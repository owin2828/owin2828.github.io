<!DOCTYPE html>

<html>

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>
    낮코밤코
  </title>

  <meta name="description" content="Already done, cause will do">

  <link href='http://cdn.jsdelivr.net/gh/joungkyun/font-d2coding/d2coding.css' rel='stylesheet' type='text/css'>
  <!-- <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'> -->

  <link rel="stylesheet" href="/assets/vendor/bootstrap/css/bootstrap.css">

  <link rel="stylesheet" href="/assets/vendor/fontawesome-free/css/all.min.css">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://owin2828.github.io/search.html">
  <link rel="alternate" type="application/rss+xml" title="낮코밤코" href="/feed.xml">

  <!-- 웹 폰트 설정 -->
  <!-- <link rel="stylesheet" href="http://cdn.jsdelivr.net/gh/joungkyun/font-d2coding/d2coding.css"> -->
  <link rel="stylesheet" href="/assets/syntax.css">
  
    <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-TVK6F4S');</script>
    <!-- End Google Tag Manager -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-154694140-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154694140-1');
</script>


</head>


<body>
  
    <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-TVK6F4S"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
  

  <!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="/">&#9750; Fake it, till U make it</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fa fa-bars"></i>
    </button>
    <div
     class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="/about">| About</a>
        <li class="nav-item">
          <a class="nav-link" href="/posts">| All Posts</a>
        </li>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href=# id="navbarDropdownMenuLink" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            | Devlog
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
            <a class="dropdown-item" href="/devlog/aws">AWS</a>
            <a class="dropdown-item" href="/devlog/cicd">CI/CD</a>
            <a class="dropdown-item" href="/devlog/java">Java</a>
            <!-- <a class="dropdown-item" href="/devlog/node">Node.js</a> -->
            <a class="dropdown-item" href="/devlog/spring">Spring</a>
            <a class="dropdown-item" href="/devlog/web">Web</a>
            <a class="dropdown-item" href="/devlog/etc">Etc</a>
          </div>
        </li>
        <!-- <li class="nav-item">
          <a class="nav-link" href="/contact">| Contact</a>
        </li> -->
        <li class="nav-item">
          <a class="nav-link" href="/search">
            <i class="fa fa-search" aria-hidden="true"></i> Search
          </a>
        </li>
      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->

<header class="masthead" style="background-image: url('/img/whale.jpg')">
  
    <div class="overlay"></div>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <div class="page-heading">
            <h1><!--낮코밤코--></h1>
            
            <span class="subheading">Already done, cause will do</span>
            
          </div>
        </div>
      </div>
    </div>
  </header>
<body>
    
  <div class="search-in">
    <form action="/search.html" method="get">
      <i class="fa fa-search" aria-hidden="true"></i>
      <input class="underline" type="text" id="search-box" name="query" placeholder="검색어를 입력해주세요." style="width:17rem">
      <!-- <input type="submit" value="search"> -->
    </form>
  </div>


<ul id="search-results"></ul>

<script>
  window.store = {
    
      "devlog-2020-01-10-aws-2-html": {
        "title": "[AWS] Region, AZ, VPC, Subnet등 구성",
        "subtitle":"AWS 기초 - 2",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "aws",
        "content": "들어가기 앞서기초적인 내용을 들어가기 전에 여담으로 aws 사용에 대한 이야기를 잠깐 하고 가겠다.퍼블릭 클라우드가 그러하듯이, aws 또한 모든것이 가상화 되어있다.이 말은 내가 신경쓰고 관리해야할 것이 전혀 없다는 말이고 모든 것을 aws가 알아서 해주는 것이다.하지만 이러한 이유로 하드웨어적 장애가 생겼을 때, 반대로 내가 할 수 있는 것은 전혀 없다.무슨 말이냐면, 하드웨어적 결함으로 어떤 에러가 발생하였을 때그게 내 문제인지, aws의 문제인지 알지 못할 수도 있다는 의미이다.생각보다 이러한 이유가 굉장히 스트레스 받는 일이 된다고 우리팀의 시니어분께서 말씀해 주셨다.  실제로 어떤 기업의 세미나에서 aws 기반 서비스를 개발하던 중, 이런 장애를 만나서 고생한 이야기를 들었다.장애의 원인이 본인들의 문제인지, aws의 결함인지 알지 못하여 문의로 해결을 받기까지 고생한 이야기인데,알 수 없는 에러와 싸우며 몇날 몇일을 고생했다고 하셨다..  하지만 이런 단점에 비해 얻는 장점이 월등히 많으므로 전세계가 aws에 열광하는 것이 아닐까각설하고 본격적으로 aws의 기초 구성에 대해 알아보도록 하자.AWS Public Cloud의 구성  출처: https://blog.leedoing.com/46AWS의 기본적인 구성요소의 단위는 다음과 같다.  region  AZ(Availability Zone)  VPC(Virtual Private Cloud)1. region구성요소 중 가장 큰 단위이며, 논리적인 단계이다.2. AZ(Availability Zone)실제 IDC 단위로써, aws 정책에 따라 하나의 region안에는 반드시 2개 이상의 AZ가 존재한다고 한다.(그림에서도 2개의 AZ가 존재한다.)시스템을 구성할 때 single AZ로 할 것인지, multi AZ로 할 것인지는 사용자의 선택사항이다.  multi AZ로 구성하여 data들을 이원화하여 안전하게 보관하는 것도 하나의 방법이고,Elastic Load Balancer를 통해 각각의 AZ가 다른 일을 수행하게 하는 것도 하나의 방법이다.3. VPC(Virtual Private Cloud)AZ 밑의 단위로써, 논리적인 구조로 하나의 IDC 처럼 동작한다.  약간 웃긴것이 분명 public 서비스인데, private가 붙었다.그 이유는 논리적인 하나의 IDC를 만들어서 개인이 사용할 수 있기 때문이라고 한다.모든 리소스는 VPC에 저장되며 한 region에 5개까지 VPC를 생성할 수 있다.(필요시 제한용량 해제 신청)물론 VPC 없이도 서버를 생성할 수 있지만, 권장되지 않는다고 한다.계정을 생성하면 기본 VPC가 생성되고 그 안에 기본적인 구성요소들이 생성된다.  이 기본 VPC는 건들지 말자. 어떤 에러들이 발생한다고 한다.  출처: https://cloudaffaire.com/create-a-vpc-interface-endpoint/위 그림에서도 볼 수 있듯이, VPC의 구성은 다음과 같이 이루어진다.  IGW(Internet Gate Way): 외부로 연결되는 인터넷 게이트웨이  Subnet: VPC의 가장 기본적인 하나의 단위로써, 각 서브넷은 public, private 중 설정이 가능private은 외부에서 접속할 수도, 외부로 나갈 수도 없음  ACL: 서브넷의 설정을 위한 방화벽  Security Group: 서브넷 하나의 보안을 설정, 주로 ACL은 두고, SG를 설정하여 보안관리  ELB(Elastic Load Balancing): 로드밸런싱과 보안 설정을 해줌private 서브넷을 만들경우, 외부와 통신이 안되는데 이때 ELB를 사용해서 외부에서 접근하도록 설정(로드밸런싱과 허용된 매서드만 접근이 가능해진다고 함)ELB의 종류는 다음과 같이 3가지 존재          Classic: 예전 방식      Application: 도메인 하위 레벨(/users 등)에 따라 다르게 웹 서버에 구성하고 이를 밸런싱      Network: 모든 프로토콜(http(s) + 커스터마이징 프로토콜)에 대해 밸런싱      3-1. Subnet과 EC2 인스턴스하나의 VPC에는 여러개의 서브넷을 생성할 수 있다.(10.1.10.100 / 10.1.10.110 등..)이때 ip를 구분하여 용도에 맞게 할당해 내부적으로 영역을 구분한다.(x.x.x.100대 이상은 외부통신, 미만은 내부통신 같은 방식)이렇게 만들어진 서브넷 하나에 만드는 서버를 우리가 아는 EC2라고 한다.오브젝트를 만들고 메모리에 올려 사용하는 것을 인스턴스라 칭하므로,가상화된 환경에 올려 사용자가 사용할 수 있도록 한 것을 EC2 인스턴스라 부른다.3-2. Bastion  출처: https://www.youtube.com/watch?v=edi1kyxznE0VPC를 구성할 때, 내부 서브넷들을 전부 private으로 설정하고 하나만 관리용 public 서브넷으로 설정한다.이 public 서브넷으로 다른 private 서브넷들을 관리하며, 이러한 관리자를 bastion이라 한다.이런 방법을 사용하려면 SG(Security Group)을 설정해 한정된 IP만 bastion에 접근하도록 허용해야 한다.  만약 전부 public으로 서브넷을 만든다면, 관리자 중 한 명만 퇴사해도 모든 서브넷의 key를 갱신해야 한다.매 번 이렇게 서브넷을 업데이트 할 수 없으므로, 전부 private으로 설정한다.3-3. NAT하지만 문제는 여전히 존재한다. 전부 private으로 만들어 버렸으니, 각 서브넷의 외부와 통신이 안된다.그럼 각 서브넷의 OS 업데이트는 어떻게 하는가?  출처: https://blog.2dal.com/2017/09/12/aws-vpc-basic/정답은 하나의 서브넷을 public으로 설정 후 outbound는 가능하게, inbound는 불가능하게 만들면 된다.이런 역할을 NAT이라 부르며 하나의 서브넷에 bastion과 NAT을 둘다 포함시킬 수도 있다.  이전에는 NAT 인스턴스를 생성해야 했으나, NAT gateway를 생성하여 서브넷 안에 포함시키면 작동하도록 변경되었다.3-4. Dev, Manage, Product VPC실제 개발 및 배포를 진행할 때는 VPC 구성을 어떻게 해야할까?여러가지 방법이 있겠지만, aws는 각 단계별로 VPC를 따로 구성하는 것을 추천한다.  출처: https://aws.amazon.com/ko/quickstart/architecture/compliance-uk-official/위의 그림은 aws 공식 홈페이지에서 가져온 것인데, Dev/Managemnet/Production 총 3단계로 구성되있다.이렇게 Stage 별로 VPC를 따로 구성해서 관리하는 것이 복잡한 서브넷간 설정을 피할 수 있기 때문이다.  물론 하나의 VPC 안에서 서브넷을 나눠 그룹별로 관리할 수도 있으나, 규모가 커졌을 때 서브넷간의 복잡한 설정으로 어려움이 따르게 된다.4. S3(Simple Storgae Service)  출처: https://www.megazone.com/techblog_191113_aws-privatelink/S3는 단순하게는 하나의 저장소이다.하지만 활용법에 따라 효율적인 정보의 전달이 가능한데, 이는 S3가 웹서버 역할을 제공하기 때문이다.이는 다음의 과정을 거쳐 이루어지게 된다.S3는 기본적으로 VPC 밖에 구성된 하나의 웹서버로써 이곳에 html 같은 정적인 파일을 주로 배치한다.End-user에게는 이곳을 보도록 설정하고, user가 원하는 요청을 수행하도록 그 파일에 스크립트로 짜놓는다.User가 해당 요청을 하게되면 스크립트가 브라우저에서 실행되어, VPC를 거쳐 EC2까지 요청을 전송한다.이러한 과정을 통해 User는 VPC를 신경쓸 필요없이 S3의 html로 결과를 받을 수 있게 된다.이러한 방식은 사실상 업계의 표준이라고 하며, 다른 오브젝트들이 이러한 S3호환 프로토콜을 제공한다.5. RDS(Relation DB Service)하나의 서브넷을 구현하고, 그 안에 DB 서버를 구축하여 운영하는 것이 기존의 방식이었다면,aws에서 제공하는 Paas의 일종인 RDS를 이용하여 더 효율적인 관리를 할 수 있다.이는 aws가 DB의 업데이트, 설치, 운영 그리고 관리까지 지원하기 때문이며, 지원하는 엔진은 다음과 같다.MySQL/Oracle/SQL Server/PostgreSQL/MariaDB/Aurora(MySQL과 호환)또한 RDS에서 Multi-AZ 옵션을 설정하면, 다른 AZ에 복제된 DB를 바로 사용할 수 있다.주로 data를 백업하여 이원화하는 용도로 많이 쓰이게 된다.  Aurora는 aws에서 제공하는 자체 DB로써 장애발생 및 AZ를 이용한 자체복구등 추가 기능을 지원한다고 한다.끝마치며aws의 기초에 대해 유능하신 어떤 분께 배운 내용을 토대로 작성된 글이다.인터넷을 찾아보면 훨씬 전문적이고 깊은 이해를 돕는 글들이 있지만,이 포스팅의 목적은 최대한 간단하게, 이해가 되도록 작성하는 것이었다.너무 긴 글이라 두개로 분리할까 고민했는데, 혹시 지치신 분들이 있다면 위로가 있기를…다음에는 간단하게 AWS VPC를 구성하는 실습을 진행해 볼 예정이다.  이번 포스팅에는 사진에 달려있는 출처들이 reference 역할을 하기 때문에 따로 참조를 달지 않았다.",
        "url": "/devlog/2020/01/10/aws-2.html"
      }
      ,
    
      "devlog-2020-01-10-aws-1-html": {
        "title": "[AWS] 퍼블릭 클라우드 vs 프라이빗 클라우드",
        "subtitle":"AWS 기초 - 1",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "aws",
        "content": "클라우드이제는 이 단어가 개발자가 아닌 주변 내 지인들에게도 전혀 낯설지 않은 단어가 되었다.그만큼 클라우드가 우리 일상에 가져오는 영향은 굉장히 크다고 할 수 있는데,이번 시리즈에서 클라우드의 기본 개념과 AWS의 기초개념 및 실습을 포스팅 하고자 한다.시리즈의 시작으로 각 클라우드의 장단점 및 고려사항부터 써보고자 한다.  클라우드의 기본 개념과 기존에 정리가 잘 된 많은 글들이 있으니,혹시 궁금한 것이 있다면 다른 글을 찾아보는 것을 추천합니다.Public Cloud나같은 일반 개발자나, 기업을 대상으로 서비스를 제공하는 클라우드 인프라를 퍼블릭 클라우드라 한다.클라우드 서비스를 제공하는 다양한 업체들(AWS, Google, MS, Alibaba, Naver)등은 가상환경 내의 서버를 임대해 준다.이러한 클라우드 서비스는 Pay-as-you-go으로 사용한 만큼 과금하는 방식을 채택하며 별도의 하드웨어가 필요하지 않다.Private Cloud하나의 조직에 전용 클라우드 환경을 제공하는 모델을 프라이빗 클라우드라 한다.(VMware, OpenStack등)사내 전용 클라우드로써, 각 조직이 더 효율적으로 관리할 수 있으나, 퍼블릭 클라우드에 비해 비용이 많이든다.각 조직에 on-premise 방식으로 적용될 수도 있고, 퍼블릭 클라우드 제공업체에서 off-premise로 호스팅 될 수도 있다.조달된 하드웨어와 가상화된 레이어 위에서 동작하기 때문에 시간이 절약되는 이점이 존재하지만,HW 관리자 – 하이퍼바이저 관리자 – SW 관리자 이런식의 구성으로 인해 하이퍼바이저의 관리가 또다른 비용발생으로 다가올 수 있다.또한 각 OS별로 라이센스를 일일히 구매해야 하므로 추가적인 비용이 발생할 수 있다.  개인적인 의견으로는 일반 사기업이 하기에는 어렵지 않나 싶다.Hybrid CloudVPN등의 보안연결을 통해서 하나 이상의 퍼블릭 클라우드 + 프라이빗 클라우드 환경을 결합하는 방식이다.두 개의 클라우드 간의 트래픽은 유동적으로 조정이 가능하여 유연한 대처가 가능하다.  프라이빗 클라우드에 많은 트래픽이 몰릴경우, 퍼블릭 클라우드로 버스팅하여 유동적인 대처가 가능하다.앞으로진행하게될 포스팅은 위에 언급한 것 중, 당연히 퍼블릭 클라우드인 aws를 이용하여 진행할 예정이다.  무료로 사용해 볼 수 있고, 가장 대중적이며 개인이 작은 규모로 해보기에 가장 좋기 때문이다.",
        "url": "/devlog/2020/01/10/aws-1.html"
      }
      ,
    
      "devlog-2020-01-09-etc-2-html": {
        "title": "[보안] 파일 업로드 취약점",
        "subtitle":"파일 업로드의 취약점과 공격,방어 방법",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "etc",
        "content": "1. 파일 업로드 취약점이란주로 게시판 등에서 파일 업로드 기능을 악용하여 시스템 권한을 획득할 수 있는 취약점을 의미한다.나처럼 보안에 대한 지식이 얕은 사람은 위의 문장이 생소하게 느껴질 것이기에, 다시 풀어 써본다.  악성 스크립트가 업로드 된 후, 서버상에서 스크립트를 실행하여 쉘을 획득하는 등의 행위로 서버를 장악할 수 있다.즉, 흔히 말하는 웹쉘의 업로드를 통해 시스템의 권한을 장악한다는 이야기이다.그렇다면 어떤 파일들이 웹에서 구동되는가? 웹 서버에서 실행 가능한 확장자는 다음과 같다.            언어      확장자                  asp, aspx      asp, aspx, htm, html, asa              php      phtml, php, php3, php4, php5, inc, htm, html              jsp, java      jsp, jspx, jsw, jsv, jspf, htm, html              perl      pl, pm, cgi, lib, htm, html              coldfusion      cfm, cfml, cfc, dbm, htm, html      이러한 악성 파일이 업로드 된다면, 접근권한, 정보유출, 악성코드 배포 등의 문제를 야기할 수 있다.2. 공격방법이러한 취약점을 찾아 공격하는 방법은 크게 4가지 정도이다.1_ 취약점 점검가장 간단한 방법으로 다음과 같은 과정을 거친다.  파일 업로드시에 확장자 제한이 없는지 확인하고,  업로드된 파일에 접근 및 실행이 가능한지 확인하여 공격하는 것이다.2_ Proxy 툴을 이용해 확장자 검사 우회 파일 업로드파일타입 변조등의 우회공격을 통해 확장자 검사를 피하는 것을 의미한다.업로드 시 파일의유형 정보를 알려주는 헤더 중, Content-type 속성을 프록시를 이용해 우회하여 공격할 수 있다.  자세한 사항은 다음 링크를 참조하시기를..https://bit.ly/2tIJ21w3_ Null을 이용한 파일 업로드널(%00)문자가 문자의 끝을 의미하기 때문에 특정 확장자를 숨기기 위한 목적으로 사용될 수 있다.해당 부분의 취약점은 내부 API를 호출할 때 발생될 가능성이 있다.  널바이트(%00)와 .jpeg확장자를 함께 접목하여 업로드하면 %00 다음의 문자열은 무시하게 된다.            언어      우회패턴      처리패턴                  php      test.php%00.jpeg      test.php              asp      test.asp%00.jpeg      test.asp              jsp      test.jsp%00.jpeg      test.jsp      4_ SQL Injection을 이용한 파일 업로드2가지 정도의 방법이 존재하는데, 다음과 같다.MySQL의 into outfile() 함수를 이용하여 웹서버에 파일을 생성할 수 있다.MSSQL의 저장 프로시저(xp_cmdshell)을 이용하여 echo와 » (파이프) 명령어를 통해 특정 파일에 삽입할 수 있다.3. 방어방법모든 부분을 전부 작성할 수는 없지만, 대략적으로 다음과 같은 방법을 통하여 기초적인 방어를 할 수 있다.  확장자 검사  대소문자 구분하지 않고 확장자 비교  특수문자가 포함된 경우 업로드 금지  업로드된 파일명, 확장자를 난수화하여 변경  업로드된 파일을 url 요청으로 직접 접근이 불가능한 위치에 저장Reference  https://4rgos.tistory.com/4",
        "url": "/devlog/2020/01/09/etc-2.html"
      }
      ,
    
      "devlog-2020-01-09-cicd-5-html": {
        "title": "[CI/CD] Jenkins vs GitLabCI vs Travis",
        "subtitle":"DevOps Full Chain - 5",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "cicd",
        "content": "이번 글에서는CI/CD 파이프라인 구축을 위한 서비스들이 무엇이 있는지 살펴보고,다음과 같은 솔루션들의 장단점을 분석하고자 한다.  Travis  GitLab CI  Jenkins1. Trvais별도의 회사였으나, GitHub에서 인수하였다.(GitHub는 MS가 인수함)오픈소스용 무료 travis.org와 Private Repo를 위한 유료 travis.com을 별도로 운영하고 있고, 내용은 동일하다.장점  GitHub와의 연동(그냥 깃허브 계정으로 로그인하며 된다.)  YML 파일을 통한 쉬운 설정  다양한 래퍼런스  직접 서버를 운영할 필요 없이, Travis에서 알아서 VM으로 호스팅해 줌  모든 job이 독립적(서로 간의 영향을 받지 않음)단점  Jenkins에 비해 플러그인의 종류가 적음  유료 서비스를 사용할 경우, 가격이 꽤 비쌈(기본: 69$/month, 일반: 129$/month)2. GitLab CIGitLab 서비스에 내장되어 있다.On-Premise 방식으로 설치하여 사용할 수도 있고, 웹 서비스로 사용할 수도 있다.GitLab CI만 Runner를 직접 호스팅하여 사용할 수 있는데, 이를 통해 고성능 혹은 서비스에 트고하된 환경에서 실행할 수 있다.  Runner: repo로부터 소스코드를 받아 해당 스크립트를 돌리는 작업을 수행GitLab의 경우shared runner를 사용해서 계획적으로 돌릴 수 있다.On-Premise 방식에서는 당연히 지원하고,GitLab의 클라우드 서비스를 사용하는 경우에도, Runner만 따로 운용할 수 있다.장점  GitLab과의 손쉬운 연동  Runner가 Docker 컨테이너 기반이라, Docker 친화적임(Docker Repo 무료 제공)  UI가 쉽고 간편함  모든 job이 독립적단점  역시나 Jenkins에 비해 플러그인의 종류가 적음  모든 job에 대해 artifact를 정의 및 업로드/다운로드를 해야함3. JenkinsJava 기반의 오픈소스로 구성되어 있으며, CI계의 아버지라 불린다.제일 오래된 만큼 다양한 플러그인을 지원하며, 사용자도 관련 문서도 많이 존재한다.장점  무료  다양한 IDE를 지원하며, 커스터마이징이 다양  많은 사용자들을 보유하고 있고, 관련 문서가 다양  호스팅을 직접해야하기 때문에 관련된 모든 부분을 관리할 수 있음단점  다양한 플러그인 -&gt; 플러그인 지옥  규모가 작은 프로젝트의 경우, 설정하는데 리소스 낭비가 발생할 수 있음  호스팅을 직접해야하기 때문에 서버 운영 및 관리 비용이 발생개인적인 견해로는CI/CD를 적용해야 한다는 생각에 제일 유명한 Jenkins를 사용하려는 사람들이 많은것 같다.하지만, Jenkins는 오래된 만큼 장단점이 확실한 솔루션임을 알고 사용했으면 좋겠다.특히 Build Server를 직접 구매 및 운영해야 하기 때문에 발생하는 단점이 생각보다 크게 다가오게 된다.하나부터 열까지 전부 환경설정을 구축해야하며, 서버를 관리하는데 발생하는 비용이 낭비가 될 수 있기 때문이다.  Jenkins를 사용할 때, 각종 방화벽 작업이나 서버의 관리 및 운용등은 생각보다 많은 리소스를 요구한다.따라서 규모가 크지않은 프로젝트거나, 외부 클라우드 서비스를 이용하는 상황등이라면 Jenkins말고 다른 서비스도 고려해볼 가치가 있다고 생각한다.내가 글을 작성하는 이 블로그 또한 Travis를 사용하여 간단한 CI/CD 형태로 빌드 및 배포하게 되어있다.개발을 하면서 느끼는 거지만, 모든 일에 정답은 없다.상황에 맞게 최선의 방법을 채택하여 가장 높은 효율을 낼 수 있는 방안을 선택하는 것도 일류 개발자의 자질이 아닐까.  이 글에서는 언급하지 않았지만, AWS, CircleCI등 수많은 다른 방법도 존재한다.Reference  https://about.gitlab.com/devops-tools/jenkins-vs-gitlab.html  https://hackernoon.com/continuous-integration-circleci-vs-travis-ci-vs-jenkins-41a1c2bd95f5  https://www.thecodecampus.de/blog/jenkins-vs-gitlab-ci/  https://blog.cookapps.io/cook-dev/tech-stack/#ci-cd",
        "url": "/devlog/2020/01/09/cicd-5.html"
      }
      ,
    
      "devlog-2020-01-08-etc-1-html": {
        "title": "[Linux] 기본 설정으로 포트 확인하기",
        "subtitle":"ping, telnet, nc, curl, bash",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "etc",
        "content": "외부 서버의 포트가 살아있는지 open여부를 점검하기이런 저런 이유로, 명령어들을 사용할 수 없는 경우가 존재한다.나도 원격 서버가 살아있는지 점검해야 하는데, host 서버에 telnet등이 지원하지 않아 고생한 경험이 있다.이러한 경우를 대비해, 서버와 통신이 되는지 확인하는 명령어를 종류에 따라 정리해 보았다.다음은 지극히 주관적인 (쉬운?) 순서대로 방법이다.1. Ping포트고 뭐고 필요 없을 때  ping은 port를 사용하지 않는다.이유는 TCP/IP 계층에서 사용되고, port가 사용되는 상위 계층인 TCP/UDP 와는 상관이 없기 때문이다.즉, ping으로는 port 확인이 불가능하다.$ ping [IP]// 예시$ ping 8.8.8.82. Telnet특정 port를 확인해야 할 경우$ telnet [IP] [PORT]  // 예시$ telnet 100.1.1.1 80803. nc(NetCat)일반적으로 UNIX의 cat명령과 비슷한 사용법 이지만, 대상이 파일이 아니라 network connection이다.포트 확인 기능 말고도 다양한 기능으로 사용이 된다.$ nc -z [IP] [PORT]// 예시$ nc -z 100.1.1.1 80804. curl대부분 서버는 telnet이 설치되어 있지만, 보안이슈나 최소 설치를 한 경우 사용이 불가능한 경우가 있다.그런 경우 다음의 명령을 사용하자. 아무리 최소 설치를 해도 curl은 설치되어 있기 때문이다.  curl의 parameter중 URL telnet 스키마를 사용하여 서버 통신 확인$ curl -v telnet://[IP]:PORT  // 예시$ curl -v telnet://100.1.1.1:80805. bash약간 하드한 방법이다. shell에 익숙하지 않은 사람들은 4번에서 끝내기를 권장한다.TCP 연결을 간단하게 bash의 내장된 기능으로 확인할 수 있다.$ timeout 5 bash -c 'cat &lt; /dev/null &gt; /dev/tcp/[IP]/[PORT]'; echo $?// 예시$ timeout 5 bash -c 'cat &lt; /dev/null &gt; /dev/tcp/100.1.1.1/8080'; echo $?// 결과$ 0   // 성공 $ 1   // 실패 연결 전 에러(hostname not known등 오류)$ 124 // 실패 Timeout 에러  echo $?는 UNIX에서 바로 전 실행의 결과를 보여주는 명령어이다.",
        "url": "/devlog/2020/01/08/etc-1.html"
      }
      ,
    
      "devlog-2020-01-08-cicd-4-html": {
        "title": "[CI/CD] 그래서 CI/CD가 뭔데?",
        "subtitle":"DevOps Full Chain - 4",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "cicd",
        "content": "드디어CI/CD까지 도착하여 포스팅을 하게 되었다.긴 시간이었고, 나 또한 그동안 배우고 겪었던 것들을 글로 풀어내느라 시간을 꽤 썼다.인터넷을 찾아보면 CI/CD에 관련된 수 많은 자료가 나오므로, 자세한 설명보다는 내가 배우고 느낀대로 적어보겠다.들어가기 앞서CI/CD라는 단어를 사용하기 전에 우리는 왜 CI/CD를 적용해야 하는가를 생각해야 한다.앞선 글 DevOps란 무엇인가?에서 설명했듯이,고객에게 가치를 빠르고 안정적으로 전달하는 것이 DevOps의 목적이고, 이를 위해 CI/CD를 활용하는 것이다.더 상세한 설명을 하기 전에,CI = 지속적인 통합 + 자동화CD = 지속적인 배포 + 자동화개발 -&gt; CI -&gt; CD 순으로 Flow가 진행됨을 먼저 알고가면 좋을 것 같다.CI / CD  출처: https://dzone.com/articles/the-complete-introduction-to-cicd-1인터넷을 찾아보면 수 많은 CI/CD pipe-line 관련 이미지가 나온다.그 중 위 이미지는 가장 간략하고 정확하게 CI/CD의 개요에 대해 설명하는 그림인것 같아 가져와봤다.이 중, 개발자가 혼자서 진행하는 부분은 CI, CD 파이프라인 중 어디에도 속하지 않는다.다시 말해서 CI/CD의 파이프라인을 태운다는 것은 협업을 기반으로 한다는 의미이다.  물론 규모가 작아 혼자서도 CI/CD 파이프 라인을 구축할 수도 있다.하지만 CI/CD 파이프라인의 극적인 효율은 협업을 할 때 나오게 된다.CI = Continuous IntegrationCI는 개발자들의 코드를 지속적, 자동적으로 빌드하고, 단위테스트를 거치며, 통합테스트를 하는 과정이다.CI의 파이프라인이 구축되어 있지 않은 극적인 상황을 생각해 보자.10명의 개발자가 각자 빌드 후, 유닛테스트를 하고 통합테스트를 진행한다.문제는 단위테스트와 통합테스트를 하는 시점이 모두에게 동일하고 명확하게 정의되기가 어렵다는 점이다.만약, 10명의 개발자가 각자 개발 후 통합테스트를 한 번에 진행한다면…?  상상은 각자의 몫이다.이제 CI를 적용해서 각 개발자들 간의 Ground Rule을 다음과 같이 세웠다고 생각해보자.  모든 개발자들은 퇴근 전 각자의 코드를 Main 코드와 통합한다.  각자의 코드가 잘 동작하는지 테스트한다.  통합테스트를 진행한다.  버그가 발견된다면, To-Do 목록에 작성하고 다음 날 업무를 수행한다.CI를 적용하기 전 상황보다는 효율적이고 소스코드의 관리도 훨씬 잘 될 것이다.하지만 글을 쓰면서도 위의 모든 과정이 너무나도 귀찮다.  당신이 개발자라면 위와 같은 과정을 수작업으로 하겠는가?누군가가 나 대신 빌드와 테스트들을 해주고 버그를 기록해준다면 얼마나 좋을까.그래서 CI/CD 파이프라인에는 필연적으로 자동화가 포함이 된다.자동화가 적용된 위의 WorkFlow는 다음과 같이 간소화 된다.  퇴근 전 각자의 코드를 Main 코드와 통합한다.  다음날 출근 후, 버그 리포팅을 기반으로 코드를 수정한다.  개발자들이 게을러야 하는 이유가 단적으로 드러나지 않는가?CD = Continuous Deploy/DeliveryCD는 개발된 SW가 배포되는 시점에 신뢰할 수 있는 수준을 유지하도록 지속적으로 관리하는 것이다.CI의 연장선상에 있으며, 이상적으로는 CI가 지속적/자동적으로 이루어진다면,CD 또한 지속적/자동적으로 이루어질 수밖에 없다.  실제로 CI/CD 파이프 라인을 구축해서 배포를 해본다면, 얼마나 효율적인지 알 수 있다.이론은별거없다. CI/CD의 등장배경과 특징 및 장점을 살펴보았지만, 이해하기 어려운 개념은 아니다.하지만 실제로 CI/CD 자동화 파이프라인을 구축하기 위해서는 많은 삽질이 필요하다.어떤 프로세스를 언제 어떻게 적용하고, 결과는 어떤 방법으로 처리할지 등이 고려되어야 한다.바닥부터 구축하라고하면 차라리 안하는게 나을수도 있지만, 역시 누군가가 만들어놓은 솔루션이 있다.Jenkins, Travis, GitLabCI 등의 CI 서버가 있고 각 솔루션의 장단점을 분석한 후에 단계별 Stage의 tool들을 살펴보러가겠다.Reference  https://dzone.com/articles/the-complete-introduction-to-cicd-1  https://www.redhat.com/ko/topics/devops/what-is-ci-cd  https://itholic.github.io/qa-cicd/",
        "url": "/devlog/2020/01/08/cicd-4.html"
      }
      ,
    
      "devlog-2020-01-07-cicd-3-html": {
        "title": "[CI/CD] Scrum? Agile?",
        "subtitle":"DevOps Full Chain - 3",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "cicd",
        "content": "Scrum이란Scrum은 그 자체로 하나의 방법론이자, Agile의 실천 도구 중 하나이다.이 말은, Agile로부터 Scrum이 등장한 것이 아니라는 이야기이다.다른 실천 도구들(칸반, XP - extreme programming, 린SW개발)등은 Agile이라는 용어 정의 전에 이미 여러 형태로 존재하였다.이후  Agile 선언문이 발표되며 이러한 방법들이 Agile 이라는 깃발 아래 모여들었고, 그 중 우리에게 익숙한 것이 Scrum이다.  결국 스크럼은 작은 개발팀, 짧은 개발 주기 및 팀원들의 생산성을 유지시켜 SW개발을 하는 대표적인 Agile 방법론이다.Scrum의 특징다음 특징들로 Scrum을 정의할 수 있다.  프로젝트 관리: 역할, 정의에 중점  시간 설정: 15분의 Daily Meeting, 1~4주 정도의 개발주기  관리체계: 요구사항(BackLog)관리, 업무 진행 가시화  팀 중심: 5~9명으로 팀 구성, 본인 task보다 급한 task를 우선시  이러한 특성은 유연하게 개발하기에 최적화 되어있는데, 특히 팀원의 수는 피자 한 판을 시켰을 때 나눠먹기 좋은 인원이라고 한다.스크럼의 5가지 가치  출처: https://www.scrum.org/resources/blog/5-scrum-values-take-center-stage항상 이러한 가치를 볼 때 손과 발이 없어지는 경험을 하지만, 그래도 정의해 보도록 한다.  Courage(용기): 갈등과 도전을 통해 일을 할 수 있는 용기  Focus(집중): 모두가 스프린트동안 같은 목표를 향해 나아가는 것  Commitment(확약): 세운 목표를 실행하는 것  Respect(존중): 팀원간 다른 객체임을 인정하고, 존중하는 것  Openess(정직): 업무상태를 공개하고, 일의 효율성을 높이는 것  일할 때 기본적으로 너무 당연한 자세 아닌가 싶지만, 실제로 스크럼을 해보면…특히 한국인의 수직적인 정서상, 팀원 간의 존중이 가장 어려운부분인것 같다.Scrum Process  출처: https://brainhub.eu/blog/differences-lean-agile-scrum/Scrum 진행은 Broduct Backlog에서 한 Sprint에 수행할 작업들을 도출한 뒤, 매일 이루어지는 Daily scrum을 통해 팀원들의 업무 진척 상황을 공유하고 필요시 지원을 하는 방식으로 이루어진다.해당 Sprint가 끝나면 Sprint 리뷰를 통해 다음 Sprint의 완급을 조절하며 이 과정을 반복한다.각 단계별 구성요소는 다음과 같다.  Product Backlog: 전체 기간동안 개발해야하는 기능, 특성 및 기술에 대한 나열. 요구사항의 우선순위 나열 필수  Sprint Planning Meeting: 해당 스프린트의 기간, 수행해야할 목록등 해당 스프린트 계획 수립  Sprint Backlog: 해당 Sprint 기간 동안 수행하는 Task 목록. Product Backlog에서 우선순위순으로 선택Scrum에서는 각 구성원이 주어진 역할을 잘 해내는것이 중요한데, 구성원들은 다음의 역할 중 하나를 따르게 된다.  Product Owner(PO):          고객, 관리자 및 팀원 간의 합의를 도출해 목표 설정      요구사항 정의, Product Backlog 간의 우선순위 조정      Product Backlog 업데이트 수행      제품을 사용할 고객이 직접 하거나, 비지니스 요구사항을 정의할 수 있는 사람        Scrum Master(SM):          팀원들이 Scrum을 올바르게 할 수 있도록 가이드하는 역할      최대한 객관적인 시각에서 Scrum의 원칙이 잘 적용될 수 있도록 도움      문제 발생시, 해결하는 역할      일이 끝났을 때, 잘 끝났는지 확인      직책에 상관없이 수행 가능        Scrum Team:          Backlog에 따라 Sprint 동안 개발하는 팀원      Cross-functional한 롤을 가진 팀원들로 구성(개발자, 디자이너, 설계자 등)      그 외 산출물로써는 Burn Down Chart가 존재하며, 각 Task별로 작업량을 측정한 뒤 작업량의 총 합에서 완료한 Task들의 작업량을 빼가며 그래프의 하강 기울기를 통해 다음 Sprint의 진행을 조절한다.  기존의 Top-Down방식과는 달리 Scrum에는 PM과 같은 직책이 존재하지 않는다.그저 서로간의 존중을 바탕으로 팀원간의 소통과 협업을 최대로 이끌어내며 일하는 것이 목표이며,Scrum Master는 권력자나 리더가 아니라 그저 조력자에 불과한 직책으로 늘 팀원들에게 귀기울이며 의견을 들어야 한다.  또한, 실제로 Scrum을 하다보면 Daily meeting이 서로 간의 감시와 업무 보고의 연장선이라고 느낄 수 있다.하지만 Scrum Master가 팀원들을 강압적으로 압박하지 않고, Daily meeting의 목적이 우선순위에 따라 Task를 수행하며 우선순위가 높은 Task에 도움이 필요하다면, 자발적으로 팀원들이 본인의 Task를 제쳐두고 도움을 주는 것임을 팀원들이 숙지하도록 도와주는 것이 중요하다.  Reference  https://brunch.co.kr/@insuk/13  https://needjarvis.tistory.com/317",
        "url": "/devlog/2020/01/07/cicd-3.html"
      }
      ,
    
      "devlog-2020-01-07-cicd-2-html": {
        "title": "[CI/CD] Agile..?",
        "subtitle":"DevOps Full Chain - 2",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "cicd",
        "content": "Agile  Agile: 날렵한, 민첩한Agile의 사전적 의미는 위와 같다.그 중, 나는 후자에 가까운 의미가 더 어울린다는 생각이 든다.민첩하게 무언가를 한다는 것은 고객에게 빠르게 가치를 전달하는 요즘 개발의 방식과 잘 맞기 때문이다.결국 Agile은 하나의 방법론이다. 민첩하게 개발을 하기 위한 방법론.그렇다면 왜 항상 Agile은 DevOps와 함께 거론되며, 어떠한 배경이 있었기에 새로운 방법론이 나오게 되었는지 알아보도록 하자.기존에는 무엇이 문제였는가?늘 새로운 것이 나오는 이유는, 기존에 존재하던 것이 현 상황에 잘 맞지 않기 때문이라 생각한다.그렇다면 이 전에 존재하던 방법론은 무엇이었길래 문제였는가?답은 Waterfall 이라 불리는 일명 ‘폭포수모델’은 개발 생태계를 지배하던 방법론이었다.계획수립 - 요구분석 - 설계 - 개발 - 테스트 - 배포의 과정을 거치는 이 방법론은 다음과 같은 장점으로 오랫동안 생태계에 군림했다.  적용사례가 풍부  전체 /현재 과정의 이해가 쉬움  문서의 관리가 쉬움이 중, 1번 장점은 생각 외로 정말 큰 장점이다.프로젝트의 크기가 크지 않고, 새로운 방법으로 도전할 리소스가 안된다면 충분히 재고할 가치가 있는 것이다.하지만 이러한 방법은 치명적인 단점을 안고 있는데, 바로 개발이병행되거나 반대로 진행되지 않는다는 것이다.시장의 변화속도가 매우 빠르고, 다양한 요구사항이 등장하는 현대에는 적용하기 어려운 방법이기 때문이다.더이상 테스트 중에 요구사항이 변경되어 처음부터 다시 시작해야하는 방법으로는 한계에 봉착한 사람들은 새로운 방법을 몰색하였고, 그 결과 Agile이 등장하게 되었다.  하지만 나는 늘 무조건 새로운 것이, 트렌디한 것이 정답은 아니며,상황에 맞는 방법을 잘 가져다가 쓰는 것이 훌륭한 선택이고 좋은 결과를 도출할 확률이 높다고 생각한다.waterfall도 요구사항이 단순하고 변경 가능성이 적거나, 프로젝트의 규모와 난이도가 낮다면 충분히 고려할 만한 방법이라는 뜻이다.그래서 Agile은단어 그대로 민첩한 개발에 중점을 두고 있다.큰 계획을 수립하지 않고 주어진 요구 사항을 스프린트에 맞춰 작은 단위로 유연하게 개발하는 방식이다.인터넷을 찾다보면 여러가지 어려운 말로 Agile을 설명하지만 결국 나는 하나의 문화라고 생각한다.  빠르고 유연하게 개발하는 문화. 이 이상으로 Agile한 것이 무엇이 있을까스프린트는다음과 같은 과정으로 이루어 진다.  고객의 피드백  다양한 방법(스크럼등)을 통해 스프린트 목표 설정  스프린트 진행  배포  1로 복귀          피드백을 받으며 지속적으로 배포하는 스프린트를 여러 번 진행하여 개발하는 것이 Agile 이다.      우리도 Agile하게 일해봐야지라는 생각은 충분히 고려를 한 후, 적용하는 것이 좋다.위에서도 언급했지만, 늘 Agile이 정답은 아니다.많은 준비를 마친 후에 비로소 걸어가야 한다고 생각한다.그래서 DevOps와 Agile은연장선상에 있다고 생각한다.Agile의 목표가 빠른 소비자 피드백을 기반하여 개발을 진행 한다면,DevOps는 개발자와 운영자의 간극을 좁혀 더욱 민첩한 개발 &amp; 배포가 가능하기 때문이다.Reference  https://blog.sonim1.com/238  https://www.sangheum.com/149",
        "url": "/devlog/2020/01/07/cicd-2.html"
      }
      ,
    
      "devlog-2020-01-07-cicd-1-html": {
        "title": "[CI/CD] DevOps란 무엇인가?",
        "subtitle":"DevOps Full Chain - 1",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "cicd",
        "content": "DevOps 등장배경  DevOps = Development + Operations하나의 소프트웨어를 개발하기 위해 여러 개발자가 동시에 협업하여 빠르게 개발할 수 있는 환경이 필요하며, 수많은 사용자를 상대로 서비스를 오픈하기 위해 안정적인 인프라가 필요하다.이러한 모순되는 두 가지, 신속함과 안정성에서 개발자와 운영자간의 충돌이 발생하게 된다.이러한 배경에서 등장하게 된 것이 DevOps이다. 자동화를 핵심으로 두 역할 간의 간극을 좁히게 해주며,업무와 정보 또한 쉽게 공유하게 해준다. 더이상 통합 빌드를 특정 시점에 진행하는 것이 아니라,주기적으로 수행하며 오류를 사전에 방지하고 시간을 단축한다.DevOps 핵심요소DevOps의 핵심요소는 CALMS로 다음과 같은 5가지 요소로 이루어져있다.  Culture(문화)  Automation(자동화)  Lean(간소화)  Measurement(측정)  Share(공유)Culture(문화)  DevOps 문화 = 협업DevOps의 문화는 도구의 문제가 아니라, 사람 간의 문제를 해결하기 위해 등장했다.Automation(자동화)  개발, 테스트 및 배포의 핵심요소자동화를 통해 막대한 이익을 얻을 수 있으며, 이는 곧 CI(지속적인 통합)과  CD(지속적인 배포)로 구성된다.또한 개발자와 운영자가 서로 업데이트한 내용을 자동화하여 확인함으로써, 즉각적인 소통을 가능하게 한다.Lean(간소화)  낭비를 제거하고 고객에게 가치를 빠르게 전달끊임없이 문제를 찾고, 해결하고, 개선하는 사고방식을 의미한다.Measurement(측정)  여러가지를 측정하고, 측정 결과를 가시화하여 보여줌실질적인 데이터를 가시화하여 제공하므로써, 지속적인 개선을 향한 노력이 실제 개선으로 나아가는지 확인 가능하다.Share(공유)  성공 여부와 상관없이 서로의 경험을 공유서로 경험을 공유함으로써, 마찰을 줄이고 서로 간의 경계를 허무는 발판이 된다.Reference  https://www.atlassian.com/ko/devops  https://www.redhat.com/ko/topics/devops#?  https://devops.com/using-calms-to-assess-organizations-devops/",
        "url": "/devlog/2020/01/07/cicd-1.html"
      }
      ,
    
      "devlog-2020-01-07-cicd-0-html": {
        "title": "[CI/CD] 데브옵스, 에자일 그리고 CI/CD 시리즈",
        "subtitle":"DevOps Full Chain - 0",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "cicd",
        "content": "개발을 하다 보면DevOps, Agile, CI/CD와 같은 이야기들이 여기저기서 들린지 꽤 되었다.사실 이러한 단어와 개념들이 나온지는 오래되었지만, 우리나라에서 적용되고 진행된지는 몇 년 안된 것 같다.들어는 보았지만 각 용어에 대한 지식이 얕기에, 이번 기회에 본 시리즈를 포스팅하며 학습할 예정이다.나는새로운 개념을 익힐 때, terminology(용어)를 굉장히 중요하게 생각하는 편이다.약간 꼰대같이 들릴 수도 있지만, 단어를 먼저 이해하는 것이 지식의 본질에 접근하는 가장 정직하고 빠른 길이라고 느껴지기 때문이다.이러한 관점에서, 새로운 단어의 의미를 알기 위해서는 그 단어가 나오게 된 배경을 아는 것이 이해를 위한 첫 걸음이라 생각하며 포스팅을 시작하고자 한다.앞으로이어지게 될 CI/CD 포스팅 시리즈는 각 개념에 대해 정의와 등장배경을 포스팅하며, 크게 다음과 같은 내용을 다룰 예정이다.  DevOps  Agile  CI/CD와 각 stage별 플랫폼여전히부족한 것이 많아 본 시리즈를 포스팅하면서도, 틀린 부분이 있을 수 있으니 언제든 피드백은 환영합니다.",
        "url": "/devlog/2020/01/07/cicd-0.html"
      }
      ,
    
      "devlog-2020-01-06-web-2-html": {
        "title": "[Web] JSTL &amp; c tag",
        "subtitle":"자바 서버페이지와 c tag에 대한 분석",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "web",
        "content": "  본 문서에서는 JSTL 및 c tag에 대하여 알아보도록 한다.  출처: https://bit.ly/2OpbwWJ, https://bit.ly/2oboH2w1. JSTLJSTL(JSP Standard Tag Library)는 JSP페이지에서 많이 사용되는논리적인 판단, 반복처리, 포맷처리를 위한 커스텀 태그를 표준으로 만들어 정의한 라이브러리1-1. Why JSTL  JSP는 HTML 코드와 스크립트릿, 표현식등의 스크립트 코드가 섞여 가독성이 떨어짐  이를 해결하기 위해 HTML 태그와 비슷한 코드를 사용해 처리하는 것이 JSTL1-2. JSTL 사용법  JSTL 사용법으로는 다음과 같이 두 가지 방법이 존재          pom.xml에 maven 의존 설정           &lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;       &lt;artifactId&gt;jstl&lt;/artifactId&gt;       &lt;version&gt;1.2&lt;/version&gt;   &lt;/dependency&gt;                    jar 파일을 WEB-INF/lib 디렉토리에 복사      1-3. JSTL이 제공하는 태그  JSTL의 태그는 다음과 같은 종류가 존재  코어          주요기능: 변수지원, 흐름제어, URL 처리      접두어: c      관련 URL: http://java.sun.com/jsp/jstl/core        XML          주요기능: XML 코어, 흐름 제어, XML 변환      접두어: x      관련 URL: http://java.sun.com/jsp/jstl/xml        국제화          주요기능: 지역, 메시지 형식, 숫자 및 날짜 형식      접두어: fmt      관련 URL: http://java.sun.com/jsp/jstl/fmt        DataBase          주요기능: SQL      접두어: sql      관련 URL: http://java.sun.com/jsp/jstl/sql        함수          주요기능: 컬렉션 처리, String 처리      접두어: fn      관련 URL: [http://java.sun.com/jsp/jstl/functions])(http://java.sun.com/jsp/jstl/functions)        이 중, 제일 많이 사용되는 태그는 c tag(코어)2. C Tag코어 태그 라이브러리는 변수 설정이나 논리 처리에 사용되는 스크립트 코드를 대체하는 태그를 제공  변수 지원:          set, remove        흐름 제어:          if, choose, forEach, forTokens        URL 처리:          import, redirect, url        기타 태그:          catch, out      2-1. set, remove (변수 설정)  &lt;c:set&gt; 태그는 EL 변수 값 혹은 EL 변수의 프로퍼티 값을 지정하거나, JSTL 태그에서 사용할 변수의 값을 처리할 때 다음과 같이 사용          &lt;c:set var=\"varName\" value=\"varValue\" [scope=\"지정영역\"] /&gt;      &lt;c:set target=\"대상\" property=\"프로퍼티 이름\" value=\"값\" /&gt;          &lt;!-- 첫번째 사용법 (jstl 변수를 생성하여 사용하는법) --&gt;  &lt;c:set var=\"test1\"  value=\"니나노\"/&gt;  &lt;!-- 두번째 사용법 (빈즈활용) --&gt;  &lt;!-- 자바 빈즈가 필요함. 한페이지에서 설명하기위해.. map 으로 대체 --&gt;  &lt;% Map&lt;String, String&gt; member = new HashMap&lt;String, String&gt;();  member.put(\"name\", \"홍길동\");  %&gt;          &lt;c:set var=\"member\"  value=\"&lt;%=member%&gt;\"/&gt;  &lt;div style=\"background-color: yellow;\"&gt;${member.name}&lt;/div&gt;  &lt;c:set target = \"&lt;%=member%&gt;\" property = \"name\" value = \"홍길동2\"/&gt;                          실행결과니나노홍길동홍길동2홍길동2                      &lt;c:remove&gt; 태그는  태그로 지정한 변수를 `삭제`할 때 다음과 같이 사용          &lt;c:remove var=\"varName\" [scope=\"지정영역\"] /&gt;          &lt;c:set var=\"test1\"  value=\"니나노\"/&gt;  &lt;div style=\"background-color: yellow;\"&gt;${test1}&lt;/div&gt;  &lt;!-- c:remove 사용하여 c:set 변수를 삭제 --&gt;  &lt;c:remove var = \"test1\"/&gt;  &lt;div style=\"background-color: yellow;\"&gt;${test1}&lt;/div&gt;                          실행결과니나노(빈 텍스트가 출력 됨)                    2-2. if, choose (조건문)  &lt;c:if&gt; 태그는 조건의 참/거짓 유무에 따라 분기하며 다음과 같이 사용          else는 따로 존재하지 않음, 따라서 choose를 사용              &lt;c:if test=\"조건\" [var = \"testResult\"]/&gt;          &lt;c:set var=\"test1\"  value=\"3\"/&gt;  &lt;c:if test=\"${test1 &gt; 1}\"&gt;      &lt;div style=\"background-color: yellow;\"&gt;1보다 크다&lt;/div&gt;  &lt;/c:if&gt;  &lt;c:if test=\"${test1 &lt; 1}\"&gt;      &lt;div style=\"background-color: yellow;\"&gt;1보다 작다&lt;/div&gt;  &lt;/c:if&gt;                          실행결과1보다 크다                      &lt;c:choose&gt;, &lt;c:when&gt;, &lt;c:otherwise&gt; 태그를 else if, else 대신 다음과 같이 함께 사용          &lt;c:chose&gt;&lt;c:when test=\"조건\"&gt;실행문&lt;/c:when&gt;&lt;c:otherwise&gt;실행문&lt;/c:otherwise&gt;&lt;/c:chose&gt;          &lt;c:set var=\"test1\"  value=\"3\"/&gt;  &lt;c:choose&gt;      &lt;c:when test=\"${test1 &lt; 1}\"&gt;          &lt;div style=\"background-color: yellow;\"&gt;1보다 작음&lt;/div&gt;      &lt;/c:when&gt;      &lt;c:when test=\"${test1 == 3}\"&gt;          &lt;div style=\"background-color: yellow;\"&gt;3과 같음&lt;/div&gt;      &lt;/c:when&gt;      &lt;c:otherwise&gt;          &lt;div style=\"background-color: yellow;\"&gt;쩌리&lt;/div&gt;      &lt;/c:otherwise&gt;  &lt;/c:choose&gt;                          실행결과3과 같음                    2-3. forEach, forTokens (반복문)  &lt;c:forEach&gt; 태그는 자바의 for문과 동일하며, 다음과 같이 사용          &lt;c:forEach var=\"변수\"  item = \"아이템\" [begin =\"시작값\" end=\"종료값\" step=\"증가값\" varStatus=\"현재의값\"]/&gt;          &lt;!-- memberList라는 구조체가 존재하며 프로퍼티 값은 name, age를 가짐 --&gt;  &lt;c:forEach var=\"member\" items=\"&lt;%=memberList %&gt;\" &gt;      &lt;div style=\"background-color: yellow;\"&gt;          이름 : ${member.name} 나이 : ${member.age}      &lt;/div&gt;  &lt;/c:forEach&gt;                          실행결과이름: 홍길동 나이: 21이름: 김순이 나이: 23                      &lt;c:forTokens&gt; 태그는 자바의 split 기능과 유사하며, 다음과 같이 사용          &lt;c:forTokens var=\"변수\" items=\"아이템\" delims=\"자를 문구\" [varStatus=\"status\"]/&gt;          &lt;c:set var=\"nameGroup\" value=\"철수,영미,나미,우솝,루피\"/&gt;  &lt;c:forTokens var=\"name\" items=\"${nameGroup}\" delims=\",\"&gt;      &lt;div style=\"background-color: yellow;\"&gt;          이름 : ${name}      &lt;/div&gt;  &lt;/c:forTokens&gt;                          실행결과이름: 철수이름: 영미이름: 나미이름: 우솝이름: 루피                    2-4. url, imnport, redirect (URL 처리)  해당 태그들은 문법만 정리  &lt;c:url value = \"링크\"/&gt;  &lt;c:import url=\"url\" [context=\"context\"] [var=\"varName\"]  [scope=\"{page|request|session|application}\"] [charEncoding=\"charEncoding\"]&gt;  &lt;c:redirect url=\"value\" [context=\"context\"]/&gt;2-5. catch, out (기타)  해당 태그들은 문법만 정리  &lt;c:catch var=\"명칭\"&gt;&lt;/c:catch&gt;  &lt;c:out value=\"value\" [escapeXml=\"{true|false}\"] [default=\"value가 없을 때 표시될 문자\"]  /&gt;",
        "url": "/devlog/2020/01/06/web-2.html"
      }
      ,
    
      "devlog-2020-01-06-web-1-html": {
        "title": "[Web] Get VS Post",
        "subtitle":"HTTP 프로토콜에 대한 분석",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "web",
        "content": "  본 문서에서는 GET / POST 방식에 대하여 알아보도록 한다.  출처: https://bit.ly/31M2YN8 0. 들어가기 앞서  사용자는 단순히 URL을 입력하여 페이지로 이동을 하지만, 서버 내부에서는 클라이언트의 요청에 응답하기 위해 처리를 해주어야 함  이 때,  클라이언트가 서버로 요청을 보내는 방법인 HTTP Method에는 크게 다음과 같은 2가지 방법이 존재          GET      POST      1. GET 방식GET은 어떤 정보를 가져와 조회하기 위해 사용하며, 간단한 데이터를 URL에 넣도록 설계된 방식으로 다음과 같은 특징을 지님1-1. GET 방식의 특징  URL에 변수(데이터)를 포함시켜 요청  데이터를 Header에 포함하여 전송  URL에 데이터가 노출  전송하는 길이에 제한  캐싱이 가능  형식          URL?변수명1=값1&amp;변수명2=값2&amp;변수명3=값3&amp;…      다음과 같이 직접 URI를 입력하여 요청가능                  /hello/test.php?name1=value1&amp;name2=value2                    2. POST 방식POST 방식은 데이터를 서버로 제출하여 추가 또는 수정하기 위해서 데이터를 전송하는 방식으로 다음과 같은 특징을 지님2-1. POST 방식의 특징  URL에 변수(데이터)를 포함하지 않고시켜 요청  데이터를 Body에 포함하여 전송  URL에 데이터가 노출되지 않음  전송하는 길이에 제한이 없음  캐싱이 불가능  형식          POST /hello/test.php HTTP/1.1    Host: jmnote.com    name1=value1&amp;name2=value2      ",
        "url": "/devlog/2020/01/06/web-1.html"
      }
      ,
    
      "devlog-2020-01-06-java-5-html": {
        "title": "[Java] JDBC / JPA &amp; Hibernate / Mybatis 차이",
        "subtitle":"SQL Mapper 와 ORM의 개념 및 차이점 분석",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "java",
        "content": "  본 문서에서는 JDBC, JPA/Hybernate, Mybatis에 대하여 알아보도록 한다.  출처: http://bitly.kr/C72t7zb0. 영속성  데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성  Persistence Layer: 프로그램 아키텍쳐에서 데이터에 영속성을 부여해주는 계층  Persistence Framework: JDBC 프로그래밍의 복잡함 없이 간단히 DB와 연동되는 시스템을 빠르게 개발할 수 있으며,안정성을 보장해주는 프레임크. 그 종류는 다음과 같다.          SQL Mapper      ORM      0-1. SQL Mapper  SQL &lt;- 매핑 -&gt; Object 필드  SQL문으로 직접 DB의 데이터를 다룸          종류: Mybatis, JdbcTemplates등      0-2. ORM  DB 데이터 &lt;- 매핑 -&gt; Object 필드  객체를 통해 간접적으로 DB의 데이터를 다룸          직관적 코드(매서드)를 통해 조작 가능      객체 간의 관계를 바탕으로 SQL을 자동 생성      종류: JPA, Hibernate등      0-3. ORM의 장,단점장점  객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와줌  재사용 및 유지보수의 편리성이 증가함  DBMS에 대한 종속성이 줄어듬단점  완벽한 ORM 으로만 서비스를 구현하기가 어려움  잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점 발생  프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어려움 1. JDBC(Java Database Connectivity)  JDBC는 DB에 접근할 수 있도록 java에서 제공하는 API  모든 Java의 Data Access 기술의 근간  모든 Persistence Framework는 내부적으로 JDBC API를 사용 2. JPA(Java Persistence API)  Java ORM 기술에 대한 API 표준 명세로 Java에서 제공하는 API  JPA의 구성요소          javax.persistence 패키지로 정의된 API      JPQL(Java Persistence Query Language)      객체/관계 메타데이터        사용자가 원하는 JPA 구현체를 선택해 사용 가능          Hibernate, EclipseLink, DataNucleus, OpenJPA, TopLink Essentails 등      2-1. Hibernate  Hibernate는 JPA의 구현체 중 하나  내부적으로 JDBC API를 사용해 SQL 구현  HQL(Hibernate Query Language)라 불리는 강력한 쿼리 언어 포함  장점          빠른 개발 가능      쿼리보다는 객체에 집중 가능      테이블 생성, 변경등 관리가 쉬움        단점          어려움(많은 것을 알아야 함)      오사용시 데이터 손실 및 성능 저하 유발       3. Mybatis  개발자가 정의한 SQL을 지원하는 SQL Mapper  DB의 레코드에 매핑하기 위해 XML과 Annotaion 사용 가능  장점          SQL에 대한 모든 컨트롤을 할 경우 적합      SQL 쿼리 최적화가 잘 되있을 경우 유용        단점          모든 관계에 대한 조작을 하고자 할 때는 적합하지 않음      ",
        "url": "/devlog/2020/01/06/java-5.html"
      }
      ,
    
      "devlog-2020-01-06-java-4-html": {
        "title": "[Java] 커넥션풀",
        "subtitle":"Java <-> DB 연결관계에 대한 해석",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "java",
        "content": "  본 문서에서는 커넥션 풀에 대하여 알아보도록 한다.1. 커넥션 풀 등장 배경  실제 서비스 운영 환경에서는 서로 다른 장비를 이용해 자바 프로그램과 DBMS를 실행이때 자바 프로그램에서 DBMS로 커넥션을 생성하는 시간은 성능 저하의 원인이 됨  동시 사용자수가 많으면 사용자마다 DB 커넥션을 생성해 DBMS에 부하를 줌  최초 연결에 따른 응답 속도 저하와 동시 접속자가 많을 때 발생하는 부하를 줄이기 위해 등장 2. 커넥션 풀의 개념 및 특징  커넥션 풀은 일정 개수의 DB 커넥션을 미리 만들어두는 기법  커넥션이 필요하다면, 풀에서 커넥션을 가져와 사용한 뒤 다시 풀에 반납  커넥션을 미리 생성하기 때문에 커넥션을 사용하는 시점에서 생성시간 단축  동시 접속자가 많더라도 생성 부하가 적기에 더 많은 동시 접속자 처리 가능  커넥션의 개수를 조절해 DBMS의 부하를 일정하게 조절 3. 커넥션 풀의 종류DB 커넥션 풀 기능을 제공하는 대표 모듈은 다음과 같다.  Tomcat JDBC  HikariCP  DBCP  c3p0",
        "url": "/devlog/2020/01/06/java-4.html"
      }
      ,
    
      "devlog-2020-01-06-java-3-html": {
        "title": "[Java] JDBC란",
        "subtitle":"Java <-> DB 연결관계에 대한 해석",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "java",
        "content": "  본 문서에서는 JDBC에 대하여 알아보도록 한다.  출처: https://bit.ly/2knY48N1. JDBC란?  Java DataBase Connectivity  JDBC는 자바 프로그램이 DBMS에 일관된 방식으로 접근할 수 있도록 API를 제공하는 자바 클래스들의 모임으로 다음의 특징을 가진다.          JDBC는 함수 호출용 SQL 인터페이스      JDBC는 ANSI SQL-92 표준을 지원      JDBC는 공통된 SQL 인터페이스를 바탕으로 함                  결과적으로 JDBC는 DB의 종류와 독립적인 API를 제공                    2. JDBC 구성 2-1. 응용프로그램  데이터베이스에 연결을 요청  데이터베이스에 SQL 문을 전송  SQL 문의 결과를 요청  오류가 발생하는 경우 오류 처리  트랜잭션을 제어2-2. 드라이버 매니저  데이터베이스에 맞는 드라이버 검색  JDBC 초기화를 위한 작업을 수행2-3. 드라이버  데이터베이스에 연결  데이터베이스에 SQL 문을 전달  응용프로그램에 검색 결과를 전달  필요한 경우 커서를 조작  필요한 경우 트랜잭션을 시작  커서란?      오라클에서 CURSOR란 시스템 글로벌 영역의 공유 풀 내에 저장공간을 사용하여 사용자가 SQL 문을 실행시키면 결과값을 저장공간에 가지고 있다가 원하는 시기에순차적으로 fetch해 처리하여 해당 결과 셋을 프로그래밍적으로 접근할수 있게 도와주는 기능    묵시적커서(Implicit Cursor)와 명시적커서(Explicit Cursor)가 존재  2-4. DB  데이터가 저장되어 있는 장소3. JDBC 코딩의 흐름  JDBC 드라이버 로드  DB 연결  DB에 데이터를 읽거나 쓰기 (SQL문)  DB 연결 종료",
        "url": "/devlog/2020/01/06/java-3.html"
      }
      ,
    
      "devlog-2020-01-06-java-2-html": {
        "title": "[Java] 추상화 클래스와 인터페이스 간의 관계",
        "subtitle":"Abstract class VS Interface",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "java",
        "content": "  본 문서에서는 추상화 클래스와 인터페이스의 공통점 및 차이에 대해 알아보도록 한다.  출처: https://bit.ly/2ZwNFGa1. 공통점  abstract class(추상 클래스)와 interface(인터페이스) 는 선언만 있고 구현 내용이 없는 클래스  자기 자신이 new를 해서 객체를 생성할 수 없으며,추상클래스를 extends 받거나, interface를 implements 한 자식만이 객체를 생성 가능  상속 받은 자식이 구현을 반드시 하도록 해야할 때 사용  선언된 type과 자식의 type이 같아야 함2. 차이점  추상화 클래스:          추상클래스의 정의는 abstract 메서드가 하나라도 존재하는 클래스를 일컫음(일부 구현된 매서드 + 구현 안된 추상화 매서드)      추상클래스를 상속받는 클래스는 반드시 추상 매서드를 구현해야 함      extends를 통해 부모 클래스를 상속        인터페이스:          인터페이스는 구현체 없이, 매서드에 대한 명세만 존재      인터페이스를 상속받는 클래스에서는 반드시 인터페이스에 있는 메소드를 모두 구현해야 함      implements를 통해 여러 개의 인터페이스를 구현      추상클래스는 단일상속이지만 interface는 다중 상속이 가능(extends + implements)      ",
        "url": "/devlog/2020/01/06/java-2.html"
      }
      ,
    
      "devlog-2020-01-06-java-1-html": {
        "title": "[Java] try~catch~finally return문 위치에 따른 결과",
        "subtitle":"문법",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "java",
        "content": "java에서 try ~ catch ~ finally 문에서 return 위치에 따른 결과  본 문서에서는 return 문의 위치에 따라 어떤 결과가 나오는지 살펴보도록 한다.  출처: https://bit.ly/2MGVKWY1. return이 try 문 안에 있을 경우public class TryCatchFinallyTrick {    public static void main(String[] args) {        System.out.println(\"The output is: \" + getName());    }    static int getName(){        int a = 3;        try{            System.out.println(\"I am try\");            a = 4;            return a;        } catch(Exception e){            System.out.println(\"I am catch\");            a = 5;        } finally {            System.out.println(\"I am finally.\");            a = 6;        }    }}  위의 예제 코드를 보며 실행 결과를 예측해보면 대부분 6이라 생각할 것이다.하지만 우리의 예상과는 달리 실행결과는 아래와 같다.          [실행결과] I am try  I am finally. The output is: 4        어째서 이런 결과가 발생할까?다른 예제를 통해 좀 더 깊게 살펴보도록 하자.2. return이 fianlly 문 안에 있을 경우public class TryCatchFinallyTrick2 {    public static void main(String[] args) {        System.out.println(\"The output is: \" + getName());    }    static String getName(){        String  name = \"a\";        try{            System.out.println(\"I am try\");            name = \"try\";            return name;        } catch(Exception e){            System.out.println(\"I am catch\");            name = \"catch\";        } finally {            System.out.println(\"I am finally.\");            name = \"finally\";            return name;        }    }}  또 다른 예제 코드를 보면, 위의 코드에서는 finally와 try 문 두 군데에 return이 위치함을 알 수 있다.  위와 같은 상황에서는 과연 어떤 실행결과를 출력할 것인가?  [실행결과]I am tryI am finally.The output is: finally",
        "url": "/devlog/2020/01/06/java-1.html"
      }
      ,
    
      "devlog-2019-12-30-spring-18-html": {
        "title": "[Spring] Spring Security",
        "subtitle":"첫걸음 - 18",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "0. 기본 보안 개념인증(Authentication)은 주체(Principal)의 신원(Identity)을 증명하는 과정  주체(Principal): 유저, 기기, 시스템 등          주로 유저(사용자)        크레덴셜(Credential): 주체가 인증을 위해 제시하는 신원 증명 정보          주체가 유저일 경우 주로 Password        인가(Authorization, 권한부여): 인증을 마친 유저에게 권한을 부여하여 특정 리소스에 접근을 허용          반드시 인증 이후에 수행        접근 통제(Access control, 접근 제어): 어플리케이션 리소스에 접근하는 행위를 제어          접근 통제 결정(Access control decision, 접근 제어 결정)이 뒤따름      1. URL 접근  Spring Security는 HTTP 요청에 서블릿 필터를 적용해 보안을 처리          AbstractSecurityWebApplicationInitializer 베이스 클래스를 상속해 구현        WebSecurityConfigurerAdapter 구성 어댑터의 configure() 매서드를 이용해 다음과 같은 기본 보안 설정 적용 가능          폼 기반 로그인 서비스      HTTP 기본 인증      로그아웃 서비스      익명 로그인      서블릿 API 연계      CSFR      보안 헤더          // TodoSecurityInitalizer.java  public class TodoSecurityInitializer extends AbstractSecurityWebApplicationInitializer {  public TodoSecurityInitializer() {      super(TodoSecurityConfig.class);  }  }                            1-1. URL 접근 보안  WebSecurityConfigurerAdapter 클래스의 configure(HttpSecurity http) 매서드는 기본적으로 다음의 특징을 지님          anyRequest().authenticated()해서 매번 요청이 들어올 때마다 반드시 인증을 받도록 강제함      HTTP 기본인증(httpBasic()) 및 폼 기반 로그인(formLogin()) 기능은 기본적으로 킴      로그인 페이지를 만들지 않으면 기본 로그인 페이지를 보이도록 구성            configure(HttpSecurity http) 매서드를 오버라이딩하여 더 정교한 인가 규칙을 적용 가능      // TodoSecurityConfig.java  @Configuration  @EnableWebSecurity  public class TodoSecurityConfig extends WebSecurityConfigurerAdapter {      @Override      protected void configure(AuthenticationManagerBuilder auth) throws Exception {          auth.inMemoryAuthentication()                  .withUser(\"user\").password(\"{noop}user\") // .password(\"user\")하면 인코딩 에러발생                  .authorities(\"USER\")                  .and()                  .withUser(\"admin\").password(\"{noop}admin\") // .password(\"admin\")하면 인코딩 에러발생                  .authorities(\"USER\", \"ADMIN\");      }      @Override      protected void configure(HttpSecurity http) throws Exception {          http.authorizeRequests() // URL 접근 보안의 시작                  .antMatchers(\"/todos*\").hasAuthority(\"USER\")                  .antMatchers(HttpMethod.DELETE, \"/todos*\").hasAuthority(\"ADMIN\")              .and()                  .formLogin()              .and()                  .csrf().disable();      }  }        URL 접근 보안은 authorizeRequests()부터 시작되며, 여러가지 매처를 통해 규칙을 지정가능          앞선 코드에서는 antMatchers로 규칙을 지정                  이때 “/todos*” 처럼 마지막에 와일드카드를 넣어줘야 쿼리 매개변수가 있는 URL도 걸림그렇지 않다면, 해커들이 아무 쿼리 변수나 덧붙여 URL 관문을 통과할 수 있음                      configure(AuthenticationManagerBuilder auth) 매서드를 통해 메모리에 유저 정보를 저장          이때, Spring5 부터 유저 정보를 메모리에 저장하면 PasswordEncoder를 찾지 못해 예외가 발생      이러한 예외를 방지하기 위해 앞선 코드처럼 {noop}를 붙여줌으로써, 내부적으로 NoOpPasswoedEncoder를 사용하겠다는 선언      위 클래스도 비권장 클래스라 좋은 방법은 아니지만, 실제 메모리에 정보를 저장하는 일은 거의 없으므로 임시사용        기본 접근 규칙 및 로그인 구성을 오버라이딩 했으므로, formLogin 기능을 다시 활성화 시켜줘야 함  앞선 코드처럼 구성하고, CSFR방어 기능을 키게 되면, 폼이 제대로 동작하지 않으므로 비활성화(활성방법 후술)1-2. CSRF 공격 방어  CSRF 방어기능은 스프링 시큐리티 기본 설정 그대로 켜두면 되지만, 필요시 csrf().disable() 로 해제 가능          CSRF 공격(Cross Site Request Forgery)은 웹 어플리케이션 취약점 중 하나로    인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격        Spring Security는 CsrfTokenRepository 인터페이스의 구현체를 이용해 토큰 값을 생성/보관하는 CsrfFilter를 추가  CSRF 방어기능이 켜진 상태로, 할 일을 완료하거나 삭제하려면 토큰이 없어서 실패          콘텐츠를 수정하는 요청을 할 때, 다음처럼 hidden input에 CSRF 토큰을 심어 서버에 재전송          &lt;input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/&gt;                            2. 웹 어플리케이션 로그인다음의 로그인 서비스는 HTTP 자동 구성을 활성화하면 자동 등록 되지만, 직접 커스터마이징 하는 경우 명시적으로 구성해야 함  예외 처리나 보안 컨텍스트 연계등 Spring Security 필수 기능      protected void configure(HttpSecurity http){      http.securityContext()          .and()          .exceptionHandling();  }        서블릿 API 연계 기능      protected void configure(HttpSecurity http){      http.servletApi();  }          2-1. HTTP 기본 인증  HTTP 기본 인증은 httpBasic()으로 구성  HTTP 기본 인증을 적용하면 대부분 브라우저는 로그인 대화상자를 띄우거나, 특정 로그인 페이지로 이동시킴      http      ...      .httpBasic();          2-2. 폼 기반 로그인  HTTP 기본 인증과 폼 기반 로그인을 동시에 활성화 할 경우, 폼 기반 로그인이 우선시 됨      formLogin() 매서드로 로그인 서비스를 구현하면, 유저가 로그인 정보를 입력하는 폼 페이지가 자동 랜더링 됨        http      ...      .formLogin();              기본 로그인 페이지가 아닌 다른 로그인 페이지를 사용하고 싶다면, login.jsp 파일을 작성 후 wepapp 루트디렉토리에 위치시킴          WEB-INF 안에 넣으면, USER는 접근조차 할 수 없음        커스텀 로그인 페이지의 URL을 다음처럼 loginPage()의 인수로 전달하고, 기본 리다이렉트 페이지 및 에러처리      http      ...      .formLogin()      .loginPage(\"/login.jsp\")      .defaultSuccessUrl(\"/messageList\")      .failureUrl(\"login.jsp?error=true\");        요청 URL에 쿼리 매개변수 error이 존재하는지 체크하고 있다면 세션 속성값을 이용해 다음처럼 최근 에러 메세지를 표시      &lt;form&gt;      ...      &lt;c:if test=\"${not empty parma.error}\"&gt;          Reason: ${sessionScope[\"SPRING_SECURITY_LAST_EXCEPTION\"].message}      ...  &lt;/form&gt;          2-3. 로그아웃 서비스  로그아웃 기능은 logout() 매서드로 구현      http      ...      .logout();        기본 URL은 /logout 이며, POST 요청일 경우에만 작동하며 로그아웃한 유저는 기본 경로(초기화면)으로 이동  다른 URL로 보내고 싶다면, 다음처럼 logoutSuccessUrl() 매서드에 지정      http      ...      .logout().logoutSuccessUrl(\"/logout.success.jsp\")      .and()      .headers();        로그아웃 이후 뒤로가기 버튼을 눌렀을 때, 브라우저가 페이지를 캐싱함으로 인해 로그인된 페이지로 이동하는 문제 발생          headers() 매서드로 보안 헤더를 활성화하여 브라우저의 페이지 캐싱을 방지      캐싱 뿐 아니라, content sniffing 방지 및 X-Frame 방어를 활성화하는 역할도 수행                  content sniffing: 바이트 스트림을 읽어 그 안의 데이터 형식을 추론하는 해킹, MIME 스니핑이라고도 불림X-Frame: 클릭 재킹은 웹 사용자를 클릭하여 사용자가 클릭 한 것으로 보이는 것과 다른 것을 클릭하여기밀 정보를 공개하거나 자신의 컴퓨터를 제어하는 악의적인 기법이다.                    2-4. 익명 로그인 구현  익명 로그인 서비스는 anonymous() 매서드에 유저명과 익명유저의 권한을 주어 다음과 같이 지정      http      ...      .and()      .anonymous().principal(\"quest\").authorities(\"ROLE_GUEST\");      // 간단하게 .anonymous()로 동작가능          2-5. Remember Me 구현  Remember Me 기능은 rememberMe() 매서드를 통해 구현          유저명, 패스워드, 리맴버 미 만료 시각, 개인키를 하나의 토큰으로 인코딩해 유저 브라우저 쿠키로 저장      재접속시 이 토큰값을 가져와 유저를 자동 로그인 시킴          http  ...  .rememberMe();                          그러나 정적인 리맴버 미 토큰은 해커가 얼마든지 빼낼 수 있어 잠재적인 보안 이슈가 존재이에 Spring Security는 토큰을 rolling 시키는 기술을 지원하며 토큰 저장을 위한 별도의 DB가 필요                    3. 유저 인증하기  Spring Security에서는 연쇄적으로 연결되 하나 이상의 인증 공급자를 이용해 인증을 수행하며, 모든 공급자의 인증 과정을 통과해야 함  대부분의 인증 공급자는 유저 세부 내용을 저장소(메모리, RDBMS, LDAP 저장소)등에서 가져온 결과와 대조하여 인증을 수행  유저 세부 내용을 저장할 때 패스워드는 해커의 공격을 당할 수 있어 주로 단방향 해시 함수를 이용해 암호화하여 저장          Spring Security는 패스워드 인코딩 알고리즘으로 MD5, SHA등을 지원        유저가 로그인할 때마다 저장소에서 조회하면 성능 저하를 유발하므로, Spring Security는 로컬 메모리와 저장 공간에 캐싱하는 기능 제공3-1. In memory 방식으로 유저 인증  유저가 적고, 정보를 수정할 일이 없을 경우      // TodoSecurityConfig.java  @Configuration  @EnableWebSecurity  public class TodoSecurityConfig extends WebSecurityConfigurerAdapter {      // 한 사람씩 withUser 매서드를 이용하여 추가      @Override      protected void configure(AuthenticationManagerBuilder auth) throws Exception {          auth.inMemoryAuthentication()                  .withUser(\"admin@ya2do.io\").password(\"secret\").authorities(\"ADMIN\",\"USER\").and()                  .withUser(\"marten@@ya2do.io\").password(\"{noop}user\").authorities(\"USER\").and()                  .withUser(\"jdoe@does.net\").password(\"unknown\").disabled(true).authorities(\"USER\");      }      ...          3-2. DB 조회 결과에 따라 유저 인증  유저의 세부 내용은 DB에 저장하는 경우가 압도적  Spring Security는 다음과 같은 두 매서드를 통해 SQL을 이용하는 조회 기능을 제공          usersByUserNameQuery()      authoritiesByUsernameQuery()          // TodoSecurityConfig.java  ...  @Override  protected void configure(AuthenticationManagerBuilder auth) throws Exception {      auth          .jdbcAuthentication()              .dataSource(dataSource())              .usersByUsernameQuery(\"SELECT username, password, 'true' as enabled FROM member WHERE username = ?\")              .authoritiesByUsernameQuery(                      \"SELECT member.username, member_role.role as authorities \" +                              \"FROM member, member_role \" +                              \"WHERE  member.username = ? AND member.id = member_role.member_id\");  }                            3-3. 패스워드 암호화  In memory 방식의 경우, passwordEncoder() 매서드에 패스워드 인코더를 지정해 암호화하여 저장 가능      // TodoSecurityConfig.java      ...      @Bean      public BCryptPasswordEncoder passwordEncoder() {          return new BCryptPasswordEncoder();      }      @Override      protected void configure(AuthenticationManagerBuilder auth) throws Exception {          auth              .jdbcAuthentication()                  .passwordEncoder(passwordEncoder())                  .dataSource(dataSource());      }              BCrypt: 단방향 해시 알고리즘으로 설계시 부터 패스워드 저장을 목적으로 설계되어 강력함      3-4. LDAP 저장소 조회 결과에 따라 유저 인증  LDAP: LDAP는 조직이나, 개체, 그리고 인터넷이나 기업 내의 인트라넷 등  네트웍 상에 있는 파일이나 장치들과 같은 자원 등의 위치를 찾을 수 있게 해주는 소프트웨어 프로토콜      LDAP의 저장소 구성은 ldapAuthentication() 매서드가 담당    유저 및 그룹을 검색하는 필터와 베이스는 콜백 매서드로 지정    Spring Security는 각 그룹마다 ROLE_ 접두어를 붙혀 권한으로 사용      // TodoSecurityConfig.java  ...  @Override  protected void configure(AuthenticationManagerBuilder auth) throws Exception {      auth          .ldapAuthentication()              .contextSource()                  .ldif(\"\")                  .url(\"ldap://ldap-server:389/dc=springrecipes,dc=com\")                  .managerDn(\"cn=Directory Manager\").managerPassword(\"ldap\")          .and()              .userSearchFilter(\"uid={0}\").userSearchBase(\"ou=people\")              .groupSearchFilter(\"member={0}\").groupSearchBase(\"ou=groups\")              .passwordCompare()                  .passwordEncoder(new BCryptPasswordEncoder())                  .passwordAttribute(\"userPassword\");  }              LDAP을 지원하는 자바 기반 오픈소스 디렉토리 서비스 엔진인 OpenDS는 기본적으로 SSHA를 사용하므로,LdapShaPasswordEncoder를 지정해야 함              SSHA: Salted Secure Hash Algorithm로서, 기존의 해싱의 단점(동일한 문자열에 대해 같은 해쉬값)을 극복하는 방법으로   무작위 문자열을 추가해 같은 문자열에 대해 매번 다른 해쉬값을 가지도록 하여 보안성을 높이는 기법            4. 접근 통제 결정      접근 통제 결정은 유저가 리소스에 접근 가능한지 판단하는 행위로서 유저 인증 상태와 리소스 속성에 따라 좌우되며,Spring Security에서는 AccessDecisionManager 인터페이스 구현을 통해 이를 판단    필요 시 직접 인터페이스를 구현할 수도 있지만, Spring Security는 거수 방식으로 동작하는 다음 3가지 결정 관리자를 기본 제공          AffirmativeBased: 하나의 거수기만 거수해도 접근 허용      ConsensusBased: 거수기 전원이 만장일치해야 접근 허용      UnanimousBased: 거수기 전원이 기권 또는 찬성해야 접근 허용(적어도 반대는 없어야 함)            위의 결정 관리자를 이용하기 위해, 접근 통제 결정에 대한 거수기 그룹을 구성해야 하며각 거수기는 AccessDecisionVoter 인터페이스를 구현하고, 유저의 리소스 접근에 대해 찬성, 기권, 반대중 하나의 의사를 표명    별도의 결정 관리자를 명시하지 않으면, AffirmativeBased를 기본 접근 통제 결정 관리자로 임명하고 다음 두 거수기를 구성          RolVoter: 유저 롤을 기준으로 접근 허용 여부를 거수, ROLE_ 접두어(다른 접두어도 가능)로 시작하는 접근 속성만 처리      AuthenticatedVoter: 유저 인증 레벨을 기준으로 접근 허용 여부를 거수하며, 다음 세 가지 접근 속성만 처리              IS_AUTHENTICATED_FULLY      IS_AUTHENTICATED_REMEMBERED      IS_AUTHENTICATED_ANONYMOUSLY                  위 3가지는 순서대로 인증레벨이 정해지며(1번이 가장 높음), 유저의 인증 레벨이 리소스 접근 레벨보다 높으면 찬성                    4-1. 표현식을 이용해 접근 통제 결정  Spring식 표현 언어인 SpEL(Spring Expression Language)를 사용  and, or, not등을 조합해 강력하고 유연한 표현식 사용 가능      // TodoSecurityConfig.java      ...      @Override      protected void configure(HttpSecurity http) throws Exception {      /*          * 유저가 ADMIN 롤을 가지고 있거나, 로컬 머신에서 로그인한 유저일 경우 삭제 권한 부여          * 유저 IP주소에 따라 허용 여부를 결정            * 주소가 127.0.0.1 또는 0:0:0:0:0:0:0:1 일때 찬성, 그렇지 않으면 반대          */          http.authorizeRequests()                  .antMatchers(\"/todos*\").hasAuthority(\"USER\")                  .antMatchers(HttpMethod.DELETE, \"/todos*\").hasAuthority(\"ADMIN\")                  .antMatchers(\"/messageDelete*)              .access(\"hasRole('ROLE_ADMIN') or hasIpAddress('127.0.0.1') or                    hasIpAddress('0:0:0:0:0:0:0:1')\")              ...      }            Spring Security는 앞선 내장 함수를 제공하지만, SecurityExpressionOperations 인터페이스를 구현해 직접 등록해 사용 가능      // ExtendWebSecurityExpressionRoot.java  /*  * 이 클래스가 상속받은 WebSecurityExpressionRoot 클래스의   * 상위 클래스인 SecurityExpressionRoot 클래스가   * SecurityExpressionOperations 인터페이스 구현 클래스  */  public class ExtendedWebSecurityExpressionRoot extends WebSecurityExpressionRoot {              public ExtendedWebSecurityExpressionRoot(Authentication a, FilterInvocation fi) {          super(a, fi);      }  /*      * 로컬 머신 로그인 여부를 체크하는 매서드를 구현해 추가      * 커스텀 표현식으로 원하는 표현식 유연하게 추가 가능       */      public boolean localAccess() {          return hasIpAddress(\"127.0.0.1\") || hasIpAddress(\"0:0:0:0:0:0:0:1\");      }  }        위와 같은 커스텀 표현식을 등록해 사용하기 위해서, SecurityExpressionHandler 인터페이스 구현체를 생성해야 함      // ExtendWevSecurityExpressionHandler.java  public class ExtendedWebSecurityExpressionHandler extends DefaultWebSecurityExpressionHandler {      private AuthenticationTrustResolver trustResolver = new AuthenticationTrustResolverImpl();      @Override      protected SecurityExpressionOperations       createSecurityExpressionRoot(Authentication authentication, FilterInvocation fi) {          // 앞선 코드에서 생성한 ExtendedWebSecurityExpressionRoot 인스턴스 생성          ExtendedWebSecurityExpressionRoot root =                  new ExtendedWebSecurityExpressionRoot(authentication, fi);          root.setPermissionEvaluator(getPermissionEvaluator());          root.setTrustResolver(trustResolver);          root.setRoleHierarchy(getRoleHierarchy());          return root;      }      ...  }        createSecurityExpressionRoot() 매서드를 오버라이드해 구현한 인스턴스를 생성  커스텀 표현식 핸들러를 다음처럼 expressionHandler() 매서드에 지정하여 커스텀 표현식을 활용      // TodoSecurityConfig.java      ...      @Override      protected void configure(HttpSecurity http) throws Exception {          http.authorizeRequests()                  .expressionHandler(new ExtendedWebSecurityExpressionHandler())                  .antMatchers(\"/todos*\").hasAuthority(\"USER\")                  .antMatchers(DELETE, \"/todos*\")                  .access(\"hasRole('ROLE_ADMIN') or localAccess()\") // 커스텀 표현식 사용              .and()      ...          4-2. Sprig Bean을 표현식에 넣어 접근 통제 결정  앞선 방식으로 Spring Security 클래스를 상속후 매서드를 오버라이드해 사용할 수 있지만, 비권장  표현식 내부에 커스텀 클래스를 만들어 사용하여, @ 어노테이션을 통해 Spring Bean으로 사용      // AccessChecker.java  public class AccessChecker {      public boolean hasLocalAccess(Authentication authentication) {          boolean access = false;          if (authentication.getDetails() instanceof WebAuthenticationDetails) {              WebAuthenticationDetails details = (WebAuthenticationDetails) authentication.getDetails();              String address = details.getRemoteAddress();              access = address.equals(\"127.0.0.1\") || address.equals(\"0:0:0:0:0:0:0:1\");          }          return access;      }  }        AccessChecker 클래스는 앞선 커스텀 표현식 핸들러와 동일한 기능을 제공하지만, Spring Security 클래스를 상속하지 않음  다음과 같은 방법으로 @accessChecker.hasLocalAccess(authentication) 표현식으로 호출 가능      // TodoSecurityConfig.java      ...      // 사용할 표현식 클래스를 Spring Bean으로 등록      @Bean      public AccessChecker accessChecker() {          return new AccessChecker();      }      @Override      protected void configure(HttpSecurity http) throws Exception {          http.authorizeRequests()                  .antMatchers(\"/todos*\").hasAuthority(\"USER\")                  .antMatchers(HttpMethod.DELETE, \"/todos*\")                  // 커스텀 매서드를 어노테이션을 통해 Bean을 부름으로써 사용                    .access(\"hasAuthority('ADMIN') or @accessChecker.hasLocalAccess(authentication)\")              .and()      ...          5. 매서드 호출 보안Spring Security는 빈 인터페이스나 구현 클래스에서 대상 매서드에 다음의 어노테이션을 선언함으로 매서드 호출을 보안  @Secured  @PreAuthorize / @PostAuthorize  @PreFilter / @PostFilter위와 같은 어노테이션을 붙인 후, 구성 클래스 레벨에 @EnableGlobalMethodSecurity를 붙이면 보안 모드로 작동5-1. 어노테이션을 붙어 매서드 보안  @Secured 어노테이션을 매서드에 붙이면 보안이 적용      // TodoServiceImpl.java  @Service  @Transactional  class TodoServiceImpl implements TodoService {      ...      @Override      @Secured(\"USER\")      public List&lt;Todo&gt; listTodos() {...}      @Override      @Secured(\"USER\")      public void save(Todo todo) {...}      @Override      @Secured(\"USER\")      public void complete(long id) {...}      @Override      @Secured({\"USER\", \"ADMIN\"})      public void remove(long id) {...}      @Override      @Secured(\"USER\")      public Todo findById(long id) {...}  }        각 매서드에 @Secured 어노테이션을 붙인 후, String[] 타입의 access 속성에 매서드별 접근 허용 권한 설정  매서드 보안을 활성화하기 위해 구성 클래스에 다음처럼 @EnableGlobalMethodSecurity를 붙이고, 속성값 설정      @Configuration  @EnableGlobalMethodSecurity(securedEnable = true)  public class TodoWebconfiguration{...}          5-2. 어노테이션 + 표현식으로 매서드 보안(@PreAuthorize, @PostAuthorize)  조금 더 정교한 보안 규칙은 @PreAuthorize, @PostAuthorize 같은 어노테이션에 SpEL 기반의 보안 표현식을 적용  이 두 가지 어노테이션을 사용하기 위해 @EnableGlobalMethodSecurity의 prePostEnabled 속성을 true로 설정      @Configuration  @EnableGlobalMethodSecurity(prePostEnabled = true)  public class TodoWebconfiguration{...}          // TodoServiceImple.java  @Service  @Transactional  class TodoServiceImpl implements TodoService {      ...      @Override      @PreAuthorize(\"hasAuthority('USER')\")      public List&lt;Todo&gt; listTodos() {...}      @Override      @PreAuthorize(\"hasAuthority('USER')\")      public void save(Todo todo) {...}      @Override      @PreAuthorize(\"hasAuthority('USER')\")      public void complete(long id) {...}      @Override      @PreAuthorize(\"hasAnyAuthority('USER', 'ADMIN')\")      public void remove(long id) {...}  /*      * returnObject 표현식으로 결과를 처리      * 할 일을 등록한 유저 이외의 다른 유저가 호출해 Todo 객체에 접근하면 보안 예외를 던짐      */      @Override      @PreAuthorize(\"hasAuthority('USER')\")      @PostAuthorize(\"returnObject.owner == authentication.name\")      public Todo findById(long id) {...}  }        @PreAuthorize는 매서드 호출 직전, @PostAuthorize는 매서드 호출 직후 각각 동작  보안 표현식을 사용하거나, returnObject 표현식으로 매서드 호출 결과를 받아올 수 있음5-3. 어노테이션 + 표현식으로 거르기(@PreFilter, @PostFilter)  앞선 두 어노테이션은 보안 규칙에 맞지 않을 경우 에러를 던지지만, @PreFilter/@PostFilter는 단순히 접근 권한을 체크  TodoList에 구현된 전체 데이터는 ADMIN만 볼 수 있고, USER는 본인의 일만 열람 가능하도록 다음처럼 제한을 둠      // TodoServiceImple.java      ...      @Override      @PreAuthorize(\"hasAuthority('USER')\")      @PostFilter(\"hasAnyAuthority('ADMIN') or filterObject.owner == authentication.name\")      public List&lt;Todo&gt; listTodos() {          return todoRepository.findAll();      }              @PreFilter/@PostFilter는 매서드 입출력을 필터링하는 편리한 수단이지만,결과가 대용량일 경우 성능저하를 심각하게 유발하므로 주의      6. 뷰에서 보안 처리Spring Security가 제공하는 보안 처리용 JSP 태그 라이브러리를 사용  JSP 스크립트릿 (&lt;% … %&gt;)을 사용하여 Spring Security API를 호출할 수 있지만, 좋은 방법이 아니라 비권장6-1. 인증 정보 표시  뷰 페이지 헤더에 주체명과 허용 권한을 설정      &lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;  &lt;%@ taglib prefix=\"sec\" uri=\"http://www.springframework.org/security/tags\" %&gt;        &lt;sec:authentication&gt; 태그를 이용하면, 현재 유저의 Authentication 객체를 가져올 수 있어뷰에서 원하는 프로퍼티를 property 속성에 명시하는 방법으로 랜더링 가능      &lt;!-- 유저 주체명은 name 프로퍼티로 가져와 표시가능 --&gt;  &lt;h4&gt;To-dos for &lt;sec:authentication property=\"name\" /&gt;&lt;/h4&gt;        위와 같이 직접 가져와 랜더링해도 되지만, JSP 변수에 프로퍼티 값을 옮겨담아 var 속성에 이름을 지정 가능      &lt;!-- 허용 권한 목록을 authorities 변수에 담고, &lt;c:forEach&gt; 태그로 하나씩 꺼내 랜더링  --&gt;  &lt;sec:authentication property=\"authorities\" var=\"authorities\" /&gt;  &lt;ul&gt;      &lt;c:forEach items=\"${authorities}\" var=\"authority\"&gt;          &lt;li&gt;${authority.authority}&lt;/li&gt;      &lt;/c:forEach&gt;  &lt;/ul&gt;          6-2. 뷰 콘텐트를 조건부 랜더링  &lt;sec:authorize&gt; 태그를 이용해 유저 권한에 따라 뷰 콘텐트를 다음 세 방법으로 조건부 표시 가능  전부 지니는 경우     &lt;!-- ROLE_ADMIN, ROLE_USER 권한을 모두 지녔을 경우만 태그로 감싼 부분을 랜더링 --&gt; &lt;td&gt;     &lt;sec:authorize access=\"hasRole('ROLE_ADMIN') and hasRole('ROLE_USER')\"&gt;         ${todo.owner}     &lt;/sec:authorize&gt; &lt;/td&gt;        하나만 지녀도 되는 경우     &lt;!-- 두 권한 중 하나만 가져도 랜더링하려면 다음처럼 hasAnyRole 사용 --&gt; &lt;td&gt;     &lt;sec:authorize access=\"hasAnyRole('ROLE_ADMIN', 'ROLE_USER')\"&gt;         ${todo.owner}     &lt;/sec:authorize&gt; &lt;/td&gt;        지니지 않을 경우     &lt;!-- 주어진 권한을 모두 갖고 있지 않은 유저에게만 보이게 하는 경우 --&gt; &lt;td&gt;     &lt;sec:authorize access=\"!hasRole('ROLE_ADMIN') and !hasRole('ROLE_USER')\"&gt;         ${todo.owner}     &lt;/sec:authorize&gt; &lt;/td&gt;          7. 도메인 객체 보안 처리Spring Security는 자체로 ACL(Access Control List, 접근 통제 목록)을 설정하는 전용 모듈을 지원하며,ACL에는 도메인 객체와 연결하는 ID를 비롯해 여러 개의 ACE(Access Control Entry, 접근 통제 엔트리)가 포함되며 ACE는 다음처럼 구성  퍼미션(Permission, 인가받은 권한): 각 비트 값은 특정 퍼미션을 의미하는 비트 마스크이며 각 비트는(READ: 0 or 1) (WRITE: 1 or 2) (CREATE: 2 or 4) (DELETE: 3 or 8) (ADMINISTRATION: 4 or 16)으로 구성          다섯 가지 기본 퍼미션과 해당하는 비트의 쌍으로 표현이 중 안쓰는 나머지 비트를 이용해 퍼미션을 임의로 지정 가능        보안 식별자(SID, Security Identity): 각 ACE는 특정 SID에 대한 퍼미션을 지님7-1. ACL 서비스 설정  Spring은 JDBC로 RDBMS에 접속하여 ACL 데이터를 저장/조회하는 기능을 기본 지원  Spring Security는 테이블에 저장된 ACL 데이터에 접근할 수 있는 고성능 JDBC 구현체 및 API를 지원하며,ACL은 도메인 객체마다 별도로 둘 수 있어 ACL 객체를 캐싱하는 기능을 제공          Class path root에 있는 ehcache.xml 파일에 설정          &lt;!-- ehcache.xml --&gt;  ...  &lt;cache name=\"aclCache\"      maxElementsInMemory=\"1000\"      eternal=\"false\"      timeToIdleSeconds=\"600\"      timeToLiveSeconds=\"3600\"      overflowToDisk=\"true\"          /&gt;                      어플리케이션에서 사용할 ACL 모듈은 Java로 구성이 안되므로, Bean 그룹으로 구성후 등록해야 하므로 설정 파일을 작성하고 위치 등록      public class TodoSecurityInitializer extends AbstractSecurityWebApplicationInitializer {      public TodoSecurityInitializer() {          super(TodoSecurityConfig.class, TodoAclConfig.class); // TodoAclConfig 파일 위치 등록      }  }        Spring Security에서 ACL 서비스 작업은 AclService, MutableAclService 두 인터페이스로 정의      AclService는 읽기 작업을, 그 하위 인터페이스 MutableAcleService는 나머지(생성, 수정, 삭제)를 각각 기술      // TodoAclConfig.java  @Configuration  public class TodoAclConfig {      private final DataSource dataSource;      public TodoAclConfig(DataSource dataSource) {          this.dataSource = dataSource;      }      @Bean      public AclEntryVoter aclEntryVoter(AclService aclService) {          return new AclEntryVoter(aclService, \"ACL_MESSAGE_DELETE\", new Permission[]{BasePermission.ADMINISTRATION, BasePermission.DELETE});      }      @Bean      public EhCacheCacheManager ehCacheManagerFactoryBean() {          return new EhCacheCacheManager();      }      @Bean      public AuditLogger auditLogger() {          return new ConsoleAuditLogger();      }      // 자신이 가지고 있는 Permission 값으로 주어진 SID에 ACL 접근을 허용할지를 결정      @Bean      public PermissionGrantingStrategy permissionGrantingStrategy() {          return new DefaultPermissionGrantingStrategy(auditLogger());      }  /*       * 각 프로퍼티 카테고리별로 필요한 권한을 지정하는 방식으로        * 주체가 특정 ACL 프로퍼티를 변경할 권한을 갖고 있는지 판단        * 해당 코드에서는 ADMIN 권한을 지닌 유저만 ACL 소유권, 감사 세부등 ACL/ACE 정보 수정 가능      */      @Bean      public AclAuthorizationStrategy aclAuthorizationStrategy() {          return new AclAuthorizationStrategyImpl(new SimpleGrantedAuthority(\"ADMIN\"));      }      @Bean      public AclCache aclCache(CacheManager cacheManager) {          return new SpringCacheBasedAclCache(cacheManager.getCache(\"aclCache\"), permissionGrantingStrategy(), aclAuthorizationStrategy());      }  /*      * 룩업 성능을 높이고자 고급 DB 기능을 사용하려면       * 직접 LookupStrategy 인스턴스를 구현해 룩업 전략을 만들어 사용      */      @Bean      public LookupStrategy lookupStrategy(AclCache aclCache) {          return new BasicLookupStrategy(this.dataSource, aclCache, aclAuthorizationStrategy(), permissionGrantingStrategy());      }          /*      * ACL 구성 파일의 핵심이 되는 JdbcMutableAclService 인스턴스      * 첫 번째 인수는 ACL 데이터를 저장할 DB에 사용하는 데이터 소스        * 두 번째 인수는 표준/호환 SQL문으로 기본 룩업을 수행하는 LookupStrategy 인터페이스 구현체      * 세 번째 인수는 ACL에 적용할 캐시 인스턴스        */      @Bean      public AclService aclService(LookupStrategy lookupStrategy, AclCache aclCache) {          return new JdbcMutableAclService(this.dataSource, lookupStrategy, aclCache);      }      @Bean      public AclPermissionEvaluator permissionEvaluator(AclService aclService) {          return new AclPermissionEvaluator(aclService);      }  }          7-2. 도메인 객체에 대한 ACL 관리  Back-end 서비스와 DAO에서는 DI를 이용해 앞서 정의한 ACL 서비스를 이용해 도메인 객체용 ACL을 관리          Todo-List에서는 할 일을 등록/삭제할 때마다 각각 ACL을 생성/삭제해야 함          // TodoServiceImple.java  @Service  @Transactional  class TodoServiceImpl implements TodoService {      ...  /*      * 유저가 할 일을 등록하면 할 일 ID와 ACL 객체의 ID를 이용해 ACL을 생성함      * 생성한 ACL에 대해서는 해당 USER와 ADMIN이 READ, WRITE, DELETE를 할 수 있도록 삽입      */      @Override      @PreAuthorize(\"hasAuthority('USER')\")      public void save(Todo todo) {          this.todoRepository.save(todo);          ObjectIdentity oid = new ObjectIdentityImpl(Todo.class, todo.getId());          MutableAcl acl = mutableAclService.createAcl(oid);          acl.insertAce(0, READ, new PrincipalSid(todo.getOwner()), true);          acl.insertAce(1, WRITE, new PrincipalSid(todo.getOwner()), true);          acl.insertAce(2, DELETE, new PrincipalSid(todo.getOwner()), true);          acl.insertAce(3, READ, new GrantedAuthoritySid(\"ADMIN\"), true);          acl.insertAce(4, WRITE, new GrantedAuthoritySid(\"ADMIN\"), true);          acl.insertAce(5, DELETE, new GrantedAuthoritySid(\"ADMIN\"), true);      }      // 유저가 등록한 할 일을 삭제하면 해당 ACL도 함께 삭제      @Override      @PreAuthorize(\"hasAnyAuthority('USER','ADMIN')\")      public void remove(long id) {          todoRepository.remove(id);          ObjectIdentity oid = new ObjectIdentityImpl(Todo.class, id);          mutableAclService.deleteAcl(oid, false);      }      ...  }        JdbcMutableAclService 입장에서는 호출 매서드 쪽에서 트랜잭션을 걸어놓아야 그 트랜잭션 안에서 SQL문 수행 가능          따라서, ACL을 관리하는 앞선 매서드의 @Transactional 어노테이션을 붙임        WebMvcConfigurer 구현 클래스에서는 다음처럼 트랜잭션 관리자를 추가하고, @EnableTransactionManagement를 붙임      @Configuration  ...  @EnableTransactionManagement  public class TodoWebConfig implements WebMvcConfigurer {      ...      @Bean      public DataSourceTransactionManager transactionManager(DataSource dataSource) {          return new DataSourceTransactionManager(dataSource);      }  }          7-3. 표현식을 이용해 접근 통제 결정  도메인 객체마다 ACL을 부착했으므로, 이 객체에 속한 매서드마다 접근 통제 결정을 내리는 것이 가능          유저가 할 일을 삭제하려고 하면 ACL을 보고 그 유저가 정말 삭제할 권한이 있는지 체크 가능        ACL을 직접 구현할 필요 없이 다음 애너테이션으로 간편하게 구현 가능          @PreAuthorize/@PreFilter로 유저의 매서드 실행, 특정 매서드 인수의 사용 권한이 있는지 체크 가능      @PostAuthorize/@PostFilter로 유저가 매서드 실행 결과에 접근하거나,ACL에 따라 그 결과를 필터링 할 수 있는지 체크 가능        이러한 애너테이션은 @EnableGlobalMethodSecurity의 prePostEnabled 속성을 true로 설정해 사용 가능      @EnableGlobalMethodSecurity(prePostEnabled = true)        표현식을 사용하여 ACL로 매서드를 보안하려면 커스텀 퍼미션 평가기를 다음처럼전역 레벨에서 매서드 보안을 활성화하는 구성 클래스에 반드시 설정      // TodoWebConfig.java  @Configuration  ...  public class TodoWebConfig implements WebMvcConfigurer {      ...      @Bean      public AclPermissionEvaluator permissionEvaluator(AclService aclService) {          return new AclPermissionEvaluator(aclService);      }  }        애너테이션과 표현식을 함께 사용한 최종 클래스는 다음과 같다.      @Service  @Transactional  class TodoServiceImpl implements TodoService {      ...  /*      * @PreAuthorize는 유저가 매서드를 수행할 퍼미션을 갖고 있는지 체크        * #message는 message라는 이름의 매서드 인수를 지칭        * hasPermission은 Spring Security의 기본 표현식        * @PostFilter는 컬렉션 중 현재 유저가 읽을 권한이 없는 원소를 제거, 표현식에 사용된 filterOject가 컬렉션의 원소        * @PostAuthorize는 하나의 결과값이 사용 가능한지(유저가 그에 맞는 권한을 지니는지)를 체크, 반환값은 returnObject 키워드로 사용      */      @Override      @PreAuthorize(\"hasAuthority('USER')\")      @PostFilter(\"hasAnyAuthority('ADMIN') or hasPermission(filterObject, 'read')\")      public List&lt;Todo&gt; listTodos() {...}      @Override      @PreAuthorize(\"hasAuthority('USER')\")      public void save(Todo todo) {...}      @Override      @PreAuthorize(\"hasPermission(#id, 'com.apress.springrecipes.board.Todo', 'write')\")      public void complete(long id) {...}      @Override      @PreAuthorize(\"hasPermission(#id, 'com.apress.springrecipes.board.Todo', 'delete')\")      public void remove(long id) {...}      @Override      @PostFilter(\"hasPermission(filterObject, 'read')\")      public Todo findById(long id) {...}  }      ",
        "url": "/devlog/2019/12/30/spring-18.html"
      }
      ,
    
      "devlog-2019-12-30-spring-17-html": {
        "title": "[Spring] 프로필과 프로퍼티 파일",
        "subtitle":"첫걸음 - 17",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 프로필개발 목적 설정과 실 서비스 복적의 설정을 구분해서 작성하는 방법으로 스프링이 제공하는 기능1-1. @Configuration 설정에서 프로필 변경하기  @Configuration 어노테이션을 이용한 설정에서 프로필을 지정하려면, 다음처럼 @Profile 어노테이션을 사용      // DsDevConfig.java  @Configuration  @Profile(\"dev\")  public class DsDevConfig {      @Bean(destroyMethod = \"close\")      public DataSource dataSource() {          ...      }  }  // DsRealConfig.java  @Configuration  @Profile(\"real\")  public class DsRealConfig {      @Bean(destroyMethod = \"close\")      public DataSource dataSource() {          ...      }  }        앞선 코드의 두 클래스는 모두 이름이 “dataSource()”인 Bean을 설정  두 Bean중 어떤 빈을 사용할지는 활성화한 프로필에 따라 달라짐  특정 프로필을 선택하기 위해 컨테이너 초기화전, setActivateProfiles() 매서드를 사용    // MainProfile.javapublic class MainProfile {  public static void main(String[] args) {      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();              // 어떤 프로필을 사용할지 선택함      context.getEnvironment().setActiveProfiles(\"dev\");      ...  }}              두 개 이상의 프로필은 다음과 같이 활성화context.getEnvironment().setActivateProfiles(“dev”, “mysql”);        위와 같은 방법을 거치지 않고도, 다음과 같은 2가지 방법에 의해 프로필 설정 가능          spring.profiles.active 시스템 프로퍼티에 사용할 프로필 값 지정      OS의 spring.profiles.active 환경 변수에 값을 설정                  프로필의 우선 순위는 다음과 같다.                      setActiveProfiles()            자바 시스템 프로퍼티            OS 환경 변수                              1-2. @Configuration을 이용한 프로필 설정  중첩 클래스를 이용해 프로필 설정을 한 파일에 모을 수 있음      // MemberConfigWithProfile.java  @Configuration  @EnableTransactionManagement  public class MemberConfigWithProfile {      ...          // 같은 이름의 Bean을 등록하는 두 클래스를 다른 프로필로 설정        @Configuration      @Profile(\"dev\")      public static class DsDevConfig {          @Bean(destroyMethod = \"close\")          public DataSource dataSource() {              ...          }      }      @Configuration      @Profile(\"real\")      public static class DsRealConfig {          @Bean(destroyMethod = \"close\")          public DataSource dataSource() {              ...          }      }  }              위와 같은 방법으로 중첩 클래스를 설정할 경우, 반드시 static으로 클래스를 선언해야 함      1-3. 다수 프로필 설정  스프링 설정은 두 개 이상의 프로필 이름을 가질 수 있음      @Configuration  @Profile(\"real,test\")  public class DataSourceJndiConfig{      ...        프로필 값을 지정할 때 다음 코드처럼 느낌표(!) 사용 가능      @Configuration  @Profile(\"!real\") // 프로필이 \"dev\", \"real\" 두 개만 있다면 해당 코드는 @Profile(\"dev\")와 동일한 코드  public class DsDevConfig {      ...              보통 특정 프로필이 사용되지 않을 때, 기본으로 사용할 설정을 지정하는 용도로 사용      1-4. 어플리케이션에서 프로필 설정하기  web.xml에서 다음과 같이 spring.profiles.active 초기화 파라미터를 이용해 프로필을 선택 가능      &lt;!-- web.xml --&gt;  ...      &lt;init-param&gt;              &lt;param-name&gt;spring.profiles.active&lt;/param-name&gt;              &lt;param-value&gt;dev&lt;/param-value&gt;      &lt;/init-param&gt;  ...          2. 프로퍼티 파일을 이용한 프로퍼티 설정스프링은 외부의 프로퍼티 파일을 이용해 스프링 Bean을 설정하는 방법을 제공    # db.properties    db.driver=com.mysql.jdbc.Driver    db.url=jdbc:mysql://localhost/spring5fs?characterEncoding=utf8    db.user=spring5    db.password=spring5위 파일의 프로퍼티 값을 자바 설정에서 사용가능2-1. @Configuration 어노티에션 이용 자바 설정에서의 프로퍼티 사용  자바 설정에서 프로퍼티 파일을 사용하려면 다음 두 가지를 설정          PropertySourcePlacholderConfigurer Bean 설정      @Value 어노테이션으로 프로퍼티 값 설정          // PropertyConfig.java  @Configuration  public class PropertyConfig {      @Bean      public static PropertySourcesPlaceholderConfigurer properties() {          PropertySourcesPlaceholderConfigurer configurer =                       new PropertySourcesPlaceholderConfigurer();          configurer.setLocations(                  new ClassPathResource(\"db.properties\"),                  new ClassPathResource(\"info.properties\"));          return configurer;      }  }                PropertySourcesPlaceholderConfigurer 타입의 Bean을 설정하는 매서드는 반드시 static으로 선언해야 함          // DsConfigWithProp  @Configuration  public class DsConfigWithProp {      @Value(\"${db.driver}\")      private String driver;      @Value(\"${db.url}\")      private String jdbcUrl;      @Value(\"${db.user}\")      private String user;      @Value(\"${db.password}\")      private String password;      ...        @Value 어노테이션은 ${구분자} 형식의 플레이스홀더를 값으로 가짐  이 경우, PropertySourcesPlaceholderConfigurer는 일치하는 프로퍼티 값으로 치환",
        "url": "/devlog/2019/12/30/spring-17.html"
      }
      ,
    
      "devlog-2019-12-30-spring-16-html": {
        "title": "[Spring] JSON 응답과 요청 처리",
        "subtitle":"첫걸음 - 16",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. Jackson 의존 설정  Jackson은 자바 객체와 JSON 형식 문자열 간 변환을 처리하는 라이브러리로 다음과 같이 pom.xml에 의존을 추가      &lt;!-- pom.xml --&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;      &lt;version&gt;2.9.4&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- java8 date/time --&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;      &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;      &lt;version&gt;2.9.4&lt;/version&gt;  &lt;/dependency&gt;          2. @RestController로 JSON 형식 응답Spring MVC에서 JSON 형식으로 데이터를 응답하는 방법은 @Controller 대신 @RestController를 사용    // RestMemberController.java    // 기존의 @Controller 대신 새로운 어노테이션 사용    @RestController    public class RestMemberController {        private MemberDao memberDao;        private MemberRegisterService registerService;        /*            * 다음 두 매서드에서 기존의 String 형태의 뷰 이름을 리턴하는 것이 아니라,            * 일반 객체를 리턴함            */        @GetMapping(\"/api/members\")        public List&lt;Member&gt; members() {            return memberDao.selectAll();        }                @GetMapping(\"/api/members2/{id}\")        public Member member2(@PathVariable Long id, HttpServletResponse response) throws IOException {            Member member = memberDao.selectById(id);            if (member == null) {                response.sendError(HttpServletResponse.SC_NOT_FOUND);                return null;            }            return member;        }            ...  @RestController 어노테이션을 붙인 경우 스프링 MVC는 요청 매핑 어노테이션을 붙인 객체가 리턴한 객체를알맞은 형식으로 변환해서 응답 데이터로 전송  이때 클래스 패스에 Jackson이 존재하면 JSON 형식의 문자열로 변환해서 응답          스프링 4버전 이전에는 @RestController 어노테이션이 없기 때문에 다음과 같이 @Controller, @ResponseBody를 함께 사용      @Controllerpublic class RestMemberController {     private MemberDao memberDao;     private MemberRegisterService registerService;          @RequestMapping(path=\"/api/members\", method = RequestMethod.GET)     @ResponseBody     public List&lt;member&gt; members(){           return memberDao.selectAll();     }}                  2-1. @JsonIgnore를 이용한 예외 처리  현재 구현된 응답 결과 JSON에는 비밀번호 같은 민감한 정보가 표기되므로 이를 제외해야 함  다음과 같이 @JasonIgnore 어노테이션을 이용하여 이를 처리      public class Member {      private Long id;      private String email;      @JsonIgnore      private String password;      private String name;      private LocalDateTime registerDateTime;          ...          2-2. 날짜 형식 변환 처리: @JsonFormat  앞선 코드를 보면 registerDateTime의 타입이 LocalDateTime으로써, 이는 다음과 같은 유닉스 타임 스태프로 날짜를 표기          “registerDateTime”: 1519870069000        숫자나 배열보다는 특정 형식으로 날짜를 표현하므로, 다음과 같이 @JasonFormat 어노테이션을 이용      public class Member {          private Long id;      private String email;      @JsonIgnore      private String password;      private String name;      @JsonFormat(shape = Shape.STRING)  // ISO-8601 형식으로 변환      private LocalDateTime registerDateTime;          ...              “registerDateTime”: “2019-09-30T11:07:49”        ISO-8601 형식이 아닌 원하는 형식일 경우 다음과 같이 @JsonFormat의 pattern 속성을 이용      @JsonFormat(pattern = \"yyyyMMddHHmmss\")    private LocalDateTime registerDateTime;              “registerDateTime”: “20190930111323”      2-3. 날짜 형식 변환처리: 기본 적용 설정  날짜를 지정하는 모든 형식의 앞선 어노테이션을 일일히 붙이는 것은 비효율적      Spring MVC의 설정을 변경함으로 해결 가능      // MvcConfig.java  public class MvcConfig implements WebMvcConfigurer {      ...      @Override      public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {          ObjectMapper objectMapper = Jackson2ObjectMapperBuilder // 스프링이 제공하는 클래스                  .json()                                  // 다음 매서드는 유닉스 타임스태프로 출력하는 기능을 비활성화(ISO-8601 사용)                  .featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)                  .build();                 /*                  * 미리 등록된 HttpMessageConverter에는 Jackson을 사용하는 것도 포함되어 있으므로,                    * 새로 생성한 HttpMessageConverter는 다음과 같이 인덱스 0에 위치(맨 앞)함                  */          converters.add(0, new MappingJackson2HttpMessageConverter(objectMapper));      }  }        extendMessageConverters() 매서드는 WebMvcConfigurer에 정의된 인터페이스로,HttpMessageConverter를 추가로 설정할 때 사용  새로 생성한 ObjectMapper를 사용하는 객체를 converters의 첫 번째 항목으로 등록하면 설정 완료4. @RequestBody로 JSON 요청 처리JSON 형식의 요청 데이터를 다음과 같이 커맨드 객체에 @RequestBody 어노테이션을 붙여 자바 객체로 변환    // RestMemberController.java    @RestController    public class RestMemberController {        ...        @PostMapping(\"/api/members\")        public ResponseEntity&lt;Object&gt; newMember(                            // 다음 어노테이션을 붙임으로, JSON 형식의 문자열을 해당 자바 객체로 변환                @RequestBody @Valid RegisterRequest regReq ) {            try {                Long newMemberId = registerService.regist(regReq);                URI uri = URI.create(\"/api/members/\" + newMemberId);                return ResponseEntity.created(uri).build();            } catch (DuplicateMemberException dupEx) {                return ResponseEntity.status(HttpStatus.CONFLICT).build();            }        }        ...    }4-1. JSON 데이터의 날짜 형식 다루기  별도의 설정을 하지 않으면, JSON에서는 다음 패턴의 문자열을 LocalDateTime과 Date로 변환          yyyy-MM-ddTHH:mm:ss        특정 패턴은 @JsonFormat 어노테이션의 pattern 속성을 사용해 지정 가능      @JsonFormat(pattern = \"yyyyMMddHHmmss\")  private LocalDateTime birthDateTime;        해당 타입을 갖는 모든 속성에 적용하려면 다음과 같이 스프링 MVC 설정을 변경      // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      ...      @Override      public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {          DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");          ObjectMapper objectMapper = Jackson2ObjectMapperBuilder                  .json()                  .featuresToEnable(SerializationFeature.INDENT_OUTPUTS)                              // 다음 두 줄에 걸쳐 스프링 MVC 속성을 설정                    .deserializerByType(LocalDateTime.class, new LocalDateTimeDeserializer(formatter))                  .simpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")                  .build();          converters.add(0, new MappingJackson2HttpMessageConverter(objectMapper));      }  }          5. ResponseEntity로 객체 리턴하고 응답 코드 지정하기지금까지는 상태 코드를 지정하기 위해 다음과 같이 HttpSevletResponse의 setStatus(), sendError() 매서드를 이용    @GetMapping(\"/api/members2/{id}\")    public Member member2(@PathVariable Long id, HttpServletResponse response) throws IOException {        Member member = memberDao.selectById(id);        if (member == null) {            response.sendError(HttpServletResponse.SC_NOT_FOUND);            return null;        }        return member;    }하지만 위와 같이 404 응답을 하면 JSON 형식이 아닌 서버가 기존으로 제공하는 HTML을 응답 결과로 제공5-1. ResponseEntity를 이용한 응답 데이터 처리  앞선 문제점은 ReponseEntity를 이용하여 정상/비정상인 두 경우 모두 처리 가능  에러 상황일 때 응답으로 사용할 ErrorResponse 클래스를 다음과 같이 생성      // ErrorReponse.java  public class ErrorResponse {      private String message;      public ErrorResponse(String message) {          this.message = message;      }      public String getMessage() {          return message;      }  }        앞선 클래스를 이용하여 다음과 같이 매서드를 새롭게 구성      // RestMemberController.java  @RestController  public class RestMemberController {      ...      @GetMapping(\"/api/members/{id}\")      public ResponseEntity&lt;Object&gt; member(@PathVariable Long id) {          Member member = memberDao.selectById(id);          if (member == null) {              return ResponseEntity                      .status(HttpStatus.NOT_FOUND)                      .body(new ErrorResponse(\"no member\"));          }          return ResponseEntity.ok(member);      }  \t    ...  }        스프링 MVC에서는 ReponseEntity()의 body로 지정한 객체를 이용해 변환을 처리  ResponseEntity의 status로 지정한 값을 응답 상태 코드로 사용          ResponseEntity.status(상태코드).body(객체)결국, 위의 코드에서 member를 찾지 못한 에러가 발생시 다음과 같은 JSON형식의 데이터를 생성              실행화면{      “member” : “no member”}            5-2. @ExceptionHandler 적용 매서드에서 ReponseEntity로 응답하기  앞선 코드처럼 member가 없는 에러가 여러 곳에서 발생 한다면 코드 중복이 발생  이를 @ExceptionHandler 어노테이션을 적용한 매서드에서 에러처리를 하도록 구현해 해결      // RestMemberController.java  @GetMapping(\"/api/members3/{id}\")  public Member member3(@PathVariable Long id) {      Member member = memberDao.selectById(id);      if (member == null) {          throw new MemberNotFoundException();      }      return member;  }  // 위 매서드에서 발생하는 에러는 다음 매서드가 JSON 형식으로 처리  @ExceptionHandler(MemberNotFoundException.class)  public ResponseEntity&lt;ErrorResponse&gt; handleNoData() {      return ResponseEntity              .status(HttpStatus.NOT_FOUND)              .body(new ErrorResponse(\"no member\"));  }        @RestControllerAdvice 어노테이션을 이용해 다음처럼 에러 처리 코드를 별도 클래스로 분리 가능      // ApiExceptionAdvice.java  @RestControllerAdvice(\"controller\")  public class ApiExceptionAdvice {      @ExceptionHandler(MemberNotFoundException.class)      public ResponseEntity&lt;ErrorResponse&gt; handleNoData() {          return ResponseEntity                  .status(HttpStatus.NOT_FOUND)                  .body(new ErrorResponse(\"no member\"));      }      ...  }          5-3. @Valid 에러 결과를 JSON으로 응답하기  @Valid 어노테이션을 붙인 커맨드 객체가 값 검증에 실패하면 400코드를 HTML 응답으로 전송  이를 해결하기 위해 다음과 같이 Errors 타입 파라미터를 추가해, 직접 에러 응답을 생성      @PostMapping(\"/api/members\")  public ResponseEntity&lt;Object&gt; newMember(          @RequestBody @Valid RegisterRequest regReq,          Errors errors) {      // hasErrors()를 호출하여 검증 에러 존재를 판별      if (errors.hasErrors()) {          String errorCodes = errors.getAllErrors()                  .stream()                  .map(error -&gt; error.getCodes()[0])                  .collect(Collectors.joining(\",\"));          return ResponseEntity                  .status(HttpStatus.BAD_REQUEST)                  .body(new ErrorResponse(\"errorCodes = \" + errorCodes));      }      ...        앞선 코드에서 Errors 타입의 파라미터가 존재하지 않으면, MethodArgumentNotValidException이 발생하므로다음과 같이 @ExceptionHandler 어노테이션을 이용해 분리가능      // ApiExceptionAdvice.java  @RestControllerAdvice(\"controller\")  public class ApiExceptionAdvice {      ...      @ExceptionHandler(MethodArgumentNotValidException.class)      public ResponseEntity&lt;ErrorResponse&gt; handleBindException(MethodArgumentNotValidException ex) {          String errorCodes = ex.getBindingResult().getAllErrors()                  .stream()                  .map(error -&gt; error.getCodes()[0])                  .collect(Collectors.joining(\",\"));          return ResponseEntity                  .status(HttpStatus.BAD_REQUEST)                  .body(new ErrorResponse(\"errorCodes = \" + errorCodes));      }  }      ",
        "url": "/devlog/2019/12/30/spring-16.html"
      }
      ,
    
      "devlog-2019-12-30-spring-15-html": {
        "title": "[Spring] 간단한 웹 어플리케이션의 구조",
        "subtitle":"첫걸음 - 15",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 간단한 웹 어플리케이션의 구성 요소간단한 웹 어플리케이션을 개발할 때 사용하는 전형적인 구조는 다음 요소를 포함  프론트 서블릿  컨트롤러 + 뷰  서비스  DAO          Dispatcher Servlet -&gt; 컨트롤러 -&gt; 서비스 -&gt; DAO        컨트롤러는 실제 웹 브라우저의 요청을 처리하며, 어플리케이션이 제공하는 기능과 사용자를 연결하는 매개체실제 기능을 위한 로직은 서비스가 담당  서비스는 기능의 로직을 구현DB 연동이 필요하다면 DAO를 사용해 데이터를 가져오거나 저장2. 서비스의 구현  구현되는 서비스의 로직은 몇 단계의 과정을 거쳐 수행되며, 모든 과정을 성공적으로 진행했을 때 완료이런 이유로 서비스의 매서드를 트랜잭션 범위에서 주로 수행3. 컨트롤러에서 DAO의 접근  서비스 매서드에서 어떤 로직도 수행하지 않고 단순히 DAO의 매서드만 호출하고 끝나는 코드등은컨트롤러에서 직접 DAO에 접근가능          단순히 ID를 가지고 DAO에 접근하는 경우      4. 패키지 구성  패키지를 구성함에는 정답이 없지만, 같은 구성원 모두가 동일한 규칙에 따라 구성해야 시간 낭비를 방지          웹 어플리케이션이 복잡해지면 기존의 컨트롤러-서비스-DAO 구조 외에UI-서비스-도메인-인프라로 영역을 구성하는 \"도메인 주도 설계\"를 적용      ",
        "url": "/devlog/2019/12/30/spring-15.html"
      }
      ,
    
      "devlog-2019-12-30-spring-14-html": {
        "title": "[Spring] MVC4: 날짜 값 변환, @PathVariable, 익셉션 처리",
        "subtitle":"첫걸음 - 14",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 날짜를 이용한 회원 검색 기능  회원 가입 일자를 기준으로 검색하는 기능을 구현    // MemberDao.javapublic class MemberDao {  ...  public List&lt;Member&gt; selectByRegdate(LocalDateTime from, LocalDateTime to) {      List&lt;Member&gt; results = jdbcTemplate.query(              \"select * from MEMBER where REGDATE between ? and ? \" +                      \"order by REGDATE desc\",              memRowMapper,              from, to);      return results;  }}        selectRegDate() 매서드는 REGDATE 값이 두 파라미터로 전달받은 from과 to 사이에 있는 Member 목록을 구함1-1. 커맨드 객체 Date 타입 프로퍼티 변환 처리: @DateTimeFormat  검색을 위한 입력 폼은 다음처럼 from과 to인 &lt;input&gt; 태그를 정의      &lt;input type=\"text\" name=\"from\" /&gt;  &lt;input type=\"text\" name=\"to\" /&gt;        &lt;input&gt;에 입력한 문자열을 LocalDateTime 타입으로 변환이 필요  @DateTimeFormat 어노테이션을 적용해 다음처럼 변환      // ListCommand.java  public class ListCommand {          // 어노테이션을 적용하여 지정된 형식으로 변환      @DateTimeFormat(pattern = \"yyyyMMddHH\")      private LocalDateTime from;      @DateTimeFormat(pattern = \"yyyyMMddHH\")      private LocalDateTime to;      ...  }        컨트롤러 클래스는 별도 설정 없이 ListCommand 클래스를 커맨드 객체로 사용      // MemberListController.java  @Controller  public class MemberListController {      ...      @RequestMapping(\"/members\")      public String list(              @ModelAttribute(\"cmd\") ListCommand listCommand,              Model model) {                  // from과 to를 이용하여 member 목록을 구한 뒤, 뷰에 \"members\" 속성으로 전달          if (listCommand.getFrom() != null &amp;&amp; listCommand.getTo() != null) {              List&lt;Member&gt; members = memberDao.selectByRegdate(                      listCommand.getFrom(), listCommand.getTo());              model.addAttribute(\"members\", members);          }          return \"member/memberList\";      }  }          1-2. 변환 에러 처리  만약 폼에서 from과 to에 입력형식인 “yyyyMMddHH”와 달리 “yyyyMMdd”가 입력되면 에러 발생  이를 처리해 알맞은 에러 메시지를 보여주기 위해 다음과 같이 Errors 타입 파라미터를 요청 어노테이션 적용 매서드에 추가      // MemberListController.java  @Controller  public class MemberListController {      ...      @RequestMapping(\"/members\")      public String list(              @ModelAttribute(\"cmd\") ListCommand listCommand,              Errors errors, Model model) {          if (errors.hasErrors()) {              return \"member/memberList\";          }          if (listCommand.getFrom() != null &amp;&amp; listCommand.getTo() != null) {              List&lt;Member&gt; members = memberDao.selectByRegdate(                      listCommand.getFrom(), listCommand.getTo());              model.addAttribute(\"members\", members);          }          return \"member/memberList\";      }  }        변환 에러가 발생하게 되면, 에러 코드로 \"typeMismatch\"를 추가하므로 다음처럼 메세지 프로퍼티 파일을 통해 에러 메세지를 변경 가능      // label.properties  ...  typeMismatch.java.time.LocalDateTime = 잘못된 형식          2. @PathVariavle을 이용한 경로 변수 처리다음은 ID가 10인 회원의 정보를 조회하기 위한 URL  http://localhost:8080/sp5-hap14/members/10          회원의 ID가 달라지면 경로의 마지막 부분이 달라짐        이렇듯 경로의 일부가 고정되어 있지 않고 달라질 때 다음처럼 @PathVariable 어노테이션을 통해 가변 경로 처리 가능      // MemberDetailController.java  @Controller  public class MemberDetailController {      ...          // {}중괄호에 둘러쌓인 부분이 경로 변수      @GetMapping(\"/members/{id}\")      public String detail(@PathVariable(\"id\") Long memId, Model model) {          Member member = memberDao.selectById(memId);          if (member == null) {              throw new MemberNotFoundException();          }          model.addAttribute(\"member\", member);          return \"member/memberDetail\";      }      ...  }          3. 컨트롤러 익셉션 처리  알맞은 익셉션 처리를 하여 사용자에게 더 적합한 안내를 다음과 같이 제공          익셉션 처리를 해주지 않으면 HTTP Status 400 같은 페이지가 사용자에게 보임              컨트롤러에서 발생한 익셉션을 직접 처리하기 위해 @ExceptionHandler 어노테이션을 사용        @ControllerAdvice 어노테이션을 이용해 공통 익셉션을 처리            3-1. @Exception 어노테이션을 이용한 컨트롤러 익셉션 직접 처리  같은 컨트롤러에 @ExceptionHandler 어노테이션을 적용한 매서드가 존재하면 그 메서드가 익셉션을 처리      // MemberDetailController.java  @Controller  public class MemberDetailController {      ...      @GetMapping(\"/members/{id}\")      public String detail(@PathVariable(\"id\") Long memId, Model model) {          Member member = memberDao.selectById(memId);          if (member == null) {              throw new MemberNotFoundException();          }          model.addAttribute(\"member\", member);          return \"member/memberDetail\";      }          // 아래의 두 매서드는 각각 해당하는 타입의 익셉션을 처리하며 뷰 이름을 리턴      @ExceptionHandler(TypeMismatchException.class)      public String handleTypeMismatchException() {          return \"member/invalidId\";      }      @ExceptionHandler(MemberNotFoundException.class)      public String handleNotFoundException() {          return \"member/noMember\";      }  }          3-2. @ControllerAdvice 어노테이션을 이용한 공통 익셉션 처리  다수의 컨트롤러에서 동일 타입의 익셉션이 발생하는 경우 사용  @ControllerAdvice 어노테이션이 적용된 클래스는 지정한 범위의 컨트롤러에 공통으로 사용될 설정을 지정 가능      @ControllerAdvice 어노테이션 적용 클래스가 동작하기 위해 해당 클래스를 스프링의 Bean으로 등록해야 함      // CommonExceptionHandler.java  // spring 패키지와 그 하위 패키지에 속한 컨트롤러 클래스를 위한 공통 기능을 정의    @ControllerAdvice(\"spring\")  public class CommonExceptionHandler {          // 처리하는 익셉션의 종류는 RuntimeException      @ExceptionHandler(RuntimeException.class)      public String handleRuntimeException() {          return \"error/commonException\";      }  }          3-3. @ExceptionHandler 적용 매서드의 우선 순위  @ControllerAdvice 클래스에 있는 @ExceptionHandler 매서드와 컨트롤러 클래스에 있는 @ExceptionHandler 매서드 중,컨트롤러 클래스의 @ExceptionHandler 매서드가 우선함  컨트롤러 매서드를 실행하는 도중 익셉션이 발생하면 다음의 순서로 처리          같은 컨트롤러에 위치한 @ExceptionHandler 매서드 중 해당 익셉션을 처리할 수 있는 매서드를 검색      @ControllerAdvice 클래스에 위치한 @ExceptionHandler 매서드를 검색      ",
        "url": "/devlog/2019/12/30/spring-14.html"
      }
      ,
    
      "devlog-2019-12-30-spring-13-html": {
        "title": "[Spring] MVC3: 세션, 인터셉션, 쿠키",
        "subtitle":"첫걸음 - 13",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "0. 들어가기 앞서본 문서에서 다루는 내용은 다음과 같다.  세션  인터셉터  쿠키  쿠키와 세션?동적인 웹페이지에서 입력 정보를 유지할 필요가 있을 때 정보를 저장하는 장소에 따라 두 가지로 분류      웹 서버에 저장하는 경우: 세션              일정 시간동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고 상태를 서버에 저장하며 유지 시킴              클라이언트에 저장하는 경우: 쿠키              서버에서 생성하고 클라이언트에서 관리하며 만료시간 여부에 따라 파괴됨              데이터가 작고 중요하지 않은 데이터는 클라이언트(쿠키) 쪽에서 관리하고 나머지는 웹서버(세션)에 저장하는 것이 일반적다음과 같은 로그인 기능을 담당하는 기본적인 파일들이 본 프로젝트에 이미 구성되어 있다(소스코드 다운).  AuthInfo.java  AuthService.java  LoginCommand.java  LoginCommandValidator.java  LoginController.java  loginFrom.jsp  loginSuccess.jsp1. 컨트롤러에서 HttpSession 사용로그인 기능을 구현 후 로그인 상태를 유지하는 방법은 크게 다음과 같이 두 가지가 존재  HttpSession  쿠키컨트롤러에서 HttpSession을 사용하려면 다음의 두 가지 방법중 한 가지를 사용  요청 매핑 어노테이션 적용 매서드에 HttpSession 파라미터를 사용      @PostMapping  public String form(LoginCommand loginCommand, Errors errors, HttpSession session){      ... // session을 사용하는 코드  }        요청 매핑 어노테이션 적용 매서드에 HttpServletRequest 파라미터를 추가하고 HttpServletRequest를 이용해 HttpSession을 구함      @PostMapping  public String submit(      LoginCommand loginCommand, Errors errors, HttpServletRequest req){    HttpSession session = req.getSession();      ... // session을 사용하는 코드  }              첫 번째 방법은 항상 HttpSession을 생성하지만, 두 번째 방법은 필요한 시점에만 HttpSession을 생성두 방법 모두 기존에 존재하는 세션이 있을시, 존재하는 세션을 전달        로그인을 위한 컨트롤러 클래스는 다음과 같이 인증 정보를 세션에 담음      // LoginController.java  @Controller  @RequestMapping(\"/login\")  public class LoginController {      ...      @PostMapping      public String submit(              LoginCommand loginCommand, Errors errors, HttpSession session,              HttpServletResponse response) {          new LoginCommandValidator().validate(loginCommand, errors);          if (errors.hasErrors()) {              return \"login/loginForm\";          }          try {              AuthInfo authInfo = authService.authenticate(                      loginCommand.getEmail(),                      loginCommand.getPassword());                              // 로그인에 성공 시 HttpSession의 authInfo 속성에 인증 정보 객체(authInfo)를 저장              session.setAttribute(\"authInfo\", authInfo);          ...          } catch (WrongIdPasswordException e) {              errors.reject(\"idPasswordNotMatching\");              return \"login/loginForm\";          }      }  }          로그아웃을 위한 컨트롤러 클래스는 HttpSession을 다음과 같이 제거함      // LogoutController.java  @Controller  public class LogoutController {      @RequestMapping(\"/logout\")      public String logout(HttpSession session) {          session.invalidate();          return \"redirect:/main\";      }  }          2. 인터셉터 사용  현재 로그인하지 않고 바로 비밀번호를 변경하는 주소를 웹 브라우저에 입력할 경우 비밀번호 변경 폼이 출력 되는데,로그인하지 않고도 변경 폼이 출력되는 것은 비정상적이며 이를 방지해야 함  이를 해결하기 위해 HttpSession에 authInfo 객체의 유무를 조사 후, 리다이렉트 시키는 방법으로 해결할 수 있으나,각 기능을 구현한 모든 컨트롤러에 이런 세션 확인 코드를 삽입하는 것은 비효율적          이렇게 다수의 컨트롤러에 대해 동일한 기능을 적용해야 할 때 사용할 수 있는 것이 HandlerInterceptor       2-1. HandlerInterceptor 구현  org.springframework.web.HandlerInterceptor 인터페이스를 이용해 구현하며 다음과 같은 시점에 공통 기능 삽입 가능          컨트롤러 실행 전      컨트롤러 실행 후, 아직 뷰를 실행 전      뷰를 실행한 이후        이러한 시점을 처리하기 위해 HandlerInterceptor 인터페이스는 다음 매서드를 정의          boolean prehandle(…)      void postHandle(…)      void afterCompletion(…)        preHandle(): 리턴 타입은 boolean으로써, 만약 false를 리턴하게 되면 컨트롤러 또는 다음 핸들러인터셉터를 실행하지 않음  postHandle(): 컨트롤러가 정상적으로 실행된 이후에 추가 기능을 구현할 때 사용하며, 컨트롤러가 익셉션을 발생하면 postHandle() 매서드는 실행하지 않음      afterCompletion(): 뷰가 클라이언트에 응답을 전송한 뒤에 실행하며, 컨트롤러 실행 이후에 예기치 않게 발생한 익셉션 로그나 실행 시간을 기록하기에 적합     // AuthCheckInterceptor.java public class AuthCheckInterceptor implements HandlerInterceptor {     @Override     public boolean preHandle(             HttpServletRequest request,             HttpServletResponse response,             Object handler) throws Exception {         HttpSession session = request.getSession(false);         if (session != null) {             Object authInfo = session.getAttribute(\"authInfo\");             if (authInfo != null) {                 return true;             }         }                 // 인증정보가 없어 실패 시, 다음과 같은 경로로 리다이렉트 시킴         response.sendRedirect(request.getContextPath() + \"/login\");         return false;     } }          2-2. HandlerInterceptor 설정  HandlerInterceptor를 구현한 다음, 어디에 적용할지 설정이 다음과 같이 필요      // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      ...          // 인터셉트를 정의하는 매서드      @Override      public void addInterceptors(InterceptorRegistry registry) {          registry.addInterceptor(authCheckInterceptor())              .addPathPatterns(\"/edit/**\")              .excludePathPatterns(\"/edit/help/**\");      }      ...  }        addInterceptor 매서드는 인터셉터를 적용할 경로 패턴을 Ant 경로 패턴을 이용하여 지정          Ant 경로 패턴?Ant 패턴은 *, **, ?의 세 가지 특수 문자를 사용해 경로를 다음과 같이 표현              *: 0개 또는 그 이상의 글자        ?: 1개 글자        **: 0개 또는 그 이상의 폴더 경로따라서 앞선 코드의 경우, http://localhost:8080/sp5-chap13/edit/changePassword 에 접근하면 로그인 폼으로 리다이렉트 됨            3. 컨트롤러에서 쿠키 사용  로그인할 때 이메일을 기억하여 쿠키에 저장하는 방식을 구현  스프링 MVC에서 쿠키를 사용하는 방법 중 하나는 @CookieValue 어노테이션을 사용하는 것      @CookieValue 어노테이션은 요청 매핑 어노테이션 적용 매서드의 Cookie 타입의 파라미터에 적용      // LoginController.java  @Controller  @RequestMapping(\"/login\")  public class LoginController {      ...      @GetMapping      public String form(LoginCommand loginCommand,              /*                  * 어노테이션을 통해 쿠키의 이름을 REMEMBER로 지정                    * 지정한 이름의 쿠키가 없다면, required 속성 값을 false로 지정                  * 만약 지정한 이름의 쿠키가 없는데, required가 ture면 익셉션 발생                  */              @CookieValue(value = \"REMEMBER\", required = false) Cookie rCookie) {          if (rCookie != null) {              loginCommand.setEmail(rCookie.getValue());              loginCommand.setRememberEmail(true);          }          return \"login/loginForm\";      }  /*      * 실제 쿠키를 생성하는 부분은 로그인을 처리하는 다음 매서드      * 쿠키를 사용하기 위해 HttpServletResponse 객체가 필요하므로 파라미터로 전달      */      @PostMapping      public String submit(              LoginCommand loginCommand, Errors errors, HttpSession session,              HttpServletResponse response) {          ...                  // 쿠키를 추가하는 코드          Cookie rememberCookie =                   new Cookie(\"REMEMBER\", loginCommand.getEmail());          rememberCookie.setPath(\"/\");                              /*                  * 로그인에 성공했을 때, 이메일 기억하기 체크박스 선택 여부에 따라                  * 30일동안 유지되는 쿠키를 생성하거나                  * 바로 삭제되는 쿠키를 생성                  */          if (loginCommand.isRememberEmail()) {              rememberCookie.setMaxAge(60 * 60 * 24 * 30);          } else {              rememberCookie.setMaxAge(0);          }          response.addCookie(rememberCookie);          ...      }  }      ",
        "url": "/devlog/2019/12/30/spring-13.html"
      }
      ,
    
      "devlog-2019-12-30-spring-12-html": {
        "title": "[Spring] MVC2: 메세지, 커맨드 객체 검증",
        "subtitle":"첫걸음 - 12",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. &lt;spring:message&gt; 태그로 메세지 출력  기존 JSP에 문자열을 하드 코딩하는 방법은 다음과 같은 두 가지 문제가 존재          동일한 문자열에 대해 변경시      다국어 지원        이러한 문제를 해결하는 방법은 다음과 같다.          뷰 코드에서 사용할 문자열을 언어별로 파일에 보관      필요시 파일에서 문자열을 읽어와 출력        스프링은 이러한 기능을 자체적으로 제공하며, 다음과 같은 작업을 거친다.          문자열을 담은 메세지 파일을 작성      메세지 파일에서 값을 읽어오는 MessageSource 빈을 설정      JSP 코드에서 &lt;spring:message&gt; 태그를 사용해 메세지를 출력          // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      ...      @Bean          // Bean 등록      public MessageSource messageSource() {          ResourceBundleMessageSource ms =                   new ResourceBundleMessageSource();                  // 읽어올 파일 등록          ms.setBasenames(\"message.label\");          ms.setDefaultEncoding(\"UTF-8\");          return ms;      }  }        설정파일에 MessageSource Bean 객체를 등록          이때 Bean의 아이디를 \"messageSource\"로 지정, 다른 이름은 동작하지 않음        기본 프로퍼티 값으로 message.label을 할당          src/main/resources/message 경로에 label.properties 파일을 생성 후 아래와 같이 작성          // label.properties  member.register=회원가입  term=약관  term.agree=약관동의  ...        위 설정을 이용하여 JSP 파일을 다음과 같이 변경 가능      &lt;!-- step1.jsp --&gt;  &lt;%@ page contentType=\"text/html; charset=utf-8\" %&gt;  &lt;%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %&gt;  &lt;!DOCTYPE html&gt;  &lt;html&gt;  &lt;!-- 변경전 코드  &lt;head&gt;      &lt;title&gt;회원가입&lt;/title&gt;  &lt;/head&gt;  --&gt;  &lt;head&gt;      &lt;title&gt;&lt;spring:message code=\"member.register\" /&gt;&lt;/title&gt;  &lt;/head&gt;  ...        &lt;spring:message&gt; 태그는 MessageSource로부터 코드에 해당하는 메세지를 읽어옴1-1. 메세지 처리를 위한 MessageSource와 &lt;spring:message&gt; 태그  스프링은 지역(로케일)에 상관없이 일괄된 방법으로 문자열(메세지)를 관리할 수 있는 MessageSource 인터페이스를 정의  특정 지역에 해당하는 메세지가 필요한 코드는 MessageSource의 getMessage() 메서드를 통해 필요한 메세지를 가져와 사용  이 기능을 사용하면 국내에서 접근하면 한글로, 해외에서 접근하면 영어로 보여주는 처리 가능      // MessageSource interface  public interface MessageSource{      /*      * code 파라미터: 메세지를 구분하기 위한 코드      * locale 파라미터: 지역을 구분하기 위한 Locale      * 이 기능을 사용하면 지역에 따른 메세지 출력 가능      */      String getMessage(String code, Object[] args,          Srting defaultMessage, Locale locale);      String getMessage(String code, Object[] args, Locale locale)          throws NoSuchMessageException;      ...              다국어 메세지를 지원하려면 각 프로퍼티 파일 이름에 언어에 해당하는 로케일 문자를 다음과 같이 추가하며해당하는 지역이 없을 경우, 기본값인 label.properties 파일의 메세지를 사용              label_ko.properties        label_en.properties                    브라우저는 서버에 요청을 전송할 때 Accept-Language 헤더에 언어 정보를 담아 전송              한글일 경우 헤더값으로 “ko“를 전송            Spring MVC는 웹 브라우저가 전송한 Accept-Language 헤더를 이용해서 Locale을 구하고 메세지를 출력함      1-2. &lt;spring:message&gt; 태그의 메세지 인자 처리  &lt;spring:message&gt; 태그를 사용할 때는 arguments 속성을 이용해 인덱스 기반 변수값을 다음과 같이 전달  properties 파일에는 다음과 같이 사용할 인덱스의 정보를 이용해 메세지를 저장      &lt;!-- step3.jsp --&gt;  &lt;spring:message code=\"register.done\" arguments=\"${registerRequest.name}, ${registerRequest.email}\" /&gt;  &lt;!-- label.properties --&gt;  register.done=&lt;strong&gt;{0}님 ({1})&lt;/strong&gt;, 회원 가입을 완료했습니다.           2. 커맨드 객체의 값 검증과 에러 메세지 처리  어플리케이션을 개발할 때 놓쳐서는 안되는 다음 두 가지 문제가 존재          폼 값 검증 - 웹 페이지에 입력한 값에 대한 검증 필요      에러 메세지 처리 - 만약 잘못된 값을 입력하여 다시 페이지가 로드 된다면, 이유를 알려줌        스프링은 이 두 가지 문제를 처리하기 위해 다음 방법을 제공          커맨드 객체를 검증하고 결과를 에러 코드로 저장      JSP에서 에러 코드로부터 메세지 출력      2-1. 커맨드 객체 검증과 에러 코드 지정  스프링 MVC에서 커맨드 객체 값이 올바른지 검사하려면 다음의 두 인터페이스를 사용          org.springframework.validation.Validator      org.springframework.validation.Errors        객체를 검증할 때 사용하는 Validator 인터페이스는 다음과 같다.      package org.springframework.validation;  public interface Validator{      boolean supports(Class&lt;?&gt; clazz);      void validate(Object target, Errors errors);  }        위 코드에서 각 매서드의 역할은 다음과 같다.          supports() 매서드는 Validator가 검증할 수 있는 타입인지 검사      validate() 매서드는 첫 번째 파라미터로 전달받은 객체를 검증하고 오류 결과를 Errors에 담는 기능          // RegisterRequesValidator.java  public class RegisterRequestValidator implements Validator {      ...      /*          * 파라미터로 전달받은 clazz 객체가 RegisterRequest 클래스로 타입 변환이 가능한지 확인            * 스프링 MVC가 자동으로 검증 기능을 수행하도록 하려면 올바르게 다음 매서드를 구현해야 함          */      @Override      public boolean supports(Class&lt;?&gt; clazz) {          return RegisterRequest.class.isAssignableFrom(clazz);      }      /*          * 두 개의 파라미터중 target은 검사 대상 객체, errors는 결과 에러 코드를 설정하기 위한 객체          * validate()는 다음과 같이 구현          * 1. 검사 대상 객체의 특정 프로퍼티나 상태가 올바른지 검사           * 2. 올바르지 않다면 Errors의 rejectValue() 매서드를 이용해 에러 코드 저장          */      @Override      public void validate(Object target, Errors errors) {          System.out.println(\"RegisterRequestValidator#validate(): \" + this);          // 실제 타입으로 변환          RegisterRequest regReq = (RegisterRequest) target;                      /*                  * \"email\" 프로퍼티 값이 유효한지 검사          * 유효하지 않다면(NULL이거나 빈 문자열) 에러 코드로 \"required\"를 추가          */          if (regReq.getEmail() == null || regReq.getEmail().trim().isEmpty()) {              errors.rejectValue(\"email\", \"required\");          }          /*                  * ValidationUtils 클래스는 객체의 값 검증 코드를 간결하게 작성할 수 있도록 도와줌          * 다음의 코드들은 앞선 email을 검증하는 코드와 동일          */          ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"required\");          ValidationUtils.rejectIfEmpty(errors, \"password\", \"required\");          ValidationUtils.rejectIfEmpty(errors, \"confirmPassword\", \"required\");          if (!regReq.getPassword().isEmpty()) {              if (!regReq.isPasswordEqualToConfirmPassword()) {                  errors.rejectValue(\"confirmPassword\", \"nomatch\");              }          }      }  }        실제 Validator()는 다음과 같이 필요한 부분에서 호출 됨      // RegisterController.java  @Controller  public class RegisterController {      ...      @PostMapping(\"/register/step3\")      public String handleStep3(RegisterRequest regReq, Errors errors) {          new RegisterRequestValidator().validate(regReq, errors);          if (errors.hasErrors())              return \"register/step2\";          try {              memberRegisterService.regist(regReq);              return \"register/step3\";          } catch (DuplicateMemberException ex) {              errors.rejectValue(\"email\", \"duplicate\");              return \"register/step2\";          }      }  }          2-2. 커맨드 객체의 에러 메세지 출력  에러 코드는 알맞은 에러 메세지를 출력하기 위해 지정  JSP는 스프링이 제공하는 &lt;form:errors&gt; 태그를 이용해 에러에 해당하는 메세지를 출력      &lt;!-- step2.jsp --&gt;  ...  &lt;body&gt;      &lt;h2&gt;&lt;spring:message code=\"member.info\" /&gt;&lt;/h2&gt;      &lt;form:form action=\"step3\" modelAttribute=\"registerRequest\"&gt;      &lt;p&gt;          &lt;label&gt;&lt;spring:message code=\"email\" /&gt;:&lt;br&gt;          &lt;form:input path=\"email\" /&gt;          &lt;form:errors path=\"email\"/&gt;          &lt;/label&gt;      &lt;/p&gt;  ...        &lt;form:errors&gt; 태그의 path 속성은 에러 메세지를 출력할 프로퍼티 이름을 지정  메세지를 찾을 때는 앞서 서술한 MessageSource를 사용하므로 에러 코드에 해당하는 메세지를 프로퍼티 파일에 추가해야 함          Controller에서 에러가 발생시, Errors 객체에 추가하는 메시지를 프로퍼티 파일에 다음과 같이 추가하면 됨…required = 필수항목입니다.bad.email = 이메일이 올바르지 않습니다.      3. 글로벌 범위 Validator와 컨트롤러 범위 Validator스프링 MVC는 다음 두 가지 Validator를 제공  모든 컨트롤러에 적용할 수 있는 글로벌 Validator  단일 컨트롤러에 적용할 수 있는 Validator 3-1. 글로벌 범위 Validator 설정과 @Valid 어노테이션  글로벌 범위 Validator를 적용하려면 다음 두 가지 설정 필요          설정 클래스에서 WebMvcConfigurer 인터페이스의 getValidator() 매서드가 Validator 구현 객체를 리턴하도록 구현      글로벌 범위 Validator가 검증할 커맨드 객체에 @Valid 어노테이션 적용          // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      /*          * WebMvcConfigurer 인터페이스의 getValidator 매서드를 다음과 같이 오버라이딩하여          * 우리가 원하는 검증을 하도록 설정          */      @Override      public Validator getValidator(          return new RegisterRequestValidator();      }  }  // RegisterController.java  @PostMapping(\"/register/step3\")  public String handleStep3(@Valid RegisterRequest regReq, Errors errors){      // 기존에 객체를 검증하는 코드를 작성할 필요가 없어짐        // new RegisterRequestValidator().validate(regReq, errors);      ...  }        @Valid 어노테이션이 붙은 파라미터는 글로벌 범위 Validator가 해당 타입을 검증할 수 있는지 확인  검증 가능하면 실제 검증을 수행하고 그 결과를 Errors에 저장  이 과정은 요청 처리 매서드(handleStep3()) 실행 전에 적용          결국 handleStep3() 매서드 안에서 RegisterRequest 객체를 검증하는 코드를 작성할 필요가 없어짐      3-2. @InitBinder 어노테이션을 이용한 컨트롤러 범위 Validator      @InitBinder 어노테이션을 이용해 컨트롤러 범위 Validator를 설정 가능      // RegisterController.java  @PostMapping(\"/register/step3\")  public String handleStep3(@Valid RegisterRequest regReq, Errors errors){      ...  }  ...  /*   * 어떤 Validator가 객체를 검증할지 다음 @InitBind 어노테이션이 붙은 매서드에서 정의  * 여기서는 RegisterRequest 타입을 지원하는 Validator를 컨트롤러 범위 Validator로 설정  */  @InitBinder  protected void initBinder(WebDataBinder binder){      binder.setValidator(new RegisterRequestValidator());  }        글로벌 범위 validator와 마찬가지로 validator() 매서드를 호출하는 부분이 없음  @InitBind 어노테이션을 적용한 매서드는 WebDataBinder 타입 파라미터를 가짐      setValidator() 매서드를 이용해 컨트롤러 범위에 적용할 Validator 설정 가능          글로벌 범위와 컨트롤러 범위 validator()가 모두 존재할 경우,    글로벌 -&gt; 컨트롤러 범위 순으로 validator()가 적용됨      4. Bean Validation을 이용한 값 검증 처리@Valid 어노테이션은 Bean Validation 스펙에 정의되어 있는데, @NotNull, @Digits, @Size 등의 어노테이션과 함께 정의되며,Bean Validaion이 제공하는 어노테이션을 이용해 커맨드 객체의 값을 검증하는 방법은 다음과 같다.  Bean Validation과 관련된 의존을 설정에 추가(Maven의 경우 pom.xml에 추가)      커맨드 객체에 @NotNull, @Digits 등의 어노테이션을 이용해 검증 규칙을 설정     // RegisterRequest.java public class RegisterRequest {     @NotNull     @Email     private String email;     @Size(min=6)     private String password;     @NotEmpty     private String confirmPassword;     @NotEmpty     private String name; ...        위와 같은 어노테이션을 사용했다면 Bean Validation 어노테이션을 적용한 커맨드 객체를 검증할 수 있는OptionalValidatorFactoryBean 클래스를 Bean으로 등록  설정 파일에 @EnableWebMvc 어노테이션을 사용해 OptionalValidatorFactoryBean을 글로벌 범위 Validator로 등록  다음과 같이 @Valid 어노테이션을 붙여 글로벌 범위 Validator로 검증 가능  각 어노테이션의 에러 메세지는 Bean validation 프로바이더가 제공하는 기본 에러 메세지를 출력          @NotNull: 반드시 값이 존재하고 공백 문자를 제외한 길이가 0보다 커야 합니다.@NotEmpty: 반드시 값이 존재하고 길이 혹은 크기가 0보다 커야 합니다.…          @PostMapping(\"/register/step3\")  public String handleStep3(@Valid RegisterRequest regReq, Errors errors) {      new RegisterRequestValidator().validate(regReq, errors);      if (errors.hasErrors())          return \"register/step2\";      try {          memberRegisterService.regist(regReq);          return \"register/step3\";      } catch (DuplicateMemberException ex) {          errors.rejectValue(\"email\", \"duplicate\");          return \"register/step2\";      }  }              만약 글로벌 validator가 따로 설정되어 있다면, Spring은 OptionalValidatorFactoryBean를 글로벌 범위 Validator로 사용하지 않음  따라서 따로 설정한 글로벌 범위 validator는 삭제해 주어야 함      4-1. Bean Validation 에러 메세지 커스터마이징      기본 에러 메세지 대신, 원하는 에러 메세지를 사용하기 위해 다음과 같이 properties 파일에 작성      NotBlank=필수 항목입니다. 공백 문자는 허용하지 않습니다.  NotEmpty=필수 항목입니다.  Size.password=암호 길이는 6자 이상이어야 합니다.  Email=올바른 이메일 주소를 입력해야 합니다.              @NotBlank: 필수 항목입니다. 공백 문자는 허용하지 않습니다.@NotEmpty: 필수 항목입니다.…      ",
        "url": "/devlog/2019/12/30/spring-12.html"
      }
      ,
    
      "devlog-2019-12-30-spring-11-html": {
        "title": "[Spring] MVC1: 요청 매핑, 커맨드 객체, 리다이렉트, 폼 태그, 모델",
        "subtitle":"첫걸음 - 11",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "0. 들어가기 앞서본 문서에서 다루는 뷰는 크게 다음과 같다.  step1: 약관 동의, 별다른 기능 없음  step2: 회원가입 정보입력, step1에 동의 해야만 접근 가능  step3: 회원가입 완료, 첫 화면으로 돌아가는 기능 제공  surveyFrom: 설문조사 항목을 표기  submitted: 설문조사 결과를 화면에 표기 1. 요청 매핑 어노테이션을 이용한 경로 매핑웹 어플리케이션을 개발하는 것은 다음 코드를 작성하는 것  특정 요청 URL을 처리할 코드  처리 결과를 HTML과 같은 형식으로 응답하는 코드이 중 첫 번째는 @Controller 어노테이션을 이용한 컨트롤러 클래스를 이용해 구현하며, 요청 매핑 어노테이션은 다음과 같다.          @RequestMapping      @GetMapping      @PostMapping      이를 이용하여 간단히 화면을 띄우는 방법은 다음 예시와 같다.    // RegisterController.java    @Controller    public class RegisterController {        ...        @RequestMapping(\"/register/step1\")        public String handleStep1() {            return \"register/step1\";        }            ...  요청 경로가 /register/step1인 경우 “register/step1”을 리턴하며 이는 곧 보여줄 뷰의 이름  step1.jsp 파일을 생성 후, 설정파일에 RegisterController를 Bean으로 등록1-1. GET, POST의 구분: @GetMapping, @PostMapping  스프링 MVC는 별도 설정이 없으면 GET과 POST 방식에 상관없이 @RequestMapping에 지정한 경로와 일치하는 요청을 처리  POST 방식의 요청만 처리하고 싶다면, @PostMapping 어노테이션을 사용해 제한  마찬가지로, GET 방식은 @GetMapping 어노테이션을 사용해 제한      // RegisterController.java  @Controller  public class RegisterController {      ...          // regist/step2 경로로 들어오는 요청중 POST 방식만 처리       @PostMapping(\"/register/step2\")      public String handleStep2(          ...          }          // regist/step2 경로로 들어오는 요청중 GET 방식만 처리      @GetMapping(\"/register/step2\")      public String handleStep2Get() {          return \"redirect:/register/step1\";      }          ...  }          2. 요청 파라미터 접근step1.jsp 코드에는 다음처럼 ‘agree’ 요청 파라미터의 값을 POST 방식으로 전송하며,폼에서는 지정한 agree 요청 파라미터의 값을 이용해 약관 동의 여부를 확인 가능    &lt;!-- step1.jsp --&gt;    &lt;!-- 약관 동의 화면을 생성하는 코드 --&gt;    ...    &lt;form action=\"step2\" method=\"post\"&gt;    &lt;label&gt;        &lt;input type=\"checkbox\" name=\"agree\" value=\"true\"&gt; 약관 동의    &lt;/label&gt;    &lt;input type=\"submit\" value=\"다음 단계\" /&gt;    &lt;/form&gt;    ...컨트롤 매서드에서 요청 파라미터를 사용하는 방법은 다음과 같이 2가지 방법이 존재  HttpServletRequest를 직접 이용  @RequestParam 어노테이션을 사용2-1. HttpServletRequest를 이용    // RegisterController.java     @Controller    public class RegisterController {        ...        @PostMapping(\"/register/step2\")        public String handleStep2(HttpServletRequest request) {                    String agreeParam = request.getParameter(\"agree\");            if (agreeParam == null || !agreeParam.equals(\"true\")) {                return \"register/step1\";            }            return \"register/step2\";        }            ...    }  컨트롤러의 처리 매서드 파라미터로 HttpServletRequest 타입을 사용  HttpServletRequest의 getPatameter() 매서드를 이용해 파라미터의 값을 구함2-2. @RequestParam 어노테이션을 이용    // RegustController.java    @Controller    public class RegisterController {        ...        @PostMapping(\"/register/step2\")        public String handleStep2(                            /*                            * agree 요청 파라미터의 값을 읽어, agreeVal에 할당                             * 요청 파라미터의 값이 없다면, \"false\" 문자열을 값으로 사용                             */                @RequestParam(value = \"agree\", defaultValue = \"false\") Boolean agreeVal){            if (!agree) {                return \"register/step1\";            }            return \"register/step2\";        }            ...    }  요청 파라미터의 개수가 몇 개 안 되면 @RequestParam 어노테이션을 사용해 간단히 값을 구하는 것이 가능  @RequestParam 어노테이션의 속성은 다음이 존재          value(String): HTTP 요청 파라미터의 이름을 지정      required(boolean): 필수 여부 지정      defaultValue(String): 값이 없을 때 사용할 문자열 지정      3. 리다이렉트 처리step2는 step1에서 약관을 동의해야만 접근 가능한 페이지이므로, URL을 직접 입력하여 접근하는 GET 방식은 허용하지 않음따라서 다음과 같이 URL을 직접 입력하는 경우, step1로 리다이렉트 시킴    // RegisterController.java    @Controller    public class RegisterController {        ...            // regist/step2 경로로 들어오는 요청중 POST 방식만 처리         @PostMapping(\"/register/step2\")        public String handleStep2(            ...            }            // regist/step2 경로로 들어오는 요청중 GET 방식만 처리, step1로 리다이렉트 시킴        @GetMapping(\"/register/step2\")        public String handleStep2Get() {            return \"redirect:/register/step1\";        }            ...    }리다이렉트할 경로를 설정하는 방법은 다음과 같이 3가지가 존재  웹 어플리케이션을 기준으로 이동 경로를 생성:          “redirect:” 뒤의 문자열이 “/”로 시작하는 경우      “redirect:/register/step1”은 웹 어플리케이션 경로와 합쳐져 “/sp5-chap11/register/step1”이 됨        현재 경로를 기준으로 상대 경로를 이용:          ”/”로 시작하지 않을 경우        절대 경로를 이용:          완전한 URL을 사용      4. 커맨드 객체4-1. 커맨드 객체를 이용해 요청 파라미터 사용step2.jsp가 생성하는 폼은 다음 파라미터를 이용해 정보를 서버에 전송  email / name / password / confirmPassword이를 처리하기 위해 다음과 같은 전송 코드를 사용가능      @PostMapping(\"/register/step3\")  public String handleStep3(HttpServletRequest request){      String email = request.getParameter(\"email\");      String name = request.getParameter(\"name\");      String password = request.getParameter(\"password\");      String confirmPassword = request.getParameter(\"confirmPassword\");          ...              하지만 파라미터의 개수가 훨씬 많아진다면 일일히 값을 읽어올 것인가?        이런 불편함을 줄이기 위해 스프링은 요청 파라미터의 값을 커맨드 객체에 담아주는 기능을 다음과 같이 제공      @PostMapping(\"/register/step3\")  public String handleStep3(RegisterRequest regReq){      ...  }        다음과 같이 요청 파라미터의 값을 전달 받을 수 있는 setter 매서드를 포함하는 객체를 커맨드 객체로 사용      // RegisterRequest.java  public class RegisterRequest {      ...      public void setEmail(String email) {          this.email = email;      }      public String getPassword() {          return password;      }      public void setPassword(String password) {          this.password = password;      }          ...  }          4-2. 뷰 JSP 코드에서 커맨드 객체 사용가입할 때 사용한 이메일 주소와 이름을 가입 완료 화면에서 커맨드 객체를 이용해 다음과 같이 표시 가능    ...    &lt;body&gt;        &lt;p&gt;&lt;strong&gt;${registerRequest.name}님&lt;/strong&gt;             회원 가입을 완료했습니다.&lt;/p&gt;        &lt;p&gt;&lt;a href=\"&lt;c:url value='/main'/&gt;\"&gt;[첫 화면 이동]&lt;/a&gt;&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;  ${registerRequest.name}에서 registerRequest가 커맨드 객체에 접근시 사용한 속성 이름  스프링 MVC는 다음과 같이 커맨드 객체의 클래스 이름과 동일한 속성 이름을 사용해 커맨드 객체를 뷰에 전달          JSTL c tag는 여기를 참조        @PostMapping(\"/register/step3\")  public String handleStep3(RegisterRequest regReq){      ...  }  // 위와 같은 RegisterRequest 클래스 이름에서 첫 글자만 소문자로 변경해 아래와 같이 전달                &lt;p&gt;&lt;strong&gt;${registerRequest.name}님&lt;/strong&gt;       회원 가입을 완료했습니다.&lt;/p&gt;          4-3. @ModelAttribute 어노테이션으로 커맨드 객체 속성 이름 변경@PostMapping(\"/register/step3\")// 뷰 코드에서는 \"fromData\"라는 이름으로 커맨드 객체에 접근 가능public String handleStep3(@ModelAttribute(\"formData\") RegisterRequest regReq){      ...}  커맨드 객체에 접근할 때 사용할 속성 이름을 @ModelAttribute 어노테이션을 사용해 변경4-4. 커맨드 객체와 스프링 폼 연동  회원 정보를 입력할 때 중복된 이메일을 입력하면 텅 빈 폼을 보여주는데, 비어있으므로 입력한 값을 다시 입력해야 하는 불편함이 발생  다시 폼을 보여줄 때 커맨드 객체의 값을 폼에 채워주면 이런 불편함을 해소 가능  스프링 MVC가 제공하는 커스텀 태그를 사용해 간단한 커맨드 객체의 값 출력 가능  스프링은 &lt;form:form&gt; 태그와 &lt;form:input&gt; 태그를 제공      &lt;!-- step2.jsp --&gt;  &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt;  ...  &lt;body&gt;      &lt;h2&gt;회원 정보 입력&lt;/h2&gt;      &lt;form:form action=\"step3\" modelAttribute=\"registerRequest\"&gt;      &lt;p&gt;          &lt;label&gt;이메일:&lt;br&gt;          &lt;form:input path=\"email\" /&gt;          &lt;/label&gt;      &lt;/p&gt;      &lt;p&gt;          &lt;label&gt;이름:&lt;br&gt;          &lt;form:input path=\"name\" /&gt;          &lt;/label&gt;      &lt;/p&gt;      &lt;p&gt;          &lt;label&gt;비밀번호:&lt;br&gt;          &lt;form:password path=\"password\" /&gt;          &lt;/label&gt;      &lt;/p&gt;  ...        &lt;form:form&gt; 태그를 사용하려면 커맨드 객체가 존재해야 함  따라서 다음과 같이 step2.jsp 뷰를 호출하는 컨트롤러 코드에 “registerRequest” 객체를 모델에 넣어야 함      // RegisterController.java  @Controller  public class RegisterController {      ...      @PostMapping(\"/register/step2\")      public String handleStep2(              @RequestParam(value = \"agree\", defaultValue = \"false\") Boolean agree,              Model model) {          if (!agree) {              return \"register/step1\";          }                  // 커스텀 태그 사용을 위해 커맨드 객체를 모델에 넣어줌          model.addAttribute(\"registerRequest\", new RegisterRequest());          return \"register/step2\";      }          ...  }          5. 컨트롤러 구현 없는 매핑step3.jsp에 존재하는 다음과 같은 코드는 가입 완료 후 첫 화면으로 복귀하는 역할    &lt;p&gt;&lt;a herf=\"c:url value='/main/'&gt;\"&gt;[첫 화면 이동]&lt;/a&gt;&lt;/p&gt;이 첫 화면이 단순히 환영 문구와 회원 가입으로 이동하는 링크를 제공한다면, 이를 위해 다음과 같은 컨트롤러를 구현해야 함    @Controller    public class MainController{        @RequestMapping(\"/main\")        public String main(){                return \"main\";        }    }  단순히 요청 경로와 뷰를 연결하기 위해 컨트롤러를 작성하는 낭비 발생  WebMvcConfigurer 인터페이스의 addViewControllers() 매서드를 이용해 다음과 같이 보완 가능      // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      ...      @Override      public void addViewControllers(ViewControllerRegistry registry) {          registry.addViewController(\"/main\").setViewName(\"main\");      }  }          6. 커맨드 객체: 중첩, 콜렉션 프로퍼티스프링 MVC는 다음과 같은 경우에 요청 파라미터의 값을 알맞게 커맨드 객체에 전달  커맨드 객체가 리스트 타입의 프로퍼티를 가졌거나  중첩 프로퍼티를 가진 경우각 경우의 규칙은 다음과 같다.  HTTP 요청 파라미터 이름이 \"프로퍼티이름[인덱스]\" 형식이면 리스트를 처리  HTTP 요청 파라미터 이름이 \"프로퍼티이름.프로퍼티이름\" 형식이면 중첩 프로퍼티를 처리    // AnsweredData.java    public class AnsweredData{        private List&lt;String&gt; responses;        private Respondent res;        ...    }    // Respondent.java    public class Respondent{        private int age;        private String location;        ...    }  AsnweredData 객체는 리스트 타입의 프로퍼티 responses를 가짐  AsnweredData 객체는 중첩 프로퍼티 res를 가짐    &lt;!-- surveyForm.jsp --&gt;    ...    1. 당신의 역할은?&lt;br/&gt;    &lt;label&gt;&lt;input type = \"radio\" name = \"response[0]\" value = \"서버\"&gt;        서버개발자&lt;/label&gt;    &lt;label&gt;&lt;input type = \"radio\" name = \"response[0]\" value = \"프론트\"&gt;        프론트개발자&lt;/label&gt;    &lt;label&gt;&lt;input type = \"radio\" name = \"response[0]\" value = \"풀스택\"&gt;        풀스택개발자&lt;/label&gt;    &lt;/p&gt;    &lt;p&gt;    2. 가장 많이 사용하는 도구는?&lt;br/&gt;    &lt;label&gt;&lt;input type = \"radio\" name = \"response[1]\" value = \"Eclipse\"&gt;        Eclipse&lt;/label&gt;    &lt;label&gt;&lt;input type = \"radio\" name = \"response[1]\" value = \"Intellij\"&gt;        Intellij&lt;/label&gt;    &lt;label&gt;&lt;input type = \"radio\" name = \"response[1]\" value = \"Sublime\"&gt;        Sublime&lt;/label&gt;    ...    &lt;label&gt;응답자 위치:&lt;br&gt;    &lt;input type=\"text\" name=\"res.location\"&gt;    &lt;/label&gt;    ...7. Model을 통해 컨트롤러에서 뷰에 데이터 전달컨트롤러는 뷰가 응답 화면을 구성하는데 필요한 데이터를 생성해서 Model을 이용하여 전달하며 다음과 같은 두 가지를 수행  요청 매핑 어노테이션이 적용된 매서드의 파라미터로 Model을 추가  Model 파라미터의 addAttribute() 매서드로 뷰에서 사용할 데이터 전달  앞선 예제에서 JSP 파일에 설문 항목을 하드 코딩한 부분을 컨트롤러에서 생성해 뷰에 전달하는 방법으로 변경    // SurveyController.java    @Controller    @RequestMapping(\"/survey\")    public class SurveyController {        @GetMapping            /*            * 1. 파라미터로 Model 타입을 추가            * 2. addAttribute() 매서드로 전달            */        public String form(Model model) {            List&lt;Question&gt; questions = createQuestions();            model.addAttribute(\"questions\", questions);            return \"survey/surveyForm\";        }            // 설문항목        private List&lt;Question&gt; createQuestions() {            Question q1 = new Question(\"당신의 역할은 무엇입니까?\",                    Arrays.asList(\"서버\", \"프론트\", \"풀스택\"));            Question q2 = new Question(\"많이 사용하는 개발도구는 무엇입니까?\",                    Arrays.asList(\"이클립스\", \"인텔리J\", \"서브라임\"));            Question q3 = new Question(\"하고 싶은 말을 적어주세요.\");            return Arrays.asList(q1, q2, q3);        }        @PostMapping        public String submit(@ModelAttribute(\"ansData\") AnsweredData data) {            return \"survey/submitted\";        }    }    &lt;!-- surveyForm.jsp --&gt;    ...    &lt;body&gt;        &lt;h2&gt;설문조사&lt;/h2&gt;        &lt;form method=\"post\"&gt;        &lt;c:forEach var=\"q\" items=\"${questions}\" varStatus=\"status\"&gt;        &lt;p&gt;            ${status.index + 1}. ${q.title}&lt;br/&gt;            &lt;c:if test=\"${q.choice}\"&gt;                &lt;c:forEach var=\"option\" items=\"${q.options}\"&gt;                &lt;label&gt;&lt;input type=\"radio\"                             name=\"responses[${status.index}]\" value=\"${option}\"&gt;                    ${option}&lt;/label&gt;                &lt;/c:forEach&gt;            &lt;/c:if&gt;            &lt;c:if test=\"${! q.choice }\"&gt;            &lt;input type=\"text\" name=\"responses[${status.index}]\"&gt;            &lt;/c:if&gt;        &lt;/p&gt;        &lt;/c:forEach&gt;    ...7-1. ModelAndView를 통한 뷰 선택과 모델 전달  지금까지 구현한 컨트롤러는 다음과 같은 특징을 지님          Model을 이용해 뷰에 전달할 데이터 설정      결과를 보여줄 뷰 이름을 리턴        ModelAndView를 사용하면 이 두 가지를 한번에 다음과 같이 처리 가능      // SurveyController.java    @Controller  @RequestMapping(\"/survey\")  public class SurveyController {      /*          * 기존 코드      @GetMapping      public String form(Model model) {          List&lt;Question&gt; questions = createQuestions();          model.addAttribute(\"questions\", questions);          return \"survey/surveyForm\";      }          */      @GetMapping      public ModelAndiew form() {          List&lt;Question&gt; questions = createQuestions();          mav.addObject(\"questions\", questions);          mav.setViewName(\"survey/surveyFrom\");          return mav;      }  }          8. 주요 폼 태그스프링 MVC는 &lt;form:form&gt;, &lt;form:input&gt; 등 HTML 폼과 커맨드 객체를 연동하기 위한 JSP 태그 라이브러리를 제공8-1. &lt;form&gt; 태그를 위한 커스텀 태그 : &lt;form:form&gt;  &lt;form&gt; 커스텀 태그는 &lt;form&gt; 태그를 생성할 때 사용      &lt;form:form&gt;  ...  &lt;input type=\"submit\" value=\"가입 완료\"&gt;  &lt;/form:form&gt;        &lt;form:form&gt; 태그의 method 속성과 action 속성의 기본값은 각각 post와 현재 요청 URL          만약 요청 URL이 “/sp5-chap11/register/step2” 라면 앞선 태그는 다음의 &lt;form&gt; 태그를 생성  ~~~jsp          ...  &lt;/from&gt;  ~~~      커맨드 객체의 이름이 기본값인 “command”가 아니라면 다음과 같이 modelAttribute 속성값으로 설정      &lt;form:form modelAttribute=\"loginCommand\"&gt;  ...  &lt;/form&gt;        다음과 같이 커멘드 객체를 이용해 이전에 입력한 값을 출력 가능      &lt;form:from modelAttribute=\"loginCommand\"&gt;  ...      &lt;input type=\"text\" name=\"id\" value=\"${loginCoomand.id}\" /&gt;  ...  &lt;/form:form&gt;              이때 input을 직접 사용하기 보다는 &lt;form:input&gt; 등의 태그를 사용하면 편리      8-2. &lt;input&gt; 관련 커스텀 태그: &lt;form:input&gt;, &lt;form:password&gt;, &lt;form:hidden&gt;  스프링은 다음과 같은 커스텀 태그를 제공          &lt;form:input&gt;: text 타입 &lt;input&gt; 태그      &lt;form:password&gt;: passowrd 타입 &lt;input&gt; 태그      &lt;form:hidden&gt;: hidden 타입 &lt;input&gt; 태그        &lt;form:input&gt; 커스텀 태그는 다음과 같이 path 속성을 사용해 연결할 커맨드 객체의 프로퍼티를 지정      &lt;form:form modelAttribute=\"registerRequest\" action=step3\"&gt;  &lt;p&gt;      &lt;label&gt;이메일:&lt;br/&gt;      &lt;form:input path=\"email\"/&gt;      &lt;/label&gt;  &lt;/p&gt;  &lt;!-- 위 코드는 아래와 같이 HTML &lt;input&gt; 태그를 생성 --&gt;  &lt;form id=\"registerRequest\" action=step3\" method=\"post\"&gt;  &lt;p&gt;      &lt;label&gt;이메일:&lt;br/&gt;      &lt;input id=\"email\" name=\"email\" type=\"text\" value=\"\"/&gt;      &lt;/label&gt;  &lt;/p&gt;          8-3. &lt;select&gt; 관련 커스텀 태그: &lt;form:select&gt;, &lt;form:options&gt;, &lt;form:option&gt;  스프링은 다음과 같은 커스텀 태그를 제공          &lt;form:select&gt;: &lt;select&gt; 태그를 생성, &lt;option&gt; 태그를 생성할 때 필요한 콜렉션을 전달 받을 수 있음      &lt;form:password&gt;: 지정한 콜렉션 객체를 이용하여 &lt;option&gt; 태그를 생성      &lt;form:hidden&gt;: &lt;option&gt; 태그를 한 개 생성        &lt;select&gt; 태그는 선택 옵션을 제공할 때 주로 사용  &lt;select&gt; 태그에서 사용할 옵션 목록을 Model을 통해 전달하면 뷰에서 다음과 같이 간단하게 태그 생성 가능      &lt;form:form modelAttriute=\"login\"&gt;  &lt;p&gt;      &lt;label for=\"loginType\"&gt;로그인 타입&lt;/label&gt;      &lt;!-- loginTypes에는 모델에서 넘어온 로그인 타입 관련 array등이 저장됨 --&gt;      &lt;form:select path=\"loginType\" items=\"${loginTypes}\" /&gt;  &lt;/p&gt;  ...  &lt;/form:form&gt;          8-4. 체크박스 관련 커스텀 태그: &lt;form:checkboxes&gt;, &lt;form:checkbox&gt;  배열이나 List 타입을 이용해 한 개 이상의 값을 커맨드 객체에 저장 후 HTML 폼에서는 checkbox 타입 태그 사용  스프링은 다음과 같은 커스텀 태그를 제공          &lt;form:checkboxes&gt;: 커맨드 객체의 특정 프로퍼티와 관련된 checkbox 타입의 &lt;input&gt; 태그 목록 생성      &lt;form:checkbox&gt;:  커맨드 객체의 특정 프로퍼티와 관련된 한 개의 checkbox 타입 &lt;input&gt; 태그 생성          &lt;p&gt;      &lt;!-- favoriteOsNames에 존재 하는 값들에 대한 체크박스를 생성 --&gt;      &lt;label&gt;선호 OS&lt;/label&gt;      &lt;form:checkboxes items=\"${favoriteOsNames}\" paht = \"favoriteOs\" /&gt;  &lt;/p&gt;                            8-4. 라디오버튼 관련 커스텀 태그: &lt;form:radiobuttons&gt;, &lt;form:radiobutton&gt;  여러 옵션중 한 가지를 선택해야 하는 경우 radio 타입의 &lt;input&gt; 태그를 사용  스프링은 다음과 같은 커스텀 태그를 제공          &lt;form:radiobuttons&gt;: 커맨드 객체의 특정 프로퍼티와 관련된 radio 타입의 &lt;input&gt; 태그 목록 생성      &lt;form:radiobutton&gt;:  커맨드 객체의 특정 프로퍼티와 관련된 한 개의 radio 타입 &lt;input&gt; 태그 생성        다음과 같이 items 속성에 값으로 사용할 콜렉션을 전달받고 path 속성에 커맨드 객체의 프로퍼티를 지정      &lt;p&gt;      &lt;label&gt;주로 사용하는 개발툴&lt;/label&gt;      &lt;form:radiobuttons items=\"${tools}\" path=\"tool\"/&gt;  &lt;/p&gt;          8-5. &lt;textarea&gt; 태그를 위한 커스텀 태그: &lt;form:textarea&gt;  게시글 내용과 같이 여러 줄을 입력받아야 하는 경우 사용  스프링은 커맨드 객체와 관련된 &lt;textarea&gt;태그를 생성하는 &lt;form:textarea&gt; 커스텀 태그를 제공      &lt;p&gt;      &lt;label for=\"etc\"&gt;기타&lt;/label&gt;      &lt;form:textarea path=\"etc\" cols=\"20\" rows=\"3\" /&gt;  &lt;/p&gt;      ",
        "url": "/devlog/2019/12/30/spring-11.html"
      }
      ,
    
      "devlog-2019-12-30-spring-10-html": {
        "title": "[Spring] 스프링 MVC 동작방식",
        "subtitle":"첫걸음 - 10",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 스프링 MVC 핵심 구성 요소MVC 프레임워크의 흐름은 다음과 같다.  DispatcherServlet이 모든 연결을 담당하며, 웹 브라우저로부터 요청을 받음            요청이 들어오면 DispathcerServlet는 HandlerMapping Bean 객체에게 컨트롤러 검색을 요청      HandlerMapping은 클라이언트의 요청 경로를 이용해 컨트롤러 Bean객체를 DispathcerServlet에게 전달        DispathcerServlet은 전달받은 객체를 처리할 수 있는 HandlerAdapter Bean에게 요청 처리를 위임  HandlerAdapter는 컨트롤러의 알맞은 매서드를 호출해 요청을 처리  그 후, 결과를 ModelAndView라는 객체로 DispathcerServlet에게 반환            DispathcerServlet는 전달받은 결과를 보여줄 뷰를 찾기 위해 ViewResolver Bean 객체를 사용      ViewResolver는 ModelAndView 내부에 있는 뷰 이름에 해당하는 View 객체를 찾거나 생성후 리턴        DispathcerServlet는 VeiwResolver가 리턴한 View 객체에게 응답 결과 생성을 요청1-1. 컨트롤러와 핸들러  클라이언트의 요청을 실제로 처리하는 것은 컨트롤러  DispathcerServlet는 클라이언트의 요청을 전달받는 창구 역할  HandlerMapping은 특정 요청 경로를 처리해주는 핸들러를 찾아주는 역할  HandlerAdapter는 핸들러의 처리결과를 ModelAndView 객체로 변환하여 DispathcerServlet에게 전달2. @Controller를 위한 HandlerMapping과 HandlerAdapter    // ControllerConfig.java    @Configuration    @EnableWebMvc    public class MvcConfig{        ...    }  @EnableWebMvc 어노테이션을 통해 HandlerMapping이나 HandleAdapter 설정을 자동으로 추가    // HelloController.java    @Controller    public class HelloController {        @GetMapping(\"/hello\")        public String hello(Model model,                @RequestParam(value = \"name\", required = false) String name)             {            model.addAttribute(\"greeting\", \"안녕하세요, \" + name);            return \"hello\";        }    }  @EnableWebMvc 어노테이션은 @Controller 타입의 핸들러 객체를 처리하기 위한 클래스를 포함  그 중 하나가 RequestMappingHandlerMapping이며, 이 어노테이션은 @GetMapping 어노테이션 값을 이용해서 웹 브라우저의 요청을 처리할 컨트롤러 Bean을 찾음          GET &amp; POST는 여기를 참조        앞선 코드에서 @GetMapping에서 “/hello”라는 요청 경로에 대해 hello() 매서드를 호출이때 Model 객체를 생성해 첫 번째 파라미터로, HTTP 요청 파라미터를 두 번째 파라미터로 전달  RequestMappingHandlerAdapter는 컨트롤러 매서드 결과 값이 String 타입이면,해당값을 뷰 이름으로 갖는 ModleAndView 객체를 생성해 DispatcherServlet에 리턴          위의 예제에서 결국 뷰의 이름은 hello가 된다.      3. JSP를 위한 ViewResolver  컨트롤러 처리 결과를 JSP를 이용해서 생성하기 위해 다음 설정을 사용      // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      ...      @Override      public void configureViewResolvers(ViewResolverRegistry registry) {          registry.jsp(\"/WEB-INF/view/\", \".jsp\"); // 접두사, 접미사 설정      }  }        WebMvcConfigurer 인터페이스에 정의된,          configureViewResolvers() 매서드의 파라미터 ViewResolverRegistry의 jsp() 매서드를 이용해 ViewResolver를 설정가능      내부 클래스를 이용하여 다음과 같이 뷰 이름에 해당하는 객체를 요청          @Bean  public ViewResolver viewResolver(){   InternalResourceViewResolver vr =        new InternalResourceViewResolver();   vr.setPrefix(\"/WEB-INF/view/\");   vr.setSurfix(\".jsp\");   return vr;  }                      앞선 코드의 구성처럼, \"prefix + 뷰이름 \" surfix\"에 해당하는 경로를 할당  DispatcherServlet이 View 생성을 요청하면 InternalResourceViewResolver는 이 JSP 코드를 실행하여 결과 생성4. 디폴트 핸들러와 HandlerMapping의 우선순위  web.xml 파일을 참조하면, DispatcherServlet에 대한 매핑 경로가 다음과 같이 '/'로 설정      &lt;!-- web.xml --&gt;  &lt;servlet-mapping&gt;      &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;      &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;        매핑 경로가 ‘/’인경우 .jsp로 끝나는 요청을 제외한 모든 요청을 DispatcherServlet이 처리  하지만 앞선 코드에서처럼 HandlerMapping으로 @GetMapping(“/hello”) 설정을 사용하였다면, /hello 경로만 처리가능하므로 “/index.html”등의 요청을 처리할 컨트롤러를 찾을 수 없음  이러한 경로를 처리하기 위한 컨트롤러 객체를 직접 구현할 수도 있지만 다음과 같이, WebMvcConfigurer의 configureDefaultServletHandling() 매서드를 사용하는 것이 편리      // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      @Override      public void configureDefaultServletHandling          (DefaultServletHandlerConfigurer configurer)       {          configurer.enable();      }      ...        위 설정에서 enable() 매서드는 다음의 두 Bean 객체를 추가          DefaultServletRequestHandler      SimpleUrlHandlerMapping        DefaultServletRequestHandler는 클라이언트의 모든 요청을 WAS가 제공하는 디폴트 서블릿에 전달          “/index.html”에 대한 처리를 결국 디폴트 서블릿이 처리하도록 만듦            그리고 SimpleUrlHandlerMapping를 이용하여 모든 경로(“/**“)를 DefaultServletHttp RequestHandler를 이용해 처리하도록 함    @EnableWebMvc 어노테이션이 등록하는 HandlerMapping의 적용 우선순위가 enable() 매서드가 등록하는 디폴트 핸들러보다 높음  따라서 다음과 같은 방식으로 요청을 처리          RequestMappingHandlerMapping을 사용해 요청 처리할 핸들러 검색                  존재하면 해당 컨트롤러를 이용해 요청을 처리                    존재하지 않으면 SimpleUrlHandlerMapping을 사용해 요청을 처리할 핸들러 검색                  모든 경로에 대해 DefaultServletHttpRequestHandler를 리턴          DispatcherServlet은 DefaultServletHttpRequestHandler에 처리를 요청          DefaultServletHttpRequestHandler는 디폴트 서블릿에 처리를 위임                          예를 들어 “/index.html” 경로로 요청이 들어오면, 1과정에서 해당하는 경로를 찾지 못하므로,   2과정을 통해 디폴트 서블릿이 /index.html 요청을 처리하게 됨                                          ",
        "url": "/devlog/2019/12/30/spring-10.html"
      }
      ,
    
      "devlog-2019-12-30-spring-9-html": {
        "title": "[Spring] 스프링 MVC 시작하기",
        "subtitle":"첫걸음 - 9",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "0. Goal  스프링 MVC 설정  웹 브라우저의 요청을 처리할 컨트롤러 구현  컨트롤러의 처리 결과를 보여줄 뷰 코드 구현  이어지는 확장은 다음과 같다.      컨트롤러에서 서비스나 DAO를 사용해 클라이언트의 요청 처리    컨트롤러에서 요청 파라미터의 값을 하나의 객체로 받고 값 검증    스프링이 제공하는 JSP 커스텀 태그를 이용해서 폼 처리    컨트롤러에서 세션이나 쿠키를 사용    인터셉터로 컨트롤러에 대한 접근 처리    JSON 응답처리  0-1. MVC란?  MVC는 디자인 패턴중 하나로, Model, View, Controller의 약자      하나의 애플리케이션이나 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴        controller는 model을 통해서 데이터를 가져오고, 그 정보를 바탕으로 시각적인 표현을 담당하는 view를 제어해서 사용자에게 전달  각 구성요소가 지니는 특징은 다음과 같다.          Model                  사용자가 원하는 모든 데이터를 가지고 있어야 한다.          뷰나 컨트롤러에 관한 정보는 알 수 없다.          변경이 일어나면 변경 통지에 대한 처리방법을 구현해야만 한다.                    View                  모델이 가지고 있는 정보를 따로 저장해서는 안된다.          모델이나 컨트롤러와 같이 다른 구성요소들을 알 수 없다.          변경이 일어나면 변경통지에 대한 처리방법을 구현해야만 한다.                    Controller                  모델이나 뷰에 대해서 알고 있어야 한다.          모델이나 뷰의 변경을 모니터링 해야 한다.                      MVC패턴을 사용함으로써 유지보수성, 확장성, 유연성이 증가하고 중복코딩은 사라지게 됨0-2. 스프링 MVC 주요 구성 요소 및 처리 흐름  Dispatcher: 클라이언트의 요청을 전달받아 요청에 맞는 컨트롤러가 리턴한 결과값을 View에 전달하여 알맞은 응답을 생성  HandlerMapping: 클라이언트의 요청 URL을 어떤 컨트롤러가 처리할지 결정  Controller: 클라이언트의 요청을 처리한 뒤, 결과를 DispatcherServlet에게 리턴  ModelAndView: 컨트롤러가 처리한 결과 정보 및 뷰 선택에 필요한 정보를 담음  ViewResolver: 컨트롤러의 처리 결과를 생성할 뷰를 결정  View: 컨트롤러의 처리 결과 화면을 생성, JSP 또는 Velocity 템플릿 파일 등을 뷰로 사용1. 프로젝트 설정웹 어플리케이션 개발을 위한 메이븐 프로젝트의 디렉토리 구조는 다음과 같다.  src/main.java  src/main/webapp  src/main/webapp/WEB_INF  src/main/webapp/WEB_INF/view1-1. pom.xml      기존 pom.xml 파일에 다음과 같은 dependency를 추가      &lt;packaging&gt;war&lt;/packaging&gt;  &lt;!-- 아래부터 dependency --&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;  &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;  &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;jstl&lt;/artifactId&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;          1-2. Tomcat 설정  본 프로젝트에서는 Tomcat 8.5.43 버전을 기준으로 수행2. 스프링 MVC 기본 설정스프링 MVC 실행을 위해 필요한 최소한의 설정은 다음과 같다.      스프링 MVC의 주요 설정 - HandlerMapping, ViewResolver        스프링의 DispatcherServlet 설정  2-1. 스프링 MVC 설정    // MvcConfig.java      @Configuration    @EnableWebMvc  // 스프링 MVC 설정을 활성화하는 어노테이션    public class MvcConfig implements WebMvcConfigurer {            /*            * DispatcherServlet의 매핑경로를 '/'으로 주었을 때,              * JSP/HTML/CSS 등을 올바르게 처리하기 위한 설정을 추가            */        @Override        public void configureDefaultServletHandling(                DefaultServletHandlerConfigurer configurer) {            configurer.enable();        }            // JSP를 이용해 컨트롤러의 실행 결과를 보여주기 위한 설정 추가        @Override        public void configureViewResolvers(ViewResolverRegistry registry) {            registry.jsp(\"/WEB-INF/view/\", \".jsp\");        }    }  기존의 복잡한 설정을 대체하는 @EnableWebMvc 어노테이션을 이용시, 내부적으로 다양한 빈 설정을 추가해줌  WebMvcConfigurer 인터페이스는 스프링 MVC 개별 설정을 조절할 때 사용2-2. web.xml 파일에 DispatcherServlet 설정      스프링 MVC가 웹 요청을 처리하려면 DispatcherServlet을 통해 웹 요청을 받아야 함        이를 위해 web.xml 파일에 DispatcherServlet을 등록          web.xml 파일은 src/main/webapp/WEB_INF/ 에 위치      3. 코드 구현다음 두 가지 코드를 구현  클라이언트의 요청을 알맞게 처리할 컨트롤러  처리 결과를 보여줄 JSP3-1. 컨트롤러 구현    // HelloController.java    @Controller // 컨트롤러로 지정    public class HelloController {        @GetMapping(\"/hello\") // 메서드가 처리할 요청 경로를 지정, 이 경우 /hello 경로        public String hello(Model model,                // name 요청 파라미터 값을 name 파라미터에 전달                @RequestParam(value = \"name\", required = false) String name) {            model.addAttribute(\"greeting\", \"안녕하세요, \" + name);            return \"hello\"; // 컨트롤러의 처리 결과를 보여줄 뷰 이름으로 \"hello\"를 사용        }    }  스프링 MVC 프레임워크에서 컨트롤러란 웹 용청을 처리하고 그 결과를 뷰에 전당하는 스프링 Bean 객체  컨트롤러로 사용될 클래스는 @Controller 어노테이션을 붙임  @GetMapping 어노테이션이나 @PostMapping 어노테이션과 같은 요청 매핑 어노테이션을 이용해 경로 지정  @RequestParam 어노테이션은 HTTP 요청 파라미터를 매서드의 파라미터로 전달          http://localhost:8080/sp5-chap09/hello?name=bk여기서 name의 파라미터에 해당하는 값을 전달            addAttribute() 매서드는 뷰에 전달할 데이터를 지정하기 위해 사용      // ControllerConfig  @Configuration  public class ControllerConfig {      @Bean      public HelloController helloController() {          return new HelloController();      }  }        컨트롤러를 스프링의 Bean객체로 등록3-2. JSP 구현      컨트롤러가 생성한 결과를 보여줄 뷰 코드는JSP로 구현      &lt;%-- hello.jsp --%&gt;  &lt;%@ page contentType=\"text/html; charset=utf-8\" %&gt;  &lt;!DOCTYPE html&gt;  &lt;html&gt;  &lt;head&gt;      &lt;title&gt;Hello&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;      인사말: ${greeting}  &lt;/body&gt;  &lt;/html&gt;        HelloController()의 hello() 매서드가 리턴한 뷰 이름은 “hello”와 동일한 파일명      뷰 이름과 JSP 파일과의 연결은 MvcConfig 설정 클래스의 다음 설정을 통해 이루어짐      // MvcConfig.java  @Override  public void configureViewResolvers(ViewResolverRegistry registry) {      registry.jsp(\"/WEB-INF/view/\", \".jsp\");  }            다음과 같이 사용된 JSP EL(Expression Language)는 컨트롤러의 구현에서 Model에 추가한 속성의 이름과 동일      인사말: ${greeting}        실행결과주소창에 http://localhost:8080/sp5-chap09/hello?name=bk 를 입력하였을 경우 다음과 같은 화면이 출력인사말: 안녕하세요, bk",
        "url": "/devlog/2019/12/30/spring-9.html"
      }
      ,
    
      "devlog-2019-12-30-spring-8-html": {
        "title": "[Spring] DB 연동",
        "subtitle":"첫걸음 - 8",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1.스프링의 DB 연동 이점  스프링은 기존의 jdbc의 단점(구조적으로 반복되는 비핵심기능들)을 보완          jdbc는 여기를 참조        자바8의 람다를 사용하면 더 효율적인 개선 가능  트랙잭션의 관리가 쉬움          트랜잭션은 데이터베이스 뿐 아니라, 한번에 처리해야할 일의 묶음, 단위를 보장하는 의미로 사용      1-1. Maven 프로젝트 생성    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;        &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt;        &lt;version&gt;8.5.27&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.16&lt;/version&gt;    &lt;/dependency&gt;  spring-jdbc: JdbcTemplate 등 JDBC 연동에 필요한 기능을 제공  tomcat-jdbc: DB 커넥션풀 기능을 제공  mysql-connector-java: MySQL 연결에 필요한 JDBC 드라이버 제공          DB 커넥션풀은 여기를 참조      1-2. DB 테이블 생성  MySQL 5.7.27 버전 사용  ID(Primary Key), EMAIL(Unique Key), PASSWORD, NAME, REGDATE을 필드로 갖는 테이블 MEMBER 생성1-3. DataSource 설정JDBC API는 DriverManager 외에 DataSource를 이용해 DB 연결을 구하는 방법을 다음과 같이 정의    Connection conn = null;    try{        // datasource는 생성자나 설정 매서드를 이용해 주입        conn = dataSource.getConnection();        ...  스프링이 제공하는 DB연동 기능은 DataSource를 사용해 DB Connection을 구함  DB 연동에 사용할 DataSource를 스프링 Bean으로 등록하고,DB 연동 기능을 구현한 Bean객체는 DataSource를 주입받아 사용      // AppCtx.java  @Configuration  public class AppCtx {          /*           * datasource() 매서드를 통해 DataSource를 스프링 Bean으로 등록          * 아래의 destroyMethod = \"close\"를 지정함으로써,           * 커넥션 풀에 보관된 Connection들을 닫는 매서드 호출까지를 Bean의 생명주기로 지정          */      @Bean(destroyMethod = \"close\")      public DataSource dataSource() {          // DataSource 객체 생성          DataSource ds = new DataSource();          // JDBC 드라이버 클래스를 지정, 여기서는 MYSQL 드라이버 클래스 사용          ds.setDriverClassName(\"com.mysql.jdbc.Driver\");          // URL 지정          ds.setUrl(\"jdbc:mysql://localhost/spring5fs?characterEncoding=utf8\");          // 계정 &amp; 암호 지정          ds.setUsername(\"spring5\");          ds.setPassword(\"spring5\");          ...          return ds;      }          ...      @Bean      public MemberDao memberDao() {          return new MemberDao(dataSource());      }          ...  }          2. JdbcTemplate을 이용한 쿼리 실행스프링에서는 DataSource, Connection, Statement 및 ResultSet을 직접 사용하지 않고,JdbcTemplate을 이용해 편리하게 쿼리 실행 가능  DB의 데이터에 접근하는 자세한 방법은 여기를 참조2-1. JdbcTemplate 생성    // MemberDao.java    public class MemberDao {        private JdbcTemplate jdbcTemplate;            // 필요한 dataSorce 객체를 주입받음        public MemberDao(DataSource dataSource) {            this.jdbcTemplate = new JdbcTemplate(dataSource);        }        ...    }2-2. JdbcTemplate을 이용한 조회 쿼리 실행  JdbcTemplate 클래스는 SELECT 쿼리 실행을 위한 query() 매서드를 다음과 같이 제공          List quey(String sql, RowMapper rowMapper)      List quey(String sql, Object[] args, RowMapper rowMapper)      List quey(String sql, RowMapper rowMapper, Object... args)        sql의 파라미터가 아래와 같이 인덱스 기반 파라미터를 가진 쿼리라면,args 파라미터를 이용하여 각 인덱스의 파라미터의 값을 지정          select * from member where email=?        RowMapper의  mapRow() 매서드는 실행 결과로 구한 ResultSet의 한 행을 읽어와 자바 객체로 변환해주는 매퍼 기능 제공          ResultSet이란 SELECT문을 사용하여 얻어온 레코드 값들을 테이블의 형태로 갖게 되는 객체          // MemberDao.java  public class MemberDao {          ...      // 조회 쿼리 기능을 구현      public Member selectByEmail(String email) {          List&lt;Member&gt; results = jdbcTemplate.query(                  \"select * from MEMBER where EMAIL = ?\",                  new RowMapper&lt;Member&gt;() {                      @Override                      public Member mapRow(ResultSet rs, int rowNum) throws SQLException {                          Member member = new Member(                                  rs.getString(\"EMAIL\"),                                  rs.getString(\"PASSWORD\"),                                  rs.getString(\"NAME\"),                                  rs.getTimestamp(\"REGDATE\").toLocalDateTime());                          member.setId(rs.getLong(\"ID\"));                          return member;                      }                  }, email);                  /*                   * query() 매서드는 쿼리를 실행한 결과가 존재하지 않으면 0인 list를 반환하므로                  * list가 비어있는지 여부로 결과가 존재하지 않는지 확인할 수 있음                  */          return results.isEmpty() ? null : results.get(0);      }        selectByEamil 매서드의 JdbcTemplate query() 매서드는 다음과 같이 인덱스 파라미터(물음표)를 포함  인덱스 파라미터에 들어갈 값은 query() 매서드 맨 마지막 부분의 email 에서 전달      List&lt;Member&gt; results = jdbcTemplate.query(      \"select * from MEMBER where EMAIL = ?\",      new RowMapper&lt;Member&gt;() {...코드생략},          email); // 물음표에 해당하는 값 전달          2-3. 결과가 1행인 경우 사용할 수 있는 queryForObject() 매서드  count(*)과 같이 결과가 한 행으로 실행되는 경우 사용      // MemberDao.java  public class MemberDao {      ...      public int count() {          Integer count = jdbcTemplate.queryForObject(                  \"select count(*) from MEMBER\", Integer.class);          return count;      }  }        queryForObject() 매서드의 두 번째 파라미터는 칼럼을 읽어올 때 사용할 타입을 지정      실행 결과 칼럼이 두 개 이상이면 RowMapper를 파라미터로 전달해 결과 생성          queryForObject() 매서드를 사용하려면 쿼리 실행 결과는 반드시 한 행이어야 함만약 행이 없거나, 두 개 이상이면 익셉션이 발생      2-4. JdbcTemplate을 이용한 변경 쿼리 실행  JdbcTemplate 클래스는 INSERT, UPDATE, DELETE 쿼리 실행을 위한 update() 매서드를 다음과 같이 제공          int update(String sql)      int update(String sql, Object… args)            update() 매서드는 쿼리 실행 결과로 변경된 행의 개수를 반환      // MemberDao.java  public class MemberDao {      ...      public void update(Member member) {          jdbcTemplate.update(                  \"update MEMBER set NAME = ?, PASSWORD = ? where EMAIL = ?\",                  member.getName(), member.getPassword(), member.getEmail());      }          2-5. PreparedStatementCreator를 이용한 쿼리 실행  앞선 예제 코드의 경우, 첫 번째, 두 번째 세 번째 파라미터의 값으로 각각 접근자를 이용해 인덱스 파라미터의 값을 전달하지만 직접 인덱스 파라미터의 값을 설정해야 할 경우, 설정자를 이용해 설정 가능      PreparedStatementCreator를 인자로 받는 매서드를 이용해 아래와 같이 사용        jdbcTemplate.update(new PreparedSatementCreator(){          @Override          public PreparedStatement createPreparedStatement(Connection con)          throws SQLException{                  // 파라미터로 전달받은 Connection을 이용해 PreparedStatement 생성                  PreparedStatement pstmt = con.prepareStatement(                      \"insert into MEMBER (EMAIL, PASSWORD, NAME, REGDATE) values (?,?,?,?)\");                  // 인덱스 파라미터 값 설정                  pstm.setString(1, member.getEmail());                  pstm.setString(2, member.getPassword());                  pstm.setString(1, member.getName());                  pstm.setString(1, Timestamp.valueOf(member.getRegisterDateTime()));                  // 생성한 PreparedStatement 객체 리턴                  return pstm;          }  });                  2-6. INSERT 쿼리 실행 시 KeyHolder를 이용해 자동 생성 키 값 구하기  MySQL의 AUTO_INCREMENT 칼럼을 가진 테이블에 값을 삽입하면 해당 칼럼의 값이 자동으로 생성되므로,다음과 같이 INSERT 쿼리에 자동 증가 칼럼에 해당하는 값이 지정되지 않음      jdbcTemplate.update(          \"insert into MEMBER (EMAIL, PASSWORD, NAME, REGDATE) values (?,?,?,?)\",          member.getEmail(), member.getPassword(), member.getName(),           new Timestamp(member.getRegisterDateTime()));        이러한 키 값을 KeyHolder를 사용해 다음과 같이 구할 수 있다.      // MemberDao.java  public class MemberDao {      ...      public void insert(Member member) {          KeyHolder keyHolder = new GeneratedKeyHolder();          jdbcTemplate.update(new PreparedStatementCreator() {              @Override              public PreparedStatement createPreparedStatement(Connection con)                      throws SQLException {                  // 파라미터로 전달받은 Connection을 이용해서 PreparedStatement 생성                  PreparedStatement pstmt = con.prepareStatement(                          \"insert into MEMBER (EMAIL, PASSWORD, NAME, REGDATE) \" +                          \"values (?, ?, ?, ?)\",                          new String[] { \"ID\" });                                                   // 여기서 자동 증가하는 key값을 두 번째 파라미터로 전달                   // 인덱스 파라미터 값 설정                  pstmt.setString(1, member.getEmail());                  pstmt.setString(2, member.getPassword());                  pstmt.setString(3, member.getName());                  pstmt.setTimestamp(4,                          Timestamp.valueOf(member.getRegisterDateTime()));                  // 생성한 PreparedStatement 객체 리턴                  return pstmt;              }          }, keyHolder);          Number keyValue = keyHolder.getKey();          member.setId(keyValue.longValue());      }          ...        keyHolder 구현 클래스인 GeneratedKeyHolder 객체를 생성  preparedStatement의 두 번째 파라미터로 new String[] {“ID”}(자동 증가 칼럼)을 전달  update() 매서드에 두 번째 파라미터로 keyHolder를 전달          KeyHolder keyHolder = new GeneratedKeyHolder();jdbcTemplate.update(new PreparedStatementCreator(){…생략}, keyHolder);        여기까지 진행 후, Main 실행시, The server time zone value ‘KST’ ~~~ 라는 익셉션이 발생 MySQL 5.1.X 이후 KST 타임존을 인식하지 못하는 에러가 발생 /etc/mysql/mysql.condf.d 설정 변경(경로는 상이할 수 있음)3. 트래잭션 처리  트랜잭션(Transaction)이란?: 두 개 이상의 쿼리를 한 작업으로 실행할 때 사용  Commit, Rollback을 통해 전부 반영하거나 기존 상태로 되돌림  JDBC는 Connection의 setAutoCommit(false)을 이용해 다음과 같이 트랜잭션을 시작하고 반영하거나 취소함      Connection conn = null;  try{      ...      conn.setAutoCommit(false); // 트랜잭션 범위 시작      ... 쿼리실행      conn.commit(); // 트랜잭션 범위 종료: 커밋  }  catch(SQLException ex){      if(conn != null)          // 트랜잭션 범위 종료: 롤백          try{ conn.rollback(); } catch (SQLException e){}  }  finally{      if(conn!= null)          try{ conn.close(); } catch(SQLException e){}  }        위와 같은 방식은 코드로 직접 트랜잭션의 범위를 설정하기 때문에, 개발자가 커밋이나 롤백을 누락하기 쉬움이에 다음에 나오는 스프링이 제공하는 방식을 사용3-1. @Tracsactional을 이용한 트랜잭션 처리  트랜잭션 범위에서 실행하고 싶은 매서드에 다음과 같이 @Transactional 어노테이션을 붙임      // ChangePasswordService.java  public class ChangePasswordService {      private MemberDao memberDao;              /* 어노테이션을 사용해 트랜잭션 범위 설정      * 따라서 memberDao.selectByEmail()에서 실행하는 쿼리와      * member.changePassword()에서 실행하는 쿼리는 한 트랜잭션에 묶임      */      @Transactional      public void changePassword(String email, String oldPwd, String newPwd) {          Member member = memberDao.selectByEmail(email);          if (member == null)              throw new MemberNotFoundException();          member.changePassword(oldPwd, newPwd);          memberDao.update(member);      }      ...  }        @Transactional 어노테이션의 올바른 작동을 위해 다음과 같은 설정이 필요          플랫폼 트랜잭션 매니저(PlatformTransactionManager) Bean 설정      @Transactional 어노테이션 활성화 설정          // AppCtx.java  @Configuration  // 다음 어노테이션을 통해 @Transactional 어노테이션 활성화  @EnableTransactionManagement  public class AppCtx {  ....  @Bean      // 플랫폼 트랜잭션 매니저 Bean 설정  public PlatformTransactionManager transactionManager() {      DataSourceTransactionManager tm = new DataSourceTransactionManager();      tm.setDataSource(dataSource());      return tm;  }                            3-2. @Transactional과 프록시  스프링은 @Transactional 어노테이션을 이용해 트랜잭션을 처리시, 내부적으로 AOP를 사용      트랜잭션 처리는 프록시를 통해 이루어짐      // MainForCPS.java  public class MainForCPS {      public static void main(String[] args) {          AnnotationConfigApplicationContext ctx =                   new AnnotationConfigApplicationContext(AppCtx.class);          /*          * 아래 코드를 실행시, ChangePasswordService 객체 대신          * 트랜잭션 처리를 위해 생성한 프록시를 리턴함          */          ChangePasswordService cps =                   ctx.getBean(\"changePwdSvc\", ChangePasswordService.class);          ...  }              위의 코드가 실행되기까지 과정은 다음과 같다.              MainForCPS -&gt; 프록시 (changePasswordService) -&gt; 플랫폼 트랜잭션 매니저 -&gt; 실제 기능(ChansgePasswordService)프록시 객체는 @Transactional 어노테이션이 붙은 매서드를 호출하면 플랫폼 트랜잭션 매니저를 사용해 트랜잭션을 시작        결과에 따라 커밋하거나 롤백            3-3. 트랜잭션 전파  트랜잭션 전파: 트랜잭션이 이미 실행되고 있는데, 내부에서 또 다른 트랜잭션이 수행되는 경우  스프링에서 @Transactional의 propagation 속성은 기본값이 Propagation.REQUIRED로서 이미 수행된 트랜잭션이 있다면, 트랜잭션을 새로 생성하지 않음(기존 트랜잭션 그대로 사용)  @Transactional의 주요 속성      value / propagation / isolation / timeout    Propagation의 주요 속성      REQUIRED / MANDATORY / REQUIRES_NEW / SUPPORTS / NOT_SUPPORTED / NEVER / NESTED    Isolation의 주요 속성      DEFAULT / READ_UNCOMMITED / READ_COMMITED / REPEATABLE_READ / SERIALIZABLE  ",
        "url": "/devlog/2019/12/30/spring-8.html"
      }
      ,
    
      "devlog-2019-12-30-spring-7-html": {
        "title": "[Spring] AOP 프로그래밍",
        "subtitle":"첫걸음 - 7",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. Proxy, AOP, Advice1-1. About proxy프록시는 기존 코드를 수정하지 않고 코드 중복을 피할 수 있는 방법으로써 다음과 같은 특징을 지님  핵심 기능의 실행은 다른 객체에 위임하고 부가적인 기능을 제공하는 객체 = 프록시(proxy)  실제 핵심 기능을 실행하는 객체 = 대상 객체  프록시는 핵심 기능을 구현하지 않음  대신 여러 객체에 공통으로 적용할 수 있는 기능을 구현1-2. About AOPAOP는 Aspect Oriented Programming의 약자로, 여러 객체에 공통으로 적용할 수 있는 기능을 분리해 재사용성을 높여주는 기법으로써 다음과 같은 특징을 지님  공통 기능 구현과 핵심 기능 구현의 분리  핵심 기능에 공통 기능을 삽입하며 다음과 같은 방법이 존재          컴파일 시점에 코드에 공통 기능을 삽입      클래스 로딩 시점에 바이트 코드에 공통 기능을 삽입      런타임에 프록시 객체를 생성해서 공통 기능을 삽입                  이 중, 스프링이 제공하는 AOP 방식은 프록시를 이용한 세 번째 방식                      스프링 AOP는 프록시 객체를 자동으로 생성해줌  AOP의 공통 기능을 Aspect라 칭하며, 아래와 같은 주요 용어가 존재          Advice: 언제 공통 관심 기능을 핵심 로직에 적용할 지를 정의      Joinpoint: Advice를 적용 가능한 지점을 의미(매서드 호출, 필드 값 변경 등, 스프링은 프록시를 이용해 AOP를 구현하기 때문에 매서드 호출에 대한 Joinpoint만 지원)      Pointcut: Joinpoint의 부분 집합, 실제 Advice가 적용되는 Joinpoint를 나타냄(스프링에서는 정규 표현식 및 AspectJ의 문법을 통해 Pointcut 정의)      Weaving: Advice를 핵심 로직 코드에 적용하는 것      Aspect: 여러 객체에 공통으로 적용되는 기능      1-3. About Advice  Before Advice: 대상 객체의 매서드 호출 전에 공통 기능을 실행  After Returning Advice: 대상 객체의 매서드가 익셉션 없이 실행된 이후에 공통 기능을 실행  After Throwing Advice: 대상 객체의 매서드를 실행하는 도중 익셉션이 발생한 경우에 공통 기능을 실행  After Advice: 익셉션 발생 여부에 상관없이 대상 객체의 매서드 실핼 후 공통 기능을 실행      Around Advice: 대상 객체의 매서드 실행 전, 후 또는 익셉션 발생 시점에 공통 기능을 실행          이 중 널리 사용되는 것은 Around Advice이며,  그 이유는 대상 객체의 매서드를 실행하기 전/후, 익셉션 발생등 다양한 시점에 원하는 기능을 삽입할 수 있기 때문      2. 스프링 AOP 구현스프링 AOP를 통해 공통 기능을 구현 및 적용하는 순서  Aspect로 사용할 클래스에 @Aspect 어노테이션을 붙임  @Pointcut 어노테이션으로 공통 기능을 적용할 Pointcut을 정의  공통 기능을 구현한 매서드에 @Around 어노테이션을 적용          후술할 예제는 크게              핵심기능: Calculator(인터페이스) &lt;- RecCalculator(상속)        공통기능: ExeTimeAspect(시간 측정) / CachceAspect(캐싱 기능)로 구현                      // Caculator.java public interface Calculator {\tpublic long factorial(long num);}                        // RecCalculator.javapublic class RecCalculator implements Calculator {\t@Override\tpublic long factorial(long num) {      if (num == 0)          return 1;      else          return num * factorial(num - 1);\t}}                                                      2-1. @Aspect, @Pointcut, @Around를 통한 AOP 구현    //ExeTimeAspect    // 공통 기능을 제공하는 클래스 설정    @Aspect    public class ExeTimeAspect {            // 공통 기능을 적용할 Pointcut 설정        @Pointcut(\"execution(public * chap07..*(..))\")        private void publicTarget() {        }            // 공통 기능을 구현할 매서드 설정        @Around(\"publicTarget()\")        public Object measure(ProceedingJoinPoint joinPoint) throws Throwable {            long start = System.nanoTime();            try {                            // proceed() 매서드를 사용해서 실제 대상 객체의 매서드를 호출                Object result = joinPoint.proceed();                return result;            } finally {                System.out.printf(\"%s.%s(%s) 실행 시간 : %d ns\\n\",                ...            }        }    }  @Aspect 어노테이션을 적용한 클래스는 Advice와 Pointcut을 함께 제공  @Pointcut 어노테이션은 cahp07 패키지나 그 하위 패키지에 속한 Bean 객체의 public 매서드를 설정          @Pointcut이 붙은 매서드는 다음의 조건을 일반적(반드시?)으로 만족해야 함              void 리턴 타입        비어있는 매서드        어떤 throws 문도 포함하지 않음              @Around 어노테이션은 publicTarget() 매서드에 정의한 Pointuct에 공통 기능을 적용  joinPoint.proceed() 매서드를 실행시, 대상 객체의 매서드가 실행되므로 이 코드 전후로 공통 기능을 위한 코드를 위치시킴          결과적으로 위 코드를 실행하게 되면,        Calculator 타입이 spring 패키지에 속하므로,         calculator Bean에 ExeTimeAspect 클래스에 정의한 공통 기능 measure()를 적용          // AppCtx.java  @Configuration  @EnableAspectJAutoProxy  public class AppCtx {          // exeTimeAspect 매서드가 공통 기능으로 사용될 프록시를 위한 Bean 객체를 생성하는 매서드          // 앞선 코드 ExeTimeAspect 클래스의 @Pointcut과 @Around 설정을 사용      @Bean      public ExeTimeAspect exeTimeAspect() {          return new ExeTimeAspect();      }      @Bean      public Calculator calculator() {          return new RecCalculator();      }  }        @Aspect 어노테이션을 붙인 클래스를 공통 기능으로 적용하려면,@EnableAspectJAutoProxy 어노테이션을 설정 클래스에 붙여야 함      @Aspect 어노테이션이 붙은 Bean 객체를 찾아 Bean 객체의 @Pointcut 설정과 @Around 설정을 사용          위의 코드를 수행하면 결과적으로 아래와 같은 흐름으로 진행              Main -&gt; Proxy -&gt; ExeTimeAspect(공통기능) -&gt; ProceedingJoinPoint -&gt; RecCalculator(핵심기능)                  @Before 어노테이션의 사용 예는 다음과 같다.              @Aspectpublic class ExeTimeAspect {\t@Pointcut(\"execution(public * chap07..*(..))\")\tprivate void publicTarget() {\t}\t\t@Before(\"publicTarget()\")\tpublic void beforeMethod() {\t\tSystem.out.println(\"실행전 시작!\");\t}       @Around(\"publicTarget()\")       public Object measure(ProceedingJoinPoint joinPoint) throws Throwable {\t       ...                            실행결과는 다음과 같다.              실행전 시작!———————————————————————// 여기까지 매서드 실행전 공통기능 수행 (@Before)RecCalculator.factorial([7]) 실행 시간 : 126851 nsCacheAspect: Cache에 추가[7]CacheAspect: Cache에서 구함[7]———————————————————————// 여기까지 원하는 위치에서 공통기능 수행 (@Around)            2-2. ProceedingJoinPoint의 매서드      Around Advice에서 사용할 공통 기능 매서드는 대부분 파라미터로 전달받은 ProceedingJoinPoint의 proceed() 매서드만 호출하면 됨(앞선 코드 ExeTimeAspect.java의 joinPoint.proceed() 부분)        이때 세부적인 정보가 필요하다면 아래와 같은 매서드를 통해 정보를 획득 가능          Signature getSignature(): 호출되는 매서드의 대한 정보를 구함      Object getTaget(): 대상 객체를 구함      Object[] getArgs(): 파라미터 목록을 구함                  예시: joinPoint.getTarget() 등                    3. 프록시 생성 방식    // 수정 전 MainAspect.java    Calculator cal = ctx.getBean(\"calculator\", Calculator.class);    // 수정 후 MainAspect.java    RecCalculator cal = ctx.getBean(\"calculator\", RecCalculator.class);  만약, 위와 같이 타입을 변경하여 Bean 객체를 가져온다고 하면,아래와 같이 설정 파일에 RecCalculator 객체를 반환하므로 문제가 없어 보임      // AppCtx.java  @Bean  public Calculator calculator() {      return new RecCalculator();  }              하지만 getBean() 매서드에 사용한 타입이 RecCalculator 인데 반해 실제 타입은 $Proxy17 이라는 메세지와 함께, 다음과 같은 이유로 에러 발생        현재 구조는 Calculator(인터페이스)를 RecCalculator와 $Proxy17가 상속받는 관계  스프링은 AOP를 위한 프록시 객체를 생성할 때 실제 생성할 Bean 객체가 인터페이스를 상속하면 인터페이스를 이용해 프록시를 구현      따라서 아래 코드처럼 Bean의 실제 타입이 RecCalculator 라고 해도,“calculator”에 해당하는 Bean 객체 타입은 Caculator 를 상속받은 프록시 타입이됨      // AppCtx.java  // AOP 적용시 RecCalculator가 상속받은 Calculator 인터페이스를 이용해 프록시 생성  @Bean  public Calculator calculator(){      return new RecCalculator();  }  // MainAspect.java  // calculator Bean의 실제 타입은 Calculator를 상속한 프록시 타입이므로  // RecCalculator로 타입변환을 할 수 없기 때문에 익셉션 발생  RecCalculator cal = ctx.getBean(\"calculator\", RecCalculator.class);          3-1. execution 명시자 표현 방식execution 명시자는 Advice를 적용할 매서드를 지정할 때 아래와 같이 사용    @Pointcut(\"execution(public * cahp07..*(..))\")    private void public Target(){    }  Aspect를 적용할 위치를 지정하기 위한 Pointcut 설정      스프링 AOP는 public 매서드에만 적용할 수 있기 때문에, 사실상 public만 가능          execution(수식어패턴? 리턴타입패턴 클래스이름패턴?매서드이름패턴(파라미터패턴)) 방식으로 사용              수식어패턴은 생략 가능하며 public, protected등이 올 수 있음        리턴타입패턴은 리턴 타입을 명시        클래스이름패턴, 매서드이름패턴은 클래스 이름 및 매서드 이름을 패턴으로 명시        파라미터패턴은 매칭될 파라미터에서 대해 명시        각 패턴에서 '..'은 0개 이상이라는 의미            3-2. Advice 적용 순서기존의 코드에는 ExeTimeAspect 클래스만 공통기능으로 구현했지만,이에 추가로 CacheAspect 클래스를 공통기능으로 구현해, 한 Pointcut에 여러 Advice를 적용    //CacheAspect.java    @Aspect    public class CacheAspect {        private Map&lt;Long, Object&gt; cache = new HashMap&lt;&gt;();        @Pointcut(\"execution(public * chap07..*(long))\")        public void cacheTarget() {        }                @Around(\"cacheTarget()\")        public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {            Long num = (Long) joinPoint.getArgs()[0];            if (cache.containsKey(num)) {                System.out.printf(\"CacheAspect: Cache에서 구함[%d]\\n\", num);                return cache.get(num);            }            Object result = joinPoint.proceed();            cache.put(num, result);            System.out.printf(\"CacheAspect: Cache에 추가[%d]\\n\", num);            return result;        }    }  위 클래스는 캐싱의 기능을 제공하며, 키 값이 hashmap에 존재하면 그 값을 리턴하고,없다면 프록시 대상 객체를 실행하여 그 결과를 캐시에 추가해 준 후, 그 값을 리턴  ExeTimeAspect 클래스와 동일하게, 공통기능으로 사용할 클래스에 @Aspect 공통기능을 적용할 부분에 @Pointcut 공통기능을 구현한 매서드에 @Around 어노테이션을 차례로 적용하여 구현  @Around 값으로 cacheTarget() 매서드를 지정  @Pointcut 설정은 첫 번째 인자가 long인 매서드를 대상으로 함  따라서 execute() 매서드는 앞서 작성한 Calculator의 fatoring(long) 매서드에 적용      새로운 Aspect를 구현했으므로 아래와 같이 두개의 Aspect를 추가하는 작업이 필요      // AppCtxWithCahce.java  @Configuration  @EnableAspectJAutoProxy  public class AppCtxWithCache {      @Bean      public CacheAspect cacheAspect() {          return new CacheAspect();      }      @Bean      public ExeTimeAspect exeTimeAspect() {          return new ExeTimeAspect();      }      @Bean      public Calculator calculator() {          return new RecCalculator();      }  }            위의 설정 클래스를 적용해 실행하는 코드는 아래와 같다.      // MainAspectWithCache.java  public class MainAspectWithCache {              public static void main(String[] args) {          AnnotationConfigApplicationContext ctx =                   new AnnotationConfigApplicationContext(AppCtxWithCache.class);          Calculator cal = ctx.getBean(\"calculator\", Calculator.class);          cal.factorial(7);          cal.factorial(7);          cal.factorial(5);          cal.factorial(5);          ctx.close();      }  }        위의 코드를 실행하면 아래와 같은 결과를 출력 함          RecCalculator.factorial([7]) 실행 시간 : 16584 nsCacheAspect: Cache에 추가[7] —————————————————-  // 여기까지 처음 cal.factorial(7) 결과CacheAspect: Cache에서 구함[7] // 두 번째 cal.factorial(7) 결과…        처음 factorial(7)을 실행할 때와 두 번째 실행할 때의 결과가 다른 것을 확인할 수 있으며,첫 번째는 ExeTimeAspect와 CacheAspect가 모두 적용되었고두 번째는 CacheAspect만 적용됨          이렇게 실행결과가 다른 이유는 Advice를 다음 순서로 적용했기 때문CacheAspect 프록시 -&gt; ExeTimeAspect 프록시 -&gt; 실제 대상 객체        앞선 코드의 caculator Bean 객체는 실제로 CacheAspect 프록시 객체CacheAspect 프록시 대상 객체는 ExeTimeAspect의 프록시 객체ExeTimAsepct 프록시 대상 객체는 실제 대상 객체      실제 코드상의 흐름은 다음과 같다.      // CacheAsepct.java  ...   if (cache.containsKey(num)) {      System.out.printf(\"CacheAspect: Cache에서 구함[%d]\\n\", num);      return cache.get(num);  }  /* 이 부분에서 해당 객체의 대상 객체를 호출  * 현재 CacheAspect -&gt; ExeTimeAspect -&gt; RecCalculator의 순서이므로  * jointPoint.proceed()를 호출하게 되면  * 대상 객체인 ExeTimeAspect 프록시를 호출  */  Object result = joinPoint.proceed(); // 실행순서 1)  cache.put(num, result);  System.out.printf(\"CacheAspect: Cache에 추가[%d]\\n\", num); // 실행순서 5)  return result;          // ExeTimeAspect.java  ...  try {          // 위와 마찬가지로 joinPoint.proceed()에서 해당 객체의 대상 객체를 호출          // 여기서는 실제 대상 객체 (RecCalculator)를 호출      Object result = joinPoint.proceed(); // 실행순서 2)      return result;  } finally {          ...      System.out.printf(\"%s.%s(%s) 실행 시간 : %d ns\\n\", // 실행순서 4)      ...  }  ...          // RecCalculator.java  ...  @Override  public long factorial(long num){ // 실행순서 3)  ...          3-3. @Order 어노테이션과 Aspect 적용 순서앞선 예제 코드의 흐름은 아래와 같다.  CacheAspect 프록시 -&gt; ExeTimeAspect 프록시 -&gt; RecCalculator (실제 대상 객체)          하지만 우리는 순서를 지정해준 적이 없는데, 어떤 정책에 의해 위와 같은 순서로 진행 되는가?            그 이유는 설정 파일에 아래와 같은 순서로 작성했기 때문      // AppCtxWithCahce.java  @Configuration  @EnableAspectJAutoProxy  public class AppCtxWithCache {          // 1번째로 적용될 Aspect      @Bean      public CacheAspect cacheAspect() {          return new CacheAspect();      }          // 2번째로 적용될 Aspect      @Bean      public ExeTimeAspect exeTimeAspect() {          return new ExeTimeAspect();      }      @Bean      public Calculator calculator() {          return new RecCalculator();      }  }              실제 두 Apsect의 위치를 맞바꾸면, 실행결과가 달라짐        어떤 Aspect가 적용되는지 순서가 중요하다면, 직접 순서를 지정해야 함      @Order 어노테이션을 해당 클래스에 적용함으로써 그 순서를 아래와 같이 지정 가능      import org.springframework.core.annotation.Order;  // ExeTimeAspect.java  @Aspect  @Order(1)  public class ExeTimeAspect{  ...  }  // CacheAspect.java  @Aspect  @Order(2)  public class CacheAspect{  ...  }              위의 설정대로 수행 시, 아래와 같은 순서로 실행ExeTimeAspect 프록시 -&gt; CacheAspect 프록시 -&gt; RecCalculator 실제 대상 객체      3-4. @Around의 Pointcut 설정과 @Pointcut의 재사용      @Pointcut 어노테이션이 아닌 @Around 어노테이션에 execution 명시자를 지접 아래와 같이 지정 가능      // CacheAspect.java  @Aspect  public class CacheAspect {          ...      @Around(\"execution(public * chap07..*(long))\")      public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {          ...      }  }            만약 같은 Pointcut을 여러 Advice가 함께 사용한다면, 아래와 같이 공통 Pointcut을 재사용 가능      // ExeTimeAspect.java  @Aspect  public class ExeTimeAspect {          // 다른 Advice가 참조하기 위해 prviate -&gt; public으로 변경      @Pointcut(\"execution(public * chap07..*(..))\")      public void publicTarget() {      }      ...  }          @Aspect  public class CacheAspect {      ...          // 앞선 코드의 Pointcut 재사용      @Around(\"aspect.ExeTimeAspect.publicTarget()\")      public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {          ...      }  }              만약 여러 Aspect에서 공통으로 사용하는 Pointcut이 있다면,별도 클래스에 Pointcut을 정의하고,각 Aspect 클래스에서 해당 Pointcut을 사용하도록 구성      이렇게 구성된 별도의 클래스는 따로 Bean에 등록할 필요 없고,@Around 어노테이션에서 해당 클래스에 접근 가능하면 사용 가능      ",
        "url": "/devlog/2019/12/30/spring-7.html"
      }
      ,
    
      "devlog-2019-12-30-spring-6-html": {
        "title": "[Spring] Bean의 라이프사이클과 범위",
        "subtitle":"첫걸음 - 6",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 스프링 Bean 객체의 라이프 사이클1-1. 컨테이너의 초기화와 종료  스프링 컨테이너는 초기화와 종료라는 라이프 사이클을 가짐  컨텍스트 객체가 생성되는 시점에 컨테이너를 초기화함  스프링 컨테이너는 설정 클래스에서 정보를 읽어와 알맞은 Bean 객체를 생성하고,각 Bean을 연결(의존 주입)하는 작업 수행  초기화가 끝난 후 컨테이너를 사용 가능(getBean()등의 작업으로 Bean 객체를 구하는 행위 등)  컨테이너 사용이 끝나면 컨테이너를 close() 매서드를 사용해 종료, Bean 객체의 소멸                  기본적으로 Spring의 ApplicationContext 구현은 초기화 프로세스에서 모든 싱글톤 빈을 생성 및 설정        따라서 Bean에 문제가 있을 경우 초기화 단계에서 알 수 있다는 장점이 존재        만약 어떤 이유로, 특정 Bean이 늦은 초기화를 원한다면 다음과 같이 두 가지 방법이 존재                      xml에서 Bean을 등록시 lazy-init 속성을 이용하여 초기화            Java Config에서 Bean을 등록시 @Lazy 어노테이션을 이용                                              설정파일 전체를 Lazy-init                    @Lazy@Configuration@ComponentScan(basePackages = \"com.baeldung.lazy\")public class AppConfig {     @Bean    public Region getRegion(){        return new Region();    }    ...                            특정 Bean을 Lazy-init        @Bean@Lazy(true)public Region getRegion(){    return new Region();}                            Lazy init을 하더라도 해당 Bean을 다른 Bean이 참조한다면 그 시점에 초기화 됨      1-2. Bean 객체의 라이프 사이클Bean 객체는 아래와 같은 라이프 사이클을 가지며 스프링 컨테이너에 의해 관리됨  객체생성 -&gt; 의존설정 -&gt; 초기화 -&gt; 소멸2. Bean 객체의 초기화와 소멸2-1. 스프링 인터페이스를 통한 구현스프링 컨테이너는 Bean 객체를 초기화하고 소멸하기 위해 빈 객체의 지정한 매서드를 호출  매서드 정의 인터페이스:          org.springframework.beans.factory.InitializingBean      org.springframework.beans.factory.DisposableBean        인터페이스:     // 초기화 인터페이스 public interface InitializingBean {     void afterPropertiesSet() throws Exception; } // 소멸 인터페이스 public interface DisposableBean {     void destroy() throws Exception; }              Bean 객체가 각 인터페이스를 구현하면 스프링 컨테이너는 해당하는 매서드를 실행      우리는 위의 코드에서 afterPropertiesSet()와 destroy() 매서드를 구현하면 됨        예시     // Client.java // 초기화와 소멸에 해당하는 인터페이스를 상속 후, 각 매서드 재정의 public class Client implements InitializingBean, DisposableBean {         ...         // 초기화 매서드 오버라이딩     @Override     public void afterPropertiesSet() throws Exception {         System.out.println(\"Client.afterPropertiesSet() 실행\");     }         ...         // 소멸 매서드 오버라이딩     @Override     public void destroy() throws Exception {         System.out.println(\"Client.destroy() 실행\");     } }           * 해당 코드를 수행하면 콘솔 화면에 매서드에서 정의한  `\"Client.afterPropertiesSet() 실행\"` 및 `\"Client.destroy() 실행\"`이 출력 됨        2-2. 커스텀 매서드를 통한 구현위의 두 인터페이스를 구현할 수 없거나, 두 인터페이스를 사용하지 않고 싶을 때 스프링 설정에서 직접 매서드를 지정 가능  Bean 태그에서 initMethod 속성과 destoryMethod 속성을 사용해 사용할 매서드 이름을 지정// AppCtxWithprototype.java@Configurationpublic class AppCtxWithPrototype {\t...\t// 매서드의 이름을 지정해 초기화와 소멸 로직을 처리\t@Bean(initMethod = \"connect\", destroyMethod = \"close\")\tpublic Client2 client2() {\t\tClient2 client = new Client2();\t\tclient.setHost(\"host\");\t\treturn client;\t}}2-3. Bean 설정 코드에서 직접 초기화/소멸을 수행// AppCtxWithprototype.java@Configurationpublic class AppCtxWithPrototype {\t...\t@Bean(destroyMethod = \"close\")\tpublic Client2 client2() {\t\tClient2 client = new Client2();\t\tclient.setHost(\"host\");                // 초기화는 직접 수행, 소멸은 커스텀 매서드를 통해 수행                client.connect();\t\treturn client;\t}}  위와 같이 직접 매서드를 호출하여 초기화도 가능  이때 해당 클래스 내부적으로 인터페이스를 상속받아 초기화를 실행해 두 번 초기화 과정이 수행되지 않도록 주의  initMethod 속성과 destroyMethod 속성에 지정한 매서드는 파라미터가 없어야 함만약 파라미터가 존재할 경우, 스프링 컨테이너는 Exception을 발생3. Bean 객체의 생성과 관리 범위  Bean 객체는 기본적으로 싱글톤(singleton)의 범위를 가짐  Bean 객체의 범위를 프로토타입(prototype)으로 지정시 Bean 객체를 매번 새롭게 생성  특정 Bean을 프로토타입으로 지정하려면, 다음과 같이 @Scope 어노테이션을 @Bean 어노테이션과 함께 사용                  프로토타입은 새로운 요청이 들어오면, 기존의 Bean을 바탕으로 복사해 새로운 객체를 생성        이렇게 만들어진 새로운 Bean은 스케줄링, 멀티스레딩등에 사용이 됨          // AppCtxWithprototype.java@Configurationpublic class AppCtxWithPrototype {        // 해당 Bean 객체를 프로토 타입으로 지정    @Bean    @Scope(\"prototype\")    public Client client() {        Client client = new Client();        client.setHost(\"host\");        return client;    }    // 해당 Bean을 명시저으로 싱글톤으로 지정    @Bean(initMethod = \"connect\", destroyMethod = \"close\")    @Scope(\"singleton\")    public Client2 client2() {        Client2 client = new Client2();        client.setHost(\"host\");        return client;    }}                                각 경우 해당 Bean 객체의 동일성은 아래와 같음      // 프로토 타입의 경우  Client client1 = ctx.getBean(\"client\", Client.class);  Client client2 = ctx.getBean(\"client\", Client.class);  // client1 != client -&gt; true  // 싱글톤의 경우  Client client1 = ctx.getBean(\"client\", Client2.class);  Client client2 = ctx.getBean(\"client\", Client2.class);  // client1 != client -&gt; false        프로토 타입을 갖는 Bean은 완전한 라이프 사이클을 따르지 않음  생성 및 초기화는 컨테이너가 해주지만, 소멸 처리는 코드에서 직접 해줘야 함",
        "url": "/devlog/2019/12/30/spring-6.html"
      }
      ,
    
      "devlog-2019-12-30-spring-5-html": {
        "title": "[Spring] 컴포넌트 스캔",
        "subtitle":"첫걸음 - 5",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. About Component 스캔1-1. 컴포넌트 스캔이란?  자동 주입과 함께 사용되는 기능  스프링이 직접 클래스를 검색해서 빈으로 등록해주는 기능  설정 코드가 크게 줄어듦1-2. @Component 어노테이션으로 스캔 대상 지정      기본 속성 값으로 해당 클래스를 스캔 대상으로 지정     //MemberDao.java import org.springframework.stereotype.Component; @Component public class MemberDao {     ... }            속성 값을 주어 스캔 대상으로 지정    //MemberInfoPrinter.java// 빈의 이름을 지정@Component(\"infoPrinter\")public class MemberInfoPrinter { ...}      컴포넌트 스캔시 Bean의 이름이 지정되는 방법은 위의 두 가지 방법에 따라 아래와 같이 결정됨  @Component 어노테이션에 값을 주지 않을 경우, Bean으로 등록할 때 사용될 이름은 클래스 이름의 첫 글자를 소문자로 바꾼 이름    즉, 클래스 이름이  MemberDao 라면 Bean 이름으로는 memberDao를 사용  @Component 어노테이션에 값을 주었다면, 그 값을 Bean의 이름으로 사용1-3. @ComponentScan 어노테이션으로 스캔 설정// AppCtx.javaimport org.springframework.context.annotation.ComponentScan;@Configuration// ComponentScan 어노테이션@ComponentScan(basePackages = {\"spring\"})public class AppCtx {       /*        * 다음과 같은 코드가 줄어들게 됨        * public MemberDao memberDao(){\t*     ...        * }        * public MemberInfoPrinter memberInfoPrinter(){\t*     ...        * }        */\t@Bean\t@Qualifier(\"printer\")\tpublic MemberPrinter memberPrinter1() {\t\treturn new MemberPrinter();\t}\t\t@Bean\t@Qualifier(\"summaryPrinter\")\tpublic MemberSummaryPrinter memberPrinter2() {\t\treturn new MemberSummaryPrinter();\t}\t\t@Bean\tpublic VersionPrinter versionPrinter() {\t\tVersionPrinter versionPrinter = new VersionPrinter();\t\tversionPrinter.setMajorVersion(5);\t\tversionPrinter.setMinorVersion(0);\t\treturn versionPrinter;\t}}  @ComponentScan 어노테이션으로 인해, 4장의 AppCtx 코드와 비교하여 설정 코드가 줄어듦  @ComponentScan의 basePackage 속성값은 {“spring”} 인데,이는 spring 한 개만 존재하고 그 패키지와 하위 패키지에 속한 클래스를 스캔 대상으로 설정1-4. 스캔 대상에서 제외하거나 포함시키기excludeFilters 속성을 사용하면 스캔할 때 특정 대상을 자동 등록 대상에서 제외 가능하고, 아래와 같이 3가지 사용법이 존재  제외 대상을 직접 지정  특정 어노티에션을 붙인 타입을 컴포넌트 대상에서 제외  특정 타입이나 그 하위 타입을 컴포넌트 스캔 대상에서 제외각 방법별 사용 예시는 아래와 같음  정규 표현식 / AspectJ 패턴을 사용한 대상 지정     // AppCtxWithExclude.java import org.springframework.context.annotation.FilterType; import org.springframework.context.annotation.ComponentScan.Filter; // 동일 코드에 대하여 정규표현식 / AspectJ 패턴 사용 방식 // 정규표현식을 이용한 1번째 방법 @Configuration @ComponentScan(basePackages = {\"spring\"},      excludeFilters =              (@Filter(type = FilterType.REGEX, pattern = \"spring\\\\..*Dao\" )\t\t ) // AspectJ를 이용한 2번째 방법 @Configuration @ComponentScan(basePackages = {\"spring\"},      excludeFilters =              (@Filter(type = FilterType.ASPECTJ, pattern = \"spring.*Dao\" )\t\t ) public class AppCtxWithExclude {     ... }              정규 표현식은 “spring”으로 시작하고 Dao로 끝나는 타입을 지정      AspectJ 패턴은 spring 패키지의 Dao로 끝나는 타입을 지정         특정 어노테이션을 제외     // NoProduct.java @Retention(RUNTIME) @Target(TYPE) public @interface NoProduct { } // ManualBean.java @Retention(RUNTIME) @Target(TYPE) public @interface ManualBean { }        위와 같은 특정 어노테이션을 붙인 타입을 텀포넌트 대상에서 제외하는 방법은 아래와 같이 존재     // AppCtxWithExclude.java @Configuration @ComponentScan(basePackages = {\"spring\"},      excludeFilters = {              @Filter(type = FilterType.ANNOTATION, classes = ManualBean.class )\t\t\t })              type 속성값으로 FilterType.ANNOTATION을 사용하면 class 속성에 필터로 사용할 어노테이션 타입을 값으로 줌      이 코드는 @ManualBean 어노테이션을 제외 대상에 추가했으므로, 결국 다음 클래스를 컴포넌트 스캔 대상에서 제외         // MemberDao.java @ManualBean @Component public class Member Dao{     ... }              @Retention, @Target 어노테이션?              어노테이션을 Customizing 하는 방법        @Retention: 어느 시점까지 어노테이션을 남길 것인가? (파라미터는 아래와 같음)                      SOURCE: 컴파일시 사라짐            CLASS: 컴파일러가 클래스를 참조할 때까지 유효            RUNTIME: 컴파일 이후에도 VM을 통해 참조 가능                          @Target: 어디에 우리가 만든 어노테이션을 적용할 것인가? (파라미터는 아래와 같음)                      TYPE: 클래스, 인터페이스            FIELD: 필드            METHOD: 매서드            PARAMETER: 파라미터            CONSTRUCTOR: 생성자            LOCAL_VARIABLE: 지역변수            ANNOTATION_TYPE: 어노테이션 타입            PACKAGE: 패키지                                특정 타입이나 그 하위 타입을 제외    // AppCtxWithExclude.java@Configuration@ComponentScan(basePackages = {\"spring\"},  excludeFilters = {          @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = MemberDao.class )\t\t\t})              classes 속성에는 제외할 타입의 목록을 지정        설정할 필터가 두 개 이상이면 @ComponentScan의 exludeFilters 속성에 배열을 사용해 @Filter 목록을 전달     // AppCtxWithExclude.java @Configuration @ComponentScan(basePackages = {\"spring\"},      excludeFilters = {              @Filter(type = FilterType.ANNOTATION, classes = ManualBean.class ),             (@Filter(type = FilterType.REGEX, pattern = \"spring\\\\..*Dao\" ) })          2. 컴포넌트 스캔에 따른 충돌 처리컴포넌트 스캔 기능을 사용해서 Bean을 등록할 경우, 아래와 같은 두 가지 충돌이 발생 가능  Bean 이름의 충돌  수동 등록에 따른 충돌2-1. Bean 이름 충돌  서로 다른 패키지에 같은 클래스의 이름이 존재하고, 두 클래스 모두 @Component 어노테이션이 붙게 된다면, Exception이 발생하게 됨  이럴 경우, 둘 중 하나에 명시적으로 Bean 이름을 지정해서 이름 충돌을 피해야 함2-2. 수동 등록에 따른 충돌  같은 클래스를 같은 이름으로 설정할 때:          @Component 어노테이션을 통해 이미 지정한 Bean의 클래스 이름이 존재하지만,  클래스 설정에 직접 해당 클래스를 동일한 이름으로 정해 등록하는 경우 발생      즉, 스캔할 때 사용하는 Bean 이름과 수동 등록한 이름이 같을 경우, 수동 등록한 Bean이 우선시 됨        같은 클래스를 다른 이름으로 설정할 때:          만약, 스캔할 때 사용하는 Bean 이름과 동일한 클래스를 다른 이름으로 수동 등록하는 경우에는   다른 이름의 두 개의 Bean이 만들어지게 됨      이런 경우에는 @Qualifier 어노테이션을 통해 알맞은 Bean을 선택해야 함      ",
        "url": "/devlog/2019/12/30/spring-5.html"
      }
      ,
    
      "devlog-2019-12-30-spring-4-html": {
        "title": "[Spring] 의존 자동 주입",
        "subtitle":"첫걸음 - 4",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 자동 의존 주입1-1. 자동 의존 주입?  의존 주입에 필요한 객체들을 찾아 스프링이 자동으로 필드에 할당해 주는 기능  스프링에서는 @Autowired와 @Resource 어노테이션 두 가지 방법이 존재      MVC 관점에서Component는 @Resource를Service는 @Autowired를 주로 사용하는 추세라고 함  1-2. 자동 의존 주입 예제: Bean 객체// ChangePasswordService.javapublic class ChangePasswordService {\t@Autowired\tprivate MemberDao memberDao;\t...\tpublic void setMemberDao(MemberDao memberDao) {\t\tthis.memberDao = memberDao;\t}}//AppCtx.java@Configurationpublic class AppCtx {\t@Bean\tpublic MemberDao memberDao() {\t\treturn new MemberDao();\t}\t\t@Bean\tpublic MemberRegisterService memberRegSvc() {\t\treturn new MemberRegisterService();\t}        // 아래 함수에서 의존을 주입하지 않아도 스프링이 @Autowired가 붙인 필드에        // 해당 타입의 Bean 객체를 찾아서 주입\t\t@Bean\tpublic ChangePasswordService changePwdSvc() {\t\treturn new ChangePasswordService();\t}        /* 기존 코드\t @Bean\t public ChangePasswordService changePwdSvc() {\t \tChangePasswordService pwdSvc = new ChangePasswordService();\t\tpwdSvc.setMemberDao(memberDao());\t\treturn pwdSvc;\t }        */        ...}  기존의 코드와는 다르게 memberDao()를 통해 생성된 Bean 객체를 setter 매서드에 넘겨주지 않음1-3. 자동 의존 주입 예제: method// MemberInfoPrinter.javapublic class MemberInfoPrinter {\tprivate MemberDao memDao;\tprivate MemberPrinter printer;        ...\t@Autowired\tpublic void setMemberDao(MemberDao memberDao) {\t\tthis.memDao = memberDao;\t}\t@Autowired\tpublic void setPrinter(MemberPrinter printer) {\t\tthis.printer = printer;\t}}//AppCtx.java@Configurationpublic class AppCtx {\t@Bean\tpublic MemberDao memberDao() {\t\treturn new MemberDao();\t}\t...        // 원래 호출하던 두 매서드 setPrinter(), setMemberDao()를 호출하지 않음\t@Bean\tpublic MemberInfoPrinter infoPrinter() {\t\tMemberInfoPrinter infoPrinter = new MemberInfoPrinter();\t\treturn infoPrinter;\t}        /* 기존코드        @Bean\tpublic MemberInfoPrinter infoPrinter() {\t\tMemberInfoPrinter infoPrinter = new MemberInfoPrinter();\t\tinfoPrinter.setMemberDao(memberDao());\t\tinfoPrinter.setPrinter(memberPrinter());\t\treturn infoPrinter;\t}        */\t...}  @Autowired 어노테이션을 필드나 매서드에 붙이게 되면, 스프링은 타입이 일치하는 Bean 객체를 찾아서 주입  만약 일치하는 Bean이나 매서드가 없는 경우, Exception이 발생하고 제대로 실행되지 않음      최근에는 위와 같은 방법이 권장  1-4. 자동 주입 가능 Bean이 두 개 이상이라면?// AppCtx.java@Configurationpublic class AppCtx {\t@Bean\tpublic MemberDao memberDao() {\t\treturn new MemberDao();\t}\t...        // memberPrinter1() 매서드의 Bean의 한정 값으로 \"printer\"를 지정\t@Bean\t@Qualifier(\"printer\")\tpublic MemberPrinter memberPrinter1() {\t\treturn new MemberPrinter();\t}\t\t@Bean\tpublic MemberPrinter memberPrinter2() {\t\treturn new MemberPrinter();\t}\t...}// MemberListPrinter.javapublic class MemberListPrinter {\tprivate MemberDao memberDao;\tprivate MemberPrinter printer;\t...\t@Autowired        // 앞서 스프링 설정 클래스에서 @Qualifier 어노테이션의 값으로 \"printer\"를 준        // MembeerPrinter 타입의 Bean(memberPrinter1)을 자동 주입 대상으로 사용\t@Qualifier(\"printer\")\tpublic void setMemberPrinter(MemberPrinter printer) {\t\tthis.printer = printer;\t}}  @Qualifier 어노테이션을 통해 자동 주입 Bean을 지정할 수 있음  Bean 설정에 @Qualifier 어노테이션이 없다면, Bean의 이름을 한정자로 지정2. @Autowired 어노테이션의 필수 여부자동 주입할 대상이 필수가 아닌 경우(NULL값 등) 아래와 같이 세가지 방법이 존재  @Autowired(required = false) 어노테이션 사용  자동 주입 대상 타입의 Optional 지정  @Nullable 어노테이션 사용  아래와 같이 dateTimeFormatter 필드값이 Null이어도 되는 경우 3가지 방법 예시    // MemberPrinter.javapublic class MemberPrinter {  private DateTimeFormatter dateTimeFormatter;  ...      // 차례대로 1~3번 방법의 동일 매서드 코드      // 1번 방법  @Autowired(required = false)  public void setDateFormatter(DateTimeFormatter dateTimeFormatter) {      this.dateTimeFormatter = dateTimeFormatter;  }      // 2번 방법  @Autowired  public void setDateFormatter(Optional&lt;DateTimeFormatter&gt; dateTimeFormatter) {      this.dateTimeFormatter = dateTimeFormatter;  }      // 3번 방법  @Autowired  public void setDateFormatter(@Nullable DateTimeFormatter dateTimeFormatter) {      this.dateTimeFormatter = dateTimeFormatter;  }        각 방법의 특징은 아래와 같음      1. 매칭되는 Bean이 없어도 Exception이 발생하지 않으며 자동 주입을 수행하지 않음      2. 일치하는 Bean이 존재하지 않으면 값이 없는 Optional을 인자로 전달(Exception 발생하지 않음), 일치하는 Bean이 존재하면 해당 Bean을 값으로 갖는 Optional을 인자로 전달      3. 스프링 컨테이너는 setter 매서드를 호출할 때 자동 주입할 Bean이 존재하면 해당 빈을 인자로 전달, 존재하지 않으면 인자로 NULL을 전달    1번 방법은 매칭되는 Bean이 없으면 매서드를 실행하지 않지만,2,3번 방법은 매칭되는 Bean이 없어도 해당 매서드를 실행함",
        "url": "/devlog/2019/12/30/spring-4.html"
      }
      ,
    
      "devlog-2019-12-30-spring-3-html": {
        "title": "[Spring] 스프링 DI",
        "subtitle":"첫걸음 - 3",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 의존이란?  DI는 Dependency Injection의 약자로 우리말로는 의존주입이라 번역  의존이란 객체간의 의존을 의미  한 클래스가 다른 클래스의 매서드를 실행할 경우 이를 의존한다고 표현(변경에 의해 영향을 받는 관계)2. About DI  OOP의 DIP와는 비슷한 개념  디자인 패턴의 IoC(Inversion of Control) 제어 반전의 한 종류          용어가 정확하게 구분되어 있지는 않지만, 대략 IoC &gt; DIP &gt; DI 정도로 정리가능자세한 사항은 링크 참조: https://bit.ly/2Zt9cnf        객체지향 5대 원칙: SOLID                  단일 책임 원칙(Single responsibility principle) - SRP        개방 폐쇄 원칙(Open/closed principle) - OCP        리스코프 치환 원칙(Liskov substitution principle) - LSP        인터페이스 분리 원칙(Interface segregation principle) - ISP        의존관계 역전 원칙(Dependency inversion principle) - DIP            2-1. DI를 통한 의존 처리  DI는 의존하는 객체를 직접 생성하는 대신, 의존 객체를 전달받는 방식을 이용    // MemberRegisterService.javapublic class MemberRegisterService {  private MemberDao memberDao;      // MemberDao 객체를 전달 받아 DI를 구현  public MemberRegisterService(MemberDao memberDao) {      this.memberDao = memberDao;  }      ...}          2-2. Why DI?  DI를 사용하는 가장 큰 이유는 변경의 유연함  객체를 전달받아 사용하게 되면, 코드의 수정을 최소한으로 줄이고 유연함을 가져갈 수 있음(주입 대상이 되는 객체를 생성하는 코드만 변경하면 됨)2-3. DI 방식 1: 생성자 방식// MemberRegisterService.javapublic class MemberRegisterService {\tprivate MemberDao memberDao;        // 생성자를 통해 의존 객체를 주입 받음\tpublic MemberRegisterService(MemberDao memberDao) {\t\tthis.memberDao = memberDao;\t}\tpublic Long regist(RegisterRequest req) {                // 주입 받은 의존 객체의 매서드를 사용\t\tMember member = memberDao.selectByEmail(req.getEmail());                ...\t\tmemberDao.insert(newMember);\t\treturn newMember.getId();\t}}  생성자를 통해 의존 객체를 주입받아 필드에 할당  전달할 의존 객체가 두 개 이상이어도 동일한 방식으로 주입2-4. DI 방식 2: setter 매서드 방식// MemberInfoPrinter.javapublic class MemberInfoPrinter {\tprivate MemberDao memDao;\tprivate MemberPrinter printer;        ...        // setter를 통해 의존 객체를 주입 받는다.\tpublic void setMemberDao(MemberDao memberDao) {\t\tthis.memDao = memberDao;\t}\tpublic void setPrinter(MemberPrinter printer) {\t\tthis.printer = printer;\t}}  setter 매서드를 이용하여 객체를 주입2-5. 생성자 VS setter?  각 방식의 장점은 곧 다른 방식의 단점  생성자 방식 장점: Bean 객체를 생성하는 시점에 모든 의존 객체가 주입, 그러나 생성자의 파라미터가 많을 경우 일일히 확인해 주어야 함  setter 매서드 방식: sstter 매서드 이름을 통해 어떤 의존 객체가 주입 되는지 알 수 있음, 그러나 정확한 전달이 안될 시  NullPointerException 발생가능3. 싱글톤의 이해와 어노테이션3-1. @Configuration 설정 클래스의 @Bean 설정과 싱글톤// AppCtx.java@Configurationpublic class AppCtx {\t@Bean\tpublic MemberDao memberDao() {\t\treturn new MemberDao();\t}\t\t@Bean\tpublic MemberRegisterService memberRegSvc() {                // memberDao() 매서드 호출\t\treturn new MemberRegisterService(memberDao());\t}\t\t@Bean\tpublic ChangePasswordService changePwdSvc() {\t\tChangePasswordService pwdSvc = new ChangePasswordService();                // memberDao() 매서드 호출\t\tpwdSvc.setMemberDao(memberDao());\t\treturn pwdSvc;\t}        ...}  memberRegSvc() 매서드와 changePwdSvc() 매서드는 둘 다 memberDao() 매서드를 실행그리고 memberDao() 매서드는 매번 새로운 MemberDao 객체를 생성해서 리턴두 매서드는 과연 같은 MemberDao 객체를 사용하는가?  스프링 컨테이너는 @Bean이 붙은 매서드에 대해 한 개의 객체만 생성  이는 다른 설정에서 memberDao()를 몇 번을 호출하더라도 항상 같은 객체를 리턴  이것이 가능한 이유는 스프링이 설정 클래스를 그대로 사용하지 않고,설정한 클래스를 상속한 새로운 설정 클래스를 만들어서 사용하기 때문  따라서 런타임에 매번 생성하지 않고, 한 번 생성한 객체를 보관했다가 이후에는 동일한 객체를 리턴// 이해를 돕기 위한 가상의 코드. 실제 코드는 이보다 훨씬 복잡하다.public class AppCtxExt extends AppCtx {        private Map&lt;String, Object&gt; beans = ...;\t@Override\tpublic MemberDao memberDao() {\t\tif(!beans.containersKey(\"memberDao\"))                    beans.put(\"memberDao\", super.memberDao());                return (MemberDao) beans.get(\"memberDao\");\t}        ...}  매번 새로운 객체를 리턴하는 것이 아니라, 한 번 생성한 객체를 보관했다가 동일 객체를 리턴3-2. 두 개 이상의 설정 파일을 사용하기  @AutoWired 어노테이션을 통해 필요한 Bean 객체를 자동 주입  @Import 어노테이션을 통해 함께 사용할 클래스를 지정",
        "url": "/devlog/2019/12/30/spring-3.html"
      }
      ,
    
      "devlog-2019-12-26-spring-2-html": {
        "title": "[Spring] 스프링 시작하기",
        "subtitle":"첫걸음 - 2",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "0. 들어가기 앞서스프링을 이용한 자바 프로젝트 진행 과정은 아래와 같다.  메이븐 프로젝트 생성  이클립스에서 메이븐 프로젝트 Import  스프링에 맞는 자바 코드와 설정 파일 작성  실행1. Maven1-1. 메이븐 기본 디렉토리 구조  Maven 기본 설정 파일인 pom.xml 파일이 프로젝트 root에 위치  기본 소스코드 디렉토리          src/main/java        테스트코드 디렉토리          src/test/java        compile 결과 디렉토리          target      1-2. 메이븐 기초  메이븐의 핵심 pom.xml  pom.xml은 메이븐 프로젝트에 대한 설정 정보를 관리하는 파일  의존 모듈이나 플러그인 등에 대한 설정을 담음1-3. 메이븐 의존 설정&lt;!-- pom.xml --&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;  메이븐은 한 개의 모듈을 아티팩트 단위로 관리  위 설정은 spring-context 식별자를 가진 5.0.2.RELEASE 버전의 아티팩트에 대한 의존을 추가한 예제1-4. 메이븐 레포지토리  메이븐의 아티팩트 파일은 기본적으로 원격 레포지토리와 로컬 레포지토리를 이용  메이븐은 로컬 레포지토리에서 [그룹ID][아티팩트ID][버전] 폴더에 아티팩트ID-버전.jar 형식의 이름을 갖는 파일이 있는지 검사  로컬 레포지토리에 파일이 없으면 메이븐은 원격 중앙 레포지토리로부터 해당 파일을 다운로드하여 로컬 레포지토리에 복사한 뒤 그 파일을 사용  설정한 아티팩트가 다시 의존하는 파일도 포함하여 다운로드  배포 및 테스트할 때는 로컬 레포지토리(.m2등)에 있는 파일을 지우고 원격 레포지토리에서 다운로드하는 것을 권장1-5. 메이븐 프로젝트 임포트  이클립스에서 [File]-&gt;[Import] 메뉴 이용2. About Spring2-1. 스프링이 생성하고 관리하는 객체 = Bean//AppContext.java@Configurationpublic class AppContext {    @Bean    public Greeter greeter() {        ...    }    }  @configuration 어노테이션은 해당 클래스를 스프링 설정 클래스로 지정  @Bean 어노테이션을 매서드에 붙이면 해당 매서드가 생성한 객체를 스프링이 관리하는 Bean 객체로 등록  @Bean 어노테이션을 붙인 매서드의 이름은 Bean 객체를 구분할 때 사용 (위의 예시에서는 greeter를 사용하게 됨)  @Configuration 어노테이션 말고, XML 파일로도 설정파일을 생성 가능@Configuration 어노테이션은 변경사항이 생길 시, 매번 컴파일 해야하지만 XML로 설정한 파일은 몇 글자를 고치기만 하면 됨자세한 사항은 링크 참조: https://bit.ly/2MGXG1J2-2. 스프링은 객체 컨테이너//Main.javapublic class Main {\tpublic static void main(String[] args) {                // 1. 설정 정보를 이용해 Bean 객체를 생성\t\tAnnotationConfigApplicationContext ctx = \t\t\t\tnew AnnotationConfigApplicationContext(AppContext.class);                // 2. Bean 객체를 제공\t\tGreeter g = ctx.getBean(\"greeter\", Greeter.class);\t\t...\t\tctx.close();\t}}  AnnotationConfigApplicationContext 클래스는 스프링의 핵심인 객체 생성 및 초기화를 담당, 자바 클래스의 정보를 읽어옴  AnnotationConfigApplicationContext의 상위 클래스 ApplicationContext 또는 BeanFactory는 Bean 객체의 생성, 초기화, 보관, 관리 등을 담당하고 있어 컨테이너(Container)라고도 부름  getBean() 매서드를 통해 해당 Bean 객체를 제공          컨테이너는 보통 인스턴스의 생명주기를 관리하며, 생성된 인스턴스들에게 추가적인 기능을 제공하도록하는 것스프링 컨테이너의 두 종류: 빈팩토리(BeanFactory), 어플리케이션 컨텍스트(ApplicationContext)              BeanFactory: DI의 기본사항을 제공하는 가장 단순한 컨테이너, Bean을 생성하고 분배하는 책임을 지는 클래스ApplicationContext: 빈팩토리와 유사한 기능을 제공하지만 좀 더 많은 기능을 제공하는 어플리케이션 컨텍스트추가기능:                  국제화가 지원되는 텍스트 메시지를 관리          이미지같은 파일 자원을 로드 할 수 있는 포괄적인 방법을 제공          리너스로 등록된 빈에게 이벤트 발생을 알려 줌                    2-3. Singleton 객체  별도의 설정을 하지 않을 경우 스프링은 한 개의 Bean 객체만을 생성  이때 Bean 객체는 싱글톤(singleton) 범위를 갖는다고 표현  싱글톤은 단일 객체(single object)를 의미  스프링은 기본적으로 한 개의 @Bean 어노테이션에 한 개의 Bean 객체를 생성      이때 singleton은 디자인 패턴의 singleton과는 약간의 차이가 존재    스프링의 싱글톤은 직접 오브젝트를 만들고 관리    자바의 싱글톤 = private static으로 인스턴스 생성 / 스프링의 싱글톤 = 싱글톤 레지스트리    자세한 사항은 링크 참조: https://bit.ly/2MG41KR  ",
        "url": "/devlog/2019/12/26/spring-2.html"
      }
      ,
    
      "devlog-2019-12-26-spring-1-html": {
        "title": "[Spring] 스프링이란?",
        "subtitle":"첫걸음 - 1",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "스프링이란?  흔히 말하는 스프링 = 스프링 프레임워크스프링 프레임워크의 특징은 다음와 같다.  의존 주입(Dependency Injection: DI) 지원  AOP(Aspect-Oriented Programming) 지원  MVC 웹 프레임워크 제공  JDBC, JPA 연동, 선언적 트랜잭션 처리 등 DB 연동지원  spring과 spring MVC는 다르다스프링 프레임워크의 주요 용어는 다음과 같다.  의존 주입: 객체를 직접 생성하는 것이 아닌 외부에서 객체를 주입시켜 사용하는 방식  AOP: 핵심 기능과 공통 기능을 분리 시켜놓고, 공통 기능을 필요로 하는 핵심 기능들에서 사용하는 방식  JDBC:  자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API  JPA: JPA란 자바 ORM 기술에 대한 API 표준 명세  ORM: 객체와 DB 테이블이 매핑을 이루는 것  선언적 트랜잭션: 설정 파일이나 어노테이션을 통해 트랜잭션의 범위, 롤백 규칙 등을 정의스프링 프레임워크외 다른 스프링 프로젝트는 아래와 같다.  스프링 데이터: 적은 양의 코드로 데이터 연동을 처리할 수 있도록 도와주는 프레임워크. JPA, 몽고DB, 레디스등 다양한 저장소 지원  스프링 시큐리티: 인증/인가와 관련된 프레임워크로서 웹 접근 제어, 객체 접근 제어, DB, 오픈 ID, LDAP 등 다양한 인증 방식, 암호화 기능 제공  스프링 배치: 로깅/추적, 작업 통계, 실패 처리 등 배치 처리에 필요한 기본 기능을 제공개발환경  Spring: 5.0.2.RELEASE  Java openjdk 1.8.0_22  Apache maven 3.7  Tomcat 8.5.43",
        "url": "/devlog/2019/12/26/spring-1.html"
      }
      ,
    
      "devlog-2019-12-26-spring-0-html": {
        "title": "[Spring] 스프링5 스터디를 위한 프로젝트",
        "subtitle":"첫걸음 - 0",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "스프링5 스터디를 위한 프로젝트      본 시리즈는 다음 2가지의 교재를 바탕으로 학습에 목적을 둔 글임을 밝힙니다.    목차 1~17:          교재: 초보자를 위한 스프링5 프로그래밍 입문      저자: 최범균      소스코드: https://github.com/madvirus/spring5fs        목차 18~:          교재: 스프링5 레시피      저자: 마틴 데니엄, 다니엘 루비오, 조시 롱 지음, 이일웅 옮김      소스코드: https://github.com/nililee/spring-5-recipes      목차  Intro  스프링 시작하기  스프링 DI  의존 자동 주입  컴포넌트 스캔  Bean 라이프사이클과 범위  AOP 프로그래밍  DB연동  스프링 MVC 시작하기  스프링 MVC 동작방식  MVC1: 요청 매핑, 커맨드 객체, 리다이렉트, 폼 태그, 모델  MVC2: 메시지, 커맨드 객체 검증  MVC3: 세션, 인터셉션, 쿠키  MVC4: 날짜 값 변환, @PathVariable, 익셉션 처리  간단한 웹 어플리케이션의 구조  JSON 응답과 요청 처리  프로필과 프로퍼티 파일  Spring Security부록0-1. try ~ catch ~ finally문 return위치에 따른 결과 in Java0-2. Abstract Class VS Interface0-3. JDBC란0-4. 커넥션 풀0-5. JDBC, JPA/Hibernate, Mybatis 차이",
        "url": "/devlog/2019/12/26/spring-0.html"
      }
      
    
  };
</script>
<script src="/js/lunr.min.js" charset="utf-8"></script>
<script src="/js/search.js" charset="utf-8"></script>

<!-- just under line for input box -->
<style>
  input.underline {
    border-style:none;
    border-bottom:1px solid #000;
    box-shadow: 0 1px 0 0 #000;
  }
</style>
</body>

  <!-- Footer -->

<hr>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <ul class="list-inline text-center">
          
          <li class="list-inline-item">
            <a href="mailto:owin2828@gmail.com">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="far fa-envelope fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          
          
          
          
          <li class="list-inline-item">
            <a href="https://github.com/owin2828">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="copyright text-muted">Copyright &copy; owin2828 2020</p>
      </div>
    </div>
  </div>
</footer>


  <script src="/assets/vendor/jquery/jquery.min.js"></script>
<script src="/assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
<script src="/assets/vendor/startbootstrap-clean-blog/js/clean-blog.min.js"></script>

<script src="/assets/scripts.js"></script>




</body>

</html>
