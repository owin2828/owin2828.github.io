<!DOCTYPE html>

<html>

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>
    낮코밤코
  </title>

  <meta name="description" content="Already done, cause will do">

  <link href='http://cdn.jsdelivr.net/gh/joungkyun/font-d2coding/d2coding.css' rel='stylesheet' type='text/css'>
  <!-- <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'> -->

  <link rel="stylesheet" href="/assets/vendor/bootstrap/css/bootstrap.css">

  <link rel="stylesheet" href="/assets/vendor/fontawesome-free/css/all.min.css">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://owin2828.github.io/search.html">
  <link rel="alternate" type="application/rss+xml" title="낮코밤코" href="/feed.xml">

  <!-- 웹 폰트 설정 -->
  <!-- <link rel="stylesheet" href="http://cdn.jsdelivr.net/gh/joungkyun/font-d2coding/d2coding.css"> -->
  <link rel="stylesheet" href="/assets/syntax.css">
  
    <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-TVK6F4S');</script>
    <!-- End Google Tag Manager -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-154694140-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154694140-1');
</script>


</head>


<body>
  
    <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-TVK6F4S"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
  

  <!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="/">&#9750; Fake it, till U make it</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fa fa-bars"></i>
    </button>
    <div
     class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="/about">| About</a>
        <li class="nav-item">
          <a class="nav-link" href="/posts">| All Posts</a>
        </li>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href=# id="navbarDropdownMenuLink" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            | Devlog
          </a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
            <a class="dropdown-item" href="/devlog/aws">AWS</a>
            <a class="dropdown-item" href="/devlog/devops/">DevOps</a>
            <a class="dropdown-item" href="/devlog/java">Java</a>
            <a class="dropdown-item" href="/devlog/GraphQL">GraphQL</a>
            <a class="dropdown-item" href="/devlog/spring">Spring</a>
            <a class="dropdown-item" href="/devlog/web">Web</a>
            <a class="dropdown-item" href="/devlog/vue">Vue</a>
            <a class="dropdown-item" href="/devlog/etc">Etc</a>
          </div>
        </li>
        <!-- <li class="nav-item">
          <a class="nav-link" href="/contact">| Contact</a>
        </li> -->
        <li class="nav-item">
          <a class="nav-link" href="/search">
            <i class="fa fa-search" aria-hidden="true"></i> Search
          </a>
        </li>
      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->

<header class="masthead" style="background-image: url('/img/whale.jpg')">
  
    <div class="overlay"></div>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <div class="page-heading">
            <h1><!--낮코밤코--></h1>
            
            <span class="subheading">Already done, cause will do</span>
            
          </div>
        </div>
      </div>
    </div>
  </header>
<body>
    
  <div class="search-in">
    <form action="/search.html" method="get">
      <i class="fa fa-search" aria-hidden="true"></i>
      <input class="underline" type="text" id="search-box" name="query" placeholder="검색어를 입력해주세요." style="width:17rem">
      <!-- <input type="submit" value="search"> -->
    </form>
  </div>


<ul id="search-results"></ul>

<script>
  window.store = {
    
      "devlog-2020-11-13-web-14-html": {
        "title": "[GraphQL] GraphQL GraphQL의 구성요소",
        "subtitle":"GraphQL에 대한 고찰 - 2",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "GraphQL",
        "content": "들어가기 앞서저번 포스팅에 이어, GraphQL에 대해 알아보고자 한다. 실제 구성요소와 구현 방법등에 대하여 서술할 예정이다.1. GraphQL의 구성요소GraphQL는 크게 다음과 같은 구성 요소로 이루어져 있다.  쿼리/뮤테이션(query/mutation)  스키마/타입(schema/type)  리졸버(resolver)1-1. 쿼리/뮤테이션(query/mutation)GraphQL에서는 요청을 보내는 방법을 2가지로 정의하는데, 쿼리와 뮤테이션이다. 이 둘은 다른것 같지만, 실상은 별 차이가 없다.쿼리는 조회(R)에 사용되고, 뮤테이션은 데이터의 변조(CUD)에 사용되는 개념적인 규약이다.// 쿼리를 통한 데이터 조회// 단순한 조회 작업{  human(id: \"1000\") {    name    height  }}// 인자를 통한 조회query HeroNameAndFriends($episode: Episode) {  hero(episode: $episode) {    name    friends {      name    }  }}// mutation을 통한 데이터 변조mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {  createReview(episode: $ep, review: $review) {    stars    commentary  }}1-2. 스키마/타입(schema/type)카카오 기술블로그에는 다음과 같은 설명이 첨부되어 있다.  데이터베이스 스키마(Schema)를 작성할 때의 경험을 SQL 쿼리 작성으로 비유한다면, gql 스키마를 작성할 때의 경험은 C, C++의 헤더파일 작성에 비유가 됩니다.그러므로, 프로그래밍언어(C, C++, JAVA등)에 익숙한 프로그래머라면 스키마 정의 또한 쉽게 배우실 것입니다.즉, 스키마라는 것은 GraphQL에서 사용될 객체 타입을 사전에 지정하는 작업으로써 다음과 같은 형식을 지닌다.type Character {  name: String!  appearsIn: [Episode]!}  오브젝트 타입 : Character  필드 : name, appearsIn  스칼라 타입 : String, ID, Int 등  느낌표(!) : 필수 값을 의미(non-nullable)  대괄호([, ]) : 배열을 의미(array)1-3. 리졸버(Resolver)데이터베이스에는 데이터베이스 어플리케이션을 사용하여 데이터를 가져오는 구체적인 과정이 구현되어 있다.그러나 GraphQL에서는 데이터를 가져오는 구제적인 과정을 직접 구현해야 하며 이는 리졸버(Resolver)가 담당하게 된다.이를 통해 데이터베이스뿐 아니라, 일반 파일 및 http SOAP 같은 네트워크 프로토콜을 활용하여 원격 데이터를 가져올 수 있다.GraphQL에서는 각 필드마다 하나의 함수가 존재하게 되고, 이 함수는 다음 타입을 반환하게 되며 이 각 함수를 리졸버라 부른다.필드가 스칼라 값(String, Int 같은 primtive 타입)인 경우에는 연쇄 호출이 중지되고, 종료된다.type Query {  users: [User]  user(id: ID): User  limits: [Limit]  limit(UserId: ID): Limit  paymentsByUser(userId: ID): [Payment]}type User {    ...}type Limit {    ...    user: User    ...}type Payment {    ...\tuser: User!    ...}  위와 같은 코드에서 User와 Limit는 1:1, User와 Payment는 1:N의 관계이다.이때 다음과 같은 동일한 쿼리명을 가진 2가지 쿼리를 살펴보자.// 쿼리1. 필드값 2개{  paymentsByUser(userId: 10) {    id    amount  }}// 쿼리2. 필드값 3개{  paymentsByUser(userId: 10) {    id    amount    user {      name      phoneNumber    }  }}이 때 필드 1개당 리졸버 함수 1개가 불리게 되므로, 밑의 쿼리가 더 많은 함수를 호출하게 된다.또한 각각의 리졸버 함수는 내부적으로 데이터베이스 쿼리가 존재하게 되는데, 이 두가지를 조합하면 다음과 같은 사실을 알 수 있다.  쿼리에 맞게 필요한만큼만 최적화하여 호출 가능즉 기존의 RESTful API는 정해진 쿼리가 무조건 호출됨에 비해, 리졸버 체인을 잘 활용하여 효율적인 설계를 할 수 있다는 뜻이다.2. GraphQL 비지니스 로직  비지니스 로직 레이어(출처: https://graphql.github.io/learn/thinking-in-graphs/)GraphQL을 이용하여 비지니스 로직을 작성할 때, 실제 로직은 리졸버 함수에 담지 않는다.유효성 검사 및 권한 확인과 실제 로직은 전부 전용 비지니스 로직 레이어 내부에 담게 된다.requestPaymentSession: async (parent, {     pgId, name, sex, birthDay, phoneNumber, amount, productName, ref }, context, info) =&gt; {    // 실제 로직은 비지니스 레이어로    const ret = await requestPaymentSession({ pgId, name, birthDay, phoneNumber, sex, amount, productName, ref })    return removeSymbol(ret)},requestPaymentApprove: async (parent, {    sessionKey, authNumber}, context, info) =&gt; {    // 실제 로직은 비지니스 레이어로    const ret = await requestApprovePayment({ sessionKey, authNumber })    return removeSymbol(ret)}끝마치며이로써 기본적인 GraphQL의 구성 및 구현 방법에 대하여 알아보았다.물론 실제로 코드에 위의 개념을 녹이는 것은 완전 다른 이야기지만..Refernece  GraphQL Blog  카카오기술블로그",
        "url": "/devlog/2020/11/13/web-14.html"
      }
      ,
    
      "devlog-2020-11-12-web-13-html": {
        "title": "[GraphQL] GraphQL 특징 및 장,단점",
        "subtitle":"GraphQL에 대한 고찰 - 1",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "GraphQL",
        "content": "들어가기 앞서GraphQL에 대하여 얘기는 많이 들었지만, 한 번도 써본적이 없어 이 참에 해보려 한다.GraphQL을 정확하게 이해하기 전에는 그저 새로운 프레임워크, 라이브러리정도로 생각했으나, 전혀 새로운 개념이라는 것을 알게 되었다.GraphQL의 기본에 대한 포스팅은 2회에 걸쳐 진행할 예정인데, 이론적인 부분과 실제로 구성되어 있는 것들을 살펴 보고자 한다.1. GraphQL이란?처음에 이름을 들었을 때, 맨 처음든 생각은 왜 그래프라는 단어가 들어갔을까 라는 점이다.해당 의문에 대한 답은 GraphQL 홈페이지에서 확인할 수 있었는데, 다음과 같이 서술되어 있다.  GraphQL을 사용하면 비즈니스 도메인을 그래프로 모델링 할 수 있습니다.스키마를 정의하여 비즈니스 도메인을 그래프로 연결할 수 있다는 말인데, 구조를 알기 전까지는 이해하기 어려운 문장이다.한 문장으로만 요약하자면, Facebook이 개발한 Query언어 라고 할 수 있겠다.1-1. 기존 REST API 통신의 한계사내에서 REST API 서버를 구축하며 재미있고, 즐거우며 Front-end 개발자와 협업 하는 것이 굉장이 용이하다는 생각을 하였다.그러나 개발하는 서비스의 덩치가 점점 커지며 다음과 같은 문제점들에 당면하게 되었는데 생각보다 나를 괴롭게 만들었다.  특정 기능을 위해 여러번 API가 호출 됨  특정 요청에 fit한 응답을 돌려주기 위해서는 API를 새로 만들어야함  API 유지보수의 어려움한 문장으로 요약하면, 관리해야 할 EndPoint의 증가로 인하여 발생되는 문제점이라 할 수 있다.1-2. GraphQL의 특징GraphQL의 가장 큰 특징은 다음 그림과 같이 EndPoin가 하나 라는 점이다.  REST API와 GraphQL API의 사용(출처 : https://blog.apollographql.com/graphql-vs-rest-5d425123e34b)기존에 REST API에서는 정보를 얻기 위해 여러번 네트워크를 호출하거나, 다양한 API를 호출해야 했다.하지만 GraphQL은 단 하나의 Endpoint를 제공하며, 단 한 번의 요청으로 모든 정보를 가져온다.1-3. GraphQL의 통신 방법  HTTP와 gql의 기술 스택 비교(출처 : https://tech.kakao.com/2019/08/01/graphql-basic/)위의 그림과 같이 Cient-side와 Server-side에서 각각 모듈을 활용하여 통신을 주고 받을 수 있으며, 다음과 같은 언어를 지원한다.  JavaScript  Pyhton  Ruby  Java  C#  Scala  Go  PHP  Swift  R  Kotlin또한, Client-side에서 지원되는 라이브러리는 다음과 같이 2가지 종류가 존재하나, 글을 쓰는 현재(2020년11월)에는 Apollo가 대세이다.  Relay  Apollo GraphQL1-4. GraphQL을 사용하는 기업이러한 매력적인 장점을 제공함에도, 여전히 GraphQL을 기반으로 OpenAPI를 제공하는 회사는 거의 없는 것 같다.GraphQL 홈페이지에 들어가면 현재 GraphQL을 사용하는 기업들의 목록이 나와있는데, 다음과 같은 기업들이 함께한다.  Facebook  Github  Pinterest  Intuit  Coursera  Shopify이 중, Github은 API v3에서는 REST를 사용하다가 v4에서는 GraphQL로 갈아탔는데, 위 링크의 글을 읽어보면 조금 더 GraphQL의 장점을 알 수 있다.또한 Github Explorer에서 GraphQL을 사용해볼 수 있도록 지원을 하는데, 로그인 이후 본인 계정의 정보를 조회해볼 수 있다.  Github v4 Explorer2. GraphQL의 장점GraphQL은 위에서 언급한 특징을 기반으로 다음과 같은 장점을 지닌다.2-1. 하나의 Endpoint단 한 개의 Endpoint를 지님으로써, API나 View를 따로 구성할 필요가 없어진다.요청을 보낼때는 정해진 한 군데로만 요청을 보내면 되고, 그 외의 API를 신경쓸 필요가 없어져, 유지보수가 용이해진다.2-2. Fit한 DataGraphQL은 한번의 요청으로 원하는 모든 데이터를 서버로부터 요청하여 가져온다.따라서 기존에 REST API만을 사용할때 발생하는 Overfetching이나 Underfetching등의 문제가 발생하지 않는다.  Overfetching원하는 data 이상의 정보를 요청받는 것, data의 정제에 리소스가 낭비  Underfetching원하는 data의 정보를 요청받기 위해 여러번 요청을 보내는 것, 네트워크를 통해 여러번 접근을 하여 리소스 낭비2-3. 기종에 상관없는 APIFacebook의 GraphQL blog에서는 iOS, Android에 따라 다른 기종을 위해 제공하는 API 구현이 힘들었다고 한다.RESTful API로는 일일히 다른 기종을 위해 API를 구현해야 했다고 말하며, 표준화된 쿼리언어를 개발했다고 한다.2-4. Redux를 대체할 ApolloReact와 함께 사용하는 어플리케이션에서는 Flux 아키텍처를 구현한 Redux를 제공하는데, 이는 다음과 같은 방식으로 진행된다.  Redux와 Universal Router를 사용한 SSR의 프로세스를 나타낸 도식(출처 : https://d2.naver.com/helloworld/2838729)기존의 Redux와 Universal Router를 사용한 SSR은 위의 사진처럼 실행되고 이는 다음과 같은 단점을 야기한다.  리소스를 가져오는 로직과 API를 라우팅 경로마다 구현해야 함  Redux의 스토어를 사용하기 위해 액션과 리듀서를 구현해야 함  렌더링 절차가 복잡  렌더링에 필요한 모든 리소스를 받을 때까지 렌더링을 실행할 수 없음이를 Apollo 기반의 서비스에서 React Router v4 라이브러리를 사용하여 다음과 같이 진행할 수 있게 된다.  Apollo와 React Router v4를 사용한 SSR의 프로세스를 나타낸 도식(출처 : https://d2.naver.com/helloworld/2838729)  React Router v4에서 라우팅 경로에 맞는 컴포넌트를 랜더링  컴포넌트를 렌더링할 때 Apollo Client를 통해 컴포넌트 렌더링에 필요한 리소스를 받은 후 HTML 코드로 변환  서버에서 받은 HTML 코드로 클라이언트 렌더링을 실행Redux와 Universal Router를 사용할 때보다 프로세스가 간결해졌다.또한 Redux와 Universal Router 조합에서 생겨난 단점이 보완되고 다음과 같은 장점이 추가되었다.  라우팅 경로에 상관없이 컴포넌트별로 필요한 리소스만 가져올 수 있음  리소스를 가져오는 데 시간이 오래 걸리는 컴포넌트는 리소스를 가져오지 않고 렌더링만 실행하고, 클라이언트 렌더링을 실행할 때 리소스를 가져오게 할 수 있음  라우팅 경로에 의존성이 사라져서 재사용 가능한 컴포넌트의 개발이 용이해짐  내부의 분기가 없는 하나의 라우터 코드로 클라이언트 렌더링과 서버 렌더링을 실행할 수 있음  별도의 액션과 리듀서가 없어도 필요한 리소스를 컴포넌트에서 사용할 수 있음  위의 내용은 https://d2.naver.com/helloworld/2838729의 글을 참조한 부분이며, Redux에 대한 지식이 부족하여 원문 그대로의 내용을 들고 왔습니다.3. GraphQL의 단점GraphQL의 단점으로 알려진 것들로는 다음과 같은 특징이 있다.3-1. HTTP 캐싱HTTP의 캐싱 전략은 각각 URL에 각자의 정책을 설정하는 방식으로 이루어 지는데, RESTful API는 이를 그대로 사용이 가능하다.그러나 GraphQL은 하나의 URL로 처리하기에, HTTP에서 제공하는 캐싱 전략을 그대로 사용하는 것은 불가능하다.따라서 GraphQL만의 캐싱 방법을 제공하게 되는데, 대표적으로는 영속쿼리(persisted query), 아폴로엔진(Apollo Engine)등이 있다.3-2. 파일 업로드GraphQL은 지속적으로 성장하는 생태계로써, 완성된 명세가 존재하지 않는다. 따라서 이 외의 것들은 직접 개발할 수 밖에 없게 된다.대표적인 예로 파일업로드가 있는데, 다만 이에 대해 몇가지 대안이 있다.  Base64 인코딩을 사용  Upload를 위해 분리된 API 사용  apollo-upload-server 같이 GraphQL multipart 요청 명세를 구현하는 라이브러리를 사용3-3. 요청 필터링의 어려움GraphQL은 클라이언트가 필요한 데이터를 스스로 결정하여 요청하게 된다.따라서 GraphQL의 다양한 요청형태에서 잘못된 요청을 필터링하기가 까다롭다.끝마치며GraphQL을 공부하며 GraphQL이 무엇인지 특징 및 장점에 대해 알아보았다.다음 포스팅에서는 GraphQL의 구조에 대해 알아볼 예정이다.Refernece  GraphQL Blog  카카오기술블로그  네이버기술블로그  방성범님블로그",
        "url": "/devlog/2020/11/12/web-13.html"
      }
      ,
    
      "devlog-2020-11-12-web-12-html": {
        "title": "[AsCal(Awsome-Calender)] Toy project의 시작",
        "subtitle":"팀내 일정 토이 프로젝트 - 1",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "web",
        "content": "들어가기 앞서최근 연말에 들어서며, 팀 내에서 다양한 스터디를 진행하고 있다. 나 또한 참여자로써 무엇을 할까 고민하다가, 팀내 캘린더를 만들기로 하였다.물론 기존에 다양한 방법으로 일정을 보고 있지만, 한 눈에 모아보기가 힘들다는 단점이 있어 토이프로젝트로 진행하려고 한다.사내 스터디를 진행하며, 마주치게 될 일들을 기록으로 남긴다.토이 프로젝트에 앞서 계획과 일정 그리고 생각하는 Mock-up Page 등을 끄적이고자 한다.  물론 절대 이 일정과 계획되로 매끄럽게 되진 않겠지..1. 이름은 짓기 귀찮아 대충 Awsome-Calender의 앞글자를 따서 AsCal이라고 명칭했다.2. Mock-up Page다양한 툴을 조사 중에 있으나, 결정되어 만들어지면 올릴 예정3. TechStack사실 이번 토이프로젝트의 가장 중요한 부분이자 토이프로젝트의 목적인 기술 Stack은 다음과 같이 꾸릴 예정이다.  Mongo DB –&gt; SQLite로 변경(prsima2가 이 글을 쓰는 현재(2020.11.12) 아직 몽고를 지원안한다..)  Nodejs  GraphQL  React  AWS4. Schedule이번 토이프로젝트의 기간은 약 5주에 걸쳐 진행 될 예정으로, 총 3번 정도 다음과 같이 발표를 하게 될 것 같다.  1주차: 환경 구성 및 HelloWorld APP 개발하기  2주차: AsCal 기본 기능 및 화면 개발  3주차: AsCal 고도화 및 회고끝마치며사실 위의 기술스택 중 GraphQL과 React를 잘 모르기 때문에, 좀 삽질을 할 것 같다.  특히 GraphQL은 기존에 익숙한 RESTful API와는 좀 다르기에 따로 공부를 해봐야겠다.Reference  GraphQL의 특징 및 장단점  GraphQL의 구성요소",
        "url": "/devlog/2020/11/12/web-12.html"
      }
      ,
    
      "devlog-2020-11-06-web-11-html": {
        "title": "[Vue] 뷰 프로젝트 구성",
        "subtitle":"vue.js에 대한 이해 - 7",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "vue",
        "content": "들어가기 앞서기존에 작성한 포스팅의 방법으로 화면을 구성하면 대략 다음과 같은 구조를 지니게 된다.  여러 개의 컴포넌트  페이지를 이동할 라우터그러나 위와 같은 구조로 HTML 파일을 구성할 경우, 가독성 저하와 한 눈에 구조파악의 어려움의 단점이 있다.따라서, 이를 해결하기 위한 방법을 알아보도록 하자.1. 싱글 파일 컴포넌트 체계이러한 문제를 해결하는 방법은 싱글 파일 컴포넌트(Single File Components) 체계이다.싱글 파일 컴포넌트란, .vue 파일로 프로젝트를 구성하는 방식을 의미한다.즉, 확장자 .vue 파일 1개는 뷰 어플리케이션을 구성하는 1개의 컴포넌트와 동일하다.  2. 뷰 CLI싱글 파일 컴포넌트를 사용하기 위해서는 .vue 파일을 웹 브라우저가 인식할 수 있도록 변환해주는 다음과 같은 도구가 필요하다.  웹팩(Webpack)  브라우저리파이(Broswerify)          웹펙은 웹의 자원(HTML, CSS, 이미지 등)들을 자바스크립트 모듈로 변환해 하나로 묶어 웹성능을 향상시키는 자바스크립트 모듈 번들러이다. 브라우저리파이도 웹팩과 유사한 번들러이지만, 웹 자원 압축이나 빌드 자동화 같은 기능은 없다.      이러한 모듈 번들러를 사용하지 않고도 편하게 프로젝트를 구성할 수 있도록 뷰에서 CLI(Command Line Interface)를 제공한다.  Vue CLI 설치를 위해서는 Node.js가 설치되어야 한다.Node.js 및  Vue CLI 설치는 본 포스팅에서는 다루지 않는다.3. 뷰 로더뷰 로더(Vue Loader)는 웹팩에서 지원하는 라이브러리로, .vue 파일의 내용을 웹페이지 형태로 변환해준다.즉 각 파일에서 &lt;template&gt;, &lt;script&gt;, &lt;style&gt; 내용이 각 HTML, js, CSS로 인식되도록 변환 작업을 수행한다.이와 같은 과정을 통해 최종적으로 다음의 단계로 프로젝트를 구동할 수 있게 된다.  뷰 CLI 설치: npm i vue-cli -g  프로젝트 생성: vue init webpack-simple  관련 라이브러리 설치: npm isntall  프로젝트 구동: npm run dev          뷰 CLI 명령어로는 다음과 같은 종류가 존재              vue init webpack: 고급 웹팩 기능을 활용한 프로젝트 구성        vue init webpack-simple: 웹팩 최소 기능을 활용한 프로젝트 구성        vue init browserify: 고급 브라우저리파이 기능을 활용한 프로젝트 구성        vue init browserify-simple: 브라우저리파이 최소 기능을 활용한 프로젝트 구성        vue init simple: 최소 뷰 기능이 포함된 HTML 파일 1개 작성        vue init pwa: 웹팩기반의 프로그레시브 웹 앱(PWA, Progressive Web App) 기능을 지원            끝마치며이로써 기초적인 뷰의 구성 및 프로젝트 구성 방법을 알아보았다. 백앤드의 개발을 주로 하는 나에게는 낯설고 생소한 개념과 어색함이 아직도 묻어난다.얼른 친숙해지기 위해서 실제 어플리케이션을 제작하며 학습한 내용을 더 탄탄하게 다져야겠다.",
        "url": "/devlog/2020/11/06/web-11.html"
      }
      ,
    
      "devlog-2020-11-06-web-10-html": {
        "title": "[Vue] 뷰 템플릿",
        "subtitle":"vue.js에 대한 이해 - 6",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "vue",
        "content": "들어가기 앞서뷰 템플릿(Vue Template)은  HTML, CSS등의 마크업 속성과 뷰 인스턴스에서 정의한 데이터 및 로직들을 연결하여 사용자가 브라우저에서 볼 수 있는 형태의 HTML로 변환해주는 속성으로, 다음과 같이 크게 2가지 방법이 존재한다.  ES5에서 뷰 인스턴스의 template 속성을 이용하는 방법  싱글 파일 컴포넌트 체계의 &lt;template&gt; 코드를 활용템플릿에서 사용하는 뷰의 속성과 문법은 다음과 같다.  데이터 바인딩  자바스크립트 표현식  디렉티브  이벤트 처리  고급 템플릿 기법1. 데이터 바인딩데이터 바인딩은 HTML 화면 요소를 뷰 인스턴스와 연결하는 것을 의미하며, 주요 문법으로는 { { } }과 v-bind 속성이 있다.1-1. { { } } - 콧수염 괄호중괄호 2개를 이용하는 방법은 HTML 태그에 연결하는 가장 기본적인 텍스트 삽입 방식이다.&lt;div id = \"app\"&gt;\t{ {message}}&lt;/div&gt;&lt;script&gt;\tnew Vue({\t\tel: '#app',\t\tdata: {\t\t\tmessage: 'Hello Vue.js!'\t\t}\t});&lt;/script&gt;만약 데이터가 변경되어도 값을 바꾸지 않고 싶다면, v-once 속성을 사용한다.&lt;div id = \"app\" v-once&gt;\t{ {message}}&lt;/div&gt;1-2. v-bindv-bind는 아이디, 클래스, 스타일 등의 HTML 속성 값에 뷰 데이터 값을 연결할 때 사용한다....    &lt;div id=\"app\"&gt;      &lt;p v-bind:id=\"idA\"&gt;아이디 바인딩&lt;/p&gt;      &lt;p v-bind:class=\"classA\"&gt;클래스 바인딩&lt;/p&gt;      &lt;p v-bind:style=\"styleA\"&gt;스타일 바인딩&lt;/p&gt;    &lt;/div&gt;...    &lt;script&gt;      new Vue({        el: '#app',        data: {          idA: 10,          classA: 'container',          styleA: 'color: blue'        }      });    &lt;/script&gt;...  추가적으로, v-bind: 문법을 :로 간소화 할 수 있다. 그러나 약식문법은 혼동을 야기할 수 있으므로, 기본 문법으로 쓰자.2. 자바스크립트 표현식뷰의 템플릿에서도 자바스크립트 표현식을 사용할 수 있다. { { } }안에 자바스크립트 표현식을 넣으면 된다....    &lt;div id=\"app\"&gt;      &lt;p&gt;{ { message }}&lt;/p&gt;      &lt;p&gt;{ { message + \"!!!\" }}&lt;/p&gt;      &lt;p&gt;{ { message.split('').reverse().join('') }}&lt;/p&gt;    &lt;/div&gt;...    &lt;script&gt;      new Vue({        el: '#app',        data: {          message: 'Hello Vue.js!'        }      });    &lt;/script&gt;...  출력Hello Vue.js!Hello Vue.js!!!!sj. euV olleH그러나 위와 같은 방식에서 다음과 같은 2가지를 주의해야 한다.  자바스크립트의 선언문과 분기 구문은 사용 불가능  복잡한 연산은 인스턴스 안에서, 화면에서는 간단한 결과만 표시...    &lt;div id=\"app\"&gt;      &lt;!-- 1. --&gt;      { { var a = 10; }} &lt;!-- X, 선언문은 사용 불가능 --&gt;      { { if (true) {return 100} }} &lt;!-- X, 분기 구문은 사용 불가능 --&gt;      { { true ? 100 : 0 }} &lt;!-- O, 삼항 연산자로 표현 가능 --&gt;      &lt;!-- 2. --&gt;      { { message.split('').reverse().join('') }} &lt;!-- X, 복잡한 연산은 인스턴스 안에서 수행 --&gt;      { { reversedMessage }} &lt;!-- O, 스크립트에서 computed 속성으로 계산 후 최종 값만 표현 --&gt;    &lt;/div&gt;...    &lt;script&gt;      new Vue({        el: '#app',        data: {          message: 'Hello Vue.js!'        },        computed: {          reversedMessage: function() {            return this.message.split('').reverse().join('');          }        }      });    &lt;/script&gt;...  위에서 역순으로 변환하는 함수는 computed 속성을 이용해 계산을 한다.이러한 방법은 캐싱 효과를 제공하여 성능을 높일 수 있다. 3. 디렉티브뷰 디렉티브(Directive)란 HTML 태그 안에 v- 접두사를 가지는 모든 속성을 의미하며 다음과 같은 종류가 존재한다.  v-if: 지정한 뷰 데이터 값의 참, 거짓 여부에 따라 HTML 태그를 화면에 표시하거나 표시하지 않음  v-for: 지정한 뷰 데이터의 개수만큼 해당 HTML 태그를 반복 출력  v-show: 데이터의 진위여부에 따라 표시하거나 표시하지 않음, 실제 태그는 남아있고 화면상으로만 노출하지 않음  v-bind: 뷰 데이터 - HTML 기본속성 연결  v-on: 화면 요소의 이벤트를 감지하여 처리  v-model: 폼(form)에서 주로 사용, 폼의 값과 뷰 데이터를 즉시 동기화.화면에 입력된 값을 저장하여 서버에 보내거나, watch와 같은 속성을 사용하여 추가 로직 수행4. 이벤트 처리뷰는 화면에서 발생한 이벤트를 처리하기 위해 v-on 디렉티브와 method 속성을 사용한다....    &lt;div id=\"app\"&gt;      &lt;button v-on:click=\"clickBtn\"&gt;클릭&lt;/button&gt;    &lt;/div&gt;...    &lt;script&gt;\t// 클릭 이벤트 처리     \tmethods: {          clickBtn: function() {            alert('clicked');\t\t  }        }\t// 매서드 호풀 시, 인자 값 넘기기     \tmethods: {          clickBtn: function(num) {            alert('clicked' + num + 'times');\t\t  }        }\t// event 인자를 이용해 화면 요소의 돔 이벤트에 접근     \tmethods: {          clickBtn: function(event) {            console.log(event);\t\t  }        }    &lt;/script&gt;...5. 고급 템플릿 기법고급 템플릿 기법은 데이터 바인딩과 디렉티브 같은 기본적인 문법과 함께 사용하는 유용한 속성이다.5-1. computed 속성computed 속성은 데이터 연산들을 정의하는 영역으로, 다음과 같은 장점을 지닌다.  data 속성 값의 변화에 따라 자동을 다시 연산  캐싱          캐싱의 특징을 정확히 이해하려면, 비슷한 기능을 하는 method 기능과의 비교가 필요      5-2. computed 속성과 methods 속성의 차이점가장 큰 차이점은 method 속성은 호출할 때만 해당 로직이 수행되고, computed 속성은 값의 변경에 따라 자동적으로 수행 된다는 것이다.다시 말해, method 속성은 수행할 때마다 연산을 하기에 별도로 값을 저장하지 않는다.하지만, computed 속성은 데이터가 변경되지 않는한 이전 값을 캐싱하고 있다가, 반환한다.  따라서 복잡한 연산을 반복 수행해서 화면에 나타낼 경우, computed 속성을 이용하는 것이 효율적이다.5-3. watch 속성watch 속성은 데이터의 변화를 감지하여 자동으로 특정 로직을 수행한다.computed 속성과 비슷하지만, computed 속성은 간단한 연산을 수행하는 반면에,watch 속성은 데이터 호출 처럼 상대적으로 더 많이 소요되는 비동기 처리에 적합하다.끝마치며뷰 템플릿에 대하여 간단하게 알아보았다. 다음 포스팅에서는 뷰 프로젝트의 구성에 대해 알아볼 예정이다.",
        "url": "/devlog/2020/11/06/web-10.html"
      }
      ,
    
      "devlog-2020-10-28-web-9-html": {
        "title": "[Vue] HTTP 통신",
        "subtitle":"vue.js에 대한 이해 - 5",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "vue",
        "content": "들어가기 앞서브라우저와 서버간의 통신을 위해 HTTP라는 프로토콜을 통한다. 이때 웹 앱 HTTP 통신의 대표적인 방법으로 jQuery의 ajax가 있다.이는 서버에서 받아온 데이터를 표시할 때 화면 전체를 갱신하지 않고 화면의 일부분만 변경할 수 있게 하는 자바 스크립트의 기법이다.뷰에서도 마찬가지로 이를 지원하기 위한 라이브러리로 뷰 리소스와 axios를 지원한다.1. 뷰 리소스뷰 리소스(resource)는 초기에 지원되는 라이브러리였으나, 2016년 말에 지원이 중단되어 기존에 관리했던 PageKit 팀의 라이브러리로 돌아갔다.현재도 계속하여 사용가능하며, CDN을 이용해 라이브러리를 로딩하는 방법과 NPM으로 라이브러리를 설치하는 방법이 있다.하지만 뷰의 창시자인 에반이 2016년 말에 지원을 중단하며 대안으로 axios가 뷰의 대세를 이루게 되었다.  뷰 리소스는 본 포스팅에서는 다루지 않는다.2. Axios액시오스(Axios)는 현재 뷰 커뮤니티에서 가장 많이 사용되는 HTTP 통신 라이브러리이다.Promise 기반의 API 형식이 다양하게 제공되어 별도의 로직을 구현할 필요 없이 주어진 API로 구현이 가능하다.  Promise 기반의 APIPromise란 서버에 데이터를 요청하여 받아오는 동작같은 비동기 로직 처리에 유용한 자바스크립트 객체이다.자바스크립트는 단일 스레드로 처리하기에 비동기 동작을 처리하기 위해 promise와 같은 방법을 활용한다.액시오스는 CDN을 활용하여 사용할 수 있는데, 다음과 같은 코드를 추가하면 된다.&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;  axios API에 대한 자세한 설명은 이곳을 참조이를 활용해 간단하게 GET 요청을 보내 데이터를 출력하는 코드는 다음과 같다.&lt;html&gt;\t&lt;head&gt;\t\t&lt;title&gt;Vue with Axios Sample&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;div id=\"app\"&gt;\t\t\t&lt;button v-on:click=\"getData\"&gt;프레임워크 목록 가져오기&lt;/button&gt;\t\t&lt;/div&gt;\t\t&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js\"&gt;&lt;/script&gt;\t\t&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;!-- 액시오스 라이브러리 로딩 --&gt;\t\t&lt;script&gt;\t\t\tnew Vue({\t\t\t\tel: '#app',\t\t\t\tmethods: {\t\t\t\t\tgetData: function() {                                                // 액시오스 GET 요청 API\t\t\t\t\t\taxios.get('https://raw.githubusercontent.com/joshua1988/doit-vuejs/master/data/demo.json')\t\t\t\t\t\t\t.then(function(response) {\t\t\t\t\t\t\t\tconsole.log(response);\t\t\t\t\t\t\t});\t\t\t\t\t}\t\t\t\t}\t\t\t});\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;끝마치며여기까지 진행하며 간단하게 뷰의 라우터 및 HTTP 통신에 대해 알아보았다.다음 글에서는 뷰 템플릿과 프로젝트 구성에 대해 알아보자.",
        "url": "/devlog/2020/10/28/web-9.html"
      }
      ,
    
      "devlog-2020-10-28-web-8-html": {
        "title": "[Vue] 라우터",
        "subtitle":"vue.js에 대한 이해 - 4",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "vue",
        "content": "들어가기 앞서웹 페이지의 경우, 여러 페이지로 구성되어 있기 때문에 페이지 간에 이동을 돕는 라우터를 사용해야 한다.이를 위해 뷰에서는 뷰 라우터 라이브러리를 지원하는데 이번 포스팅에서는 이를 알아보도록 한다.1. 라우팅이란?라우터(Router)를 이해하기 위해서는 먼저 라우팅(Routing)에 대해서 알아야 한다.라우팅이란 웹 피이지간의 이동 방법을 의미하는데, 싱글 페이지 어플리케이션(SPA, Single Page Application)에서 주로 사용한다.  SPA(Singe Page Application)페이지를 이동할 때마다 서버에 웹 페이지를 요청하여 새로 갱신하는 것이 아니라, 미리 해당 페이지들을 받아놓고 화면을 갱신하는 기법이런 라우팅을 이용하면 다음과 같은 장점을 지니게 된다.  화면간의 전환이 매끄러움  사용자 입장에서 응답성이 빨라짐  뷰 라우터를 사용하지 않고, HTML 파일들로도 JavaScript 라이브러리를 활용하여 라우팅 방식의 페이지 이동이 구현 가능이러한 라이브러리로는 router.js, navigo.js 등이 존재2. 뷰 라우터뷰 라우터란 뷰에서 라우팅 기능을 구현하도록 지원하는 공식 라이브러리이며, 이를 이용하여 뷰로 만든 페이지 간에 자유로운 이동이 가능하다.  &lt;router-link to=\"URL 값\"&gt;: 페이지 이동 태그. 화면에서는 &lt;a&gt;로 표시되며 틀릭하면 to에 지정된 URL로 이동  &lt;router-view&gt;: 페이지 표시태그. 변경되는 URL에 따라 해당 컴포넌트를 뿌려주는 영역&lt;html&gt;  &lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Vue Router Sample&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"app\"&gt;      &lt;h1&gt;뷰 라우터 예제&lt;/h1&gt;      &lt;p&gt;        &lt;!-- 1. URL 값을 변경하는 태그 --&gt;        &lt;router-link to=\"/main\"&gt;Main 컴포넌트로 이동&lt;/router-link&gt;        &lt;router-link to=\"/login\"&gt;Login 컴포넌트로 이동&lt;/router-link&gt;      &lt;/p&gt;      &lt;!-- 2. URL 값에 따라 갱신되는 화면 영역 --&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js\"&gt;&lt;/script&gt;    &lt;script src=\"https://unpkg.com/vue-router@3.0.1/dist/vue-router.js\"&gt;&lt;/script&gt;    &lt;script&gt;      // 3. Main. Login 컴포넌트 내용 정의      var Main = { template: '&lt;div&gt;main&lt;/div&gt;' };      var Login = { template: '&lt;div&gt;login&lt;/div&gt;' };      // 4. 각 url에 해당하는 컴포넌트 등록      var routes = [        { path: '/main', component: Main },        { path: '/login', component: Login }      ];      // 5. 뷰 라우터 정의      var router = new VueRouter({        routes      });      // 6. 뷰 라우터를 인스턴스에 등록      var app = new Vue({        router      }).$mount('#app');    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;  $mount() APIel 속성과 동일하게 인스턴스를 화면에 붙이는 역할을 함. el 속성을 지정하지 않더라도 mount를 이용하여 화면에 강제로 인스턴스를 붙일 수 있다.뷰 라우터의 공식 문서는 모두 인스턴스 안에 el 속성을 지정하지 않고 라우터만 지정하여 생성한 다음, 생성된 인스턴스를 $mount()를 이용하는 방식으로 가이드 함이런식으로 코드를 짜게 되면, 버튼을 누름면 URL에 따라서 끝이 main인지 login인지에 따라 화면이 바뀌게 된다.그러나 여러개의 컴포넌트를 동시에 표현해야 하는 상황에서는 적합하지 않으며, 이를 위해 Nested Router와 Named View가 존재한다.3. Nested 라우터네스티드 라우터(Nested Router)는 라우터로 페이지를 이동할 때 최소 2개 이상의 컴포넌트를 화면에 나타낼 수 있다.이는 상위 컴포넌트 1개에 하위 컴포넌트 1개를 포함하는 구조로 다음과 같다.  네스티드 라우터의 구조  맨 왼쪽에는 아무것도 지정하지 않았기 때문에 User 컴포넌트만 노출  오른쪽 2개의 그림에는 post, profile에 따라 각각 Post, Profile 컴포넌트가 노출이를 코드로 나타내면 다음과 같다.&lt;html&gt;  &lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Vue Nested Router&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"app\"&gt;      &lt;!-- User 컴포넌트가 뿌려질 영역 --&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js\"&gt;&lt;/script&gt;    &lt;script src=\"https://unpkg.com/vue-router@3.0.1/dist/vue-router.js\"&gt;&lt;/script&gt;    &lt;script&gt;      // 컴포넌트 내용 정의      var User = {        template: `          &lt;div&gt;            User Component            // 하위 컴포넌트가 뿌려질 영역            &lt;router-view&gt;&lt;/router-view&gt;          &lt;/div&gt;        `      };      var UserProfile = { template: '&lt;p&gt;User Profile Component&lt;/p&gt;' };      var UserPost = { template: '&lt;p&gt;User Post Component&lt;/p&gt;' };      // 네스티드 라우팅 정의      var routes = [        {          path: '/user',          component: User,          children: [            {              path: 'posts',              component: UserPost            },            {              path: 'profile',              component: UserProfile            },          ]        }      ];      // 뷰 라우터 정의      var router = new VueRouter({        routes      });      // 뷰 인스턴스에 라우터 추가      var app = new Vue({        router      }).$mount('#app');    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;이러한 기법은 화면을 구성하는 컴포넌트의 수가 적을 때는 유용하지만, 한 번에 많은 컴포넌트를 표시하는데 한계가 있다.이를 위한 방안으로는 네임드 뷰가 존재한다.4. Named View네임드 뷰(Named View)는 특정 페이지로 이동 했을 때, 여러 개의 컴포넌트를 동시에 표시하는 라우팅 방식이다.  네스티드 라우터 vs 네임드 뷰&lt;html&gt;  &lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Vue Named View Sample&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"app\"&gt;      &lt;!-- 라우팅 영역 정의 --&gt;      &lt;router-view name=\"header\"&gt;&lt;/router-view&gt;      &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- name이 없는 경우는 디폴트 --&gt;      &lt;router-view name=\"footer\"&gt;&lt;/router-view&gt;    &lt;/div&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js\"&gt;&lt;/script&gt;    &lt;script src=\"https://unpkg.com/vue-router@3.0.1/dist/vue-router.js\"&gt;&lt;/script&gt;    &lt;script&gt;      // 컴포넌트 내용 정의      var Body = { template: '&lt;div&gt;This is Body&lt;/div&gt;' };      var Header = { template: '&lt;div&gt;This is Header&lt;/div&gt;' };      var Footer = { template: '&lt;div&gt;This is Footer&lt;/div&gt;' };      var router = new VueRouter({        routes: [          {            path: '/',            // &lt;router-view&gt;의 name 속성과 컴포넌트를 연결            components: {              default: Body,              header: Header,              footer: Footer            }          }        ]      })      var app = new Vue({        router      }).$mount('#app');    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;끝마치며이로써 간단하게 뷰에서 제공하는 라우터에 대하여 알아보았다.다음 포스팅에서는 HTTP 통신에 대해 알아보도록 하자.",
        "url": "/devlog/2020/10/28/web-8.html"
      }
      ,
    
      "devlog-2020-10-26-web-7-html": {
        "title": "[Vue] 컴포넌트",
        "subtitle":"vue.js에 대한 이해 - 3",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "vue",
        "content": "들어가기 앞서이전 포스팅에 이어 뷰의 컴포넌트의 정의, 유효범위 및 사용법에 대해 알아보도록 한다.1. 컴포넌트란?컴포넌트(Component)란 조합하여 화면을 구성할 수 있는 블록을 의미하며 다음과 같은 장점을 지닌다.  구조화하여 일괄적인 패턴으로 개발 가능  코드 재사용성이 높아짐  남의 코드를 직관적으로 이해하기 편함  컴포넌트로 구분한 화면 영역 간의 관계도2. 전역 컴포넌트 VS 지역 컴포넌트컴포넌트를 등록할 때, 전역과 지역 두 가지 방법으로 가능하다.지역(Local) 컴포넌트는 특정 인스턴스에서만 유효한 범위를, 전역(Global) 컴포넌트는 여러 인스턴스에서 공통으로 사용할 수 있다.2-1. 전역 컴포넌트전역 컴포넌트는 다음과 같이 Vue 변수를 이용하여 등록하며, .component() 함수를 호출하여 실행한다.&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Vue Component Registration&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"app\"&gt;      &lt;button&gt;컴포넌트 등록&lt;/button&gt;      &lt;my-component&gt;&lt;/my-component&gt;    &lt;/div&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js\"&gt;&lt;/script&gt;    &lt;script&gt;      Vue.component('my-component', {        template: '&lt;div&gt;전역 컴포넌트가 등록되었습니다!&lt;/div&gt;'      });      new Vue({        el: '#app'      });    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;위의 my-component 태그부분은 최종적으로 다음과 같이 변경된다.    &lt;div id=\"app\"&gt;      &lt;button&gt;컴포넌트 등록&lt;/button&gt;      &lt;!-- 치환된 모습 --&gt;      &lt;div&gt;전역 컴포넌트가 등록되었습니다!&lt;/div&gt;    &lt;/div&gt;2-2. 지역 컴포넌트지역 컴포넌트는 인스턴스에 component 속성을 추가하여 이름과 내용을 정의한다.  ...    &lt;script&gt;      var cmp = {        // 컴포넌트 내용        template: '&lt;div&gt;지역 컴포넌트가 등록되었습니다!&lt;/div&gt;'      };      new Vue({        el: '#app',        components: {          'my-local-component': cmp        }      });    &lt;/script&gt;2-3. 전역 vs 지역 컴포넌트 차이&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Vue Local and Global Components&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"app\"&gt;      &lt;h3&gt;첫 번째 인스턴스 영역&lt;/h3&gt;      &lt;my-global-component&gt;&lt;/my-global-component&gt;      &lt;my-local-component&gt;&lt;/my-local-component&gt;    &lt;/div&gt;    &lt;hr&gt;    &lt;div id=\"app2\"&gt;      &lt;h3&gt;두 번째 인스턴스 영역&lt;/h3&gt;      &lt;my-global-component&gt;&lt;/my-global-component&gt;      &lt;my-local-component&gt;&lt;/my-local-component&gt;    &lt;/div&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js\"&gt;&lt;/script&gt;    &lt;script&gt;      // 전역 컴포넌트 등록      Vue.component('my-global-component', {        template: '&lt;div&gt;전역 컴포넌트 입니다.&lt;/div&gt;'      });      // 지역 컴포넌트 내용      var cmp = {        template: '&lt;div&gt;지역 컴포넌트 입니다.&lt;/div&gt;'      };      new Vue({        el: '#app',        // 지역 컴포넌트 등록        components: {          'my-local-component': cmp        }      });      // 두 번째 인스턴스      new Vue({        el: '#app2'      });    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;위와 같은 코드에서 첫번째 인스턴스 영역에서는 전역, 지역이 모두 표기되나 두번째 인스턴스에서는 전역만 노출된다.전역 컴포넌트는 인스턴스를 새로 생성할 때마다, 인스턴스에 components 속성으로 등록할 필요 없이 사용 가능하나, 지역 컴포넌트는 새 인스턴스를 사용할 때마다 등록해줘야 한다.3. 컴포넌트 통신뷰 컴포넌트는 자체적으로 고유한 유효 범위(Scope)을 지니기 때문에 같은 웹 페이지에 존재하더라도, 데이터 공유가 불가능하다.따라서 뷰 프레임워크 자체에서 정의한 컴포넌트 데이터 전달 방법을 따라야 하는데, 가장 기본적인 방법은 상위-하위 컴포넌트 간의 데이터전달이다.기본적으로 상위 -&gt; 하위로는 props라는 특별한 속성을 전달하고, 하위 -&gt; 상위로는 이벤트만 전달이 가능하다.3-1. 상위 -&gt; 하위 데이터 전달상위 -&gt; 하위 컴포넌트로 데이터를 전달할 때는 props라는 속성을 다음과 같은 순서로 사용한다.  하위 컴포넌트 속성에 props를 정의  상위 컴포넌트의 해당하는 태그에 v-bind 속성을 추가이를 코드로 나타내면 다음과 같다.&lt;html&gt;  &lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Vue Props Sample&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"app\"&gt;      &lt;!-- 팁 : 오른쪽에서 왼쪽으로 속성을 읽으면 더 수월합니다. --&gt;      &lt;child-component v-bind:propsdata=\"message\"&gt;&lt;/child-component&gt;    &lt;/div&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js\"&gt;&lt;/script&gt;    &lt;script&gt;      Vue.component('child-component', {        props: ['propsdata'],        template: '&lt;p&gt;{ { propsdata }}&lt;/p&gt;',      });      new Vue({        el: '#app',        data: {          message: 'Hello Vue! passed from Parent Component'        }      });    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;3-2. 하위 -&gt; 상위 이벤트 전달하위 -&gt; 상위 컴포넌트의 통신은 이벤트(Event)를 발생시켜 신호를 보내는 방식으로 작동한다.이를 처리하기 위해 상위 컴포넌트는 이벤트를 기다리고 있다가 하위 컴포넌트에서 특정 이벤트가 발생하면,상위 컴포넌트에서 해당 이벤트를 수신하여 상위 컴포넌트의 메서드를 호출한다.  뷰 공식 사이트에서 이벤트 발생 사용방법에서는 하위 -&gt; 상위 컴포넌트로 데이터의 전달은 다루지 않는다고 한다.뷰의 단방향 데이터 흐름에 어긋나는 방법이기 때문인데, 복잡한 어플리케이션에서는 전달해야할 경우가 생기게 된다.이를 위한 방법이 이벤트 버스(Event Bus)이다.이벤트 발생과 수신은 $emit()과 v-on: 속성을 사용하여 구현하며, 이를 코드로 나타내면 다음과 같다.&lt;html&gt;  &lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Vue Event Emit Sample&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"app\"&gt;      &lt;child-component v-on:show-log=\"printText\"&gt;&lt;/child-component&gt;    &lt;/div&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js\"&gt;&lt;/script&gt;    &lt;script&gt;      Vue.component('child-component', {        template: '&lt;button v-on:click=\"showLog\"&gt;show&lt;/button&gt;',        methods: {          showLog: function() {            this.$emit('show-log');          }        }      });      new Vue({        el: '#app',        data: {          message: 'Hello Vue! passed from Parent Component'        },        methods: {          printText: function() {            console.log(\"received an event\");          }        }      });    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;$emit()을 호출하면 괄호안에 정의된 이벤트가 발생되며, 해당 이벤트 명을 v-on:속성에지정하고 발생시킬 메서드를 지정한다.3-3. 같은 레벨의 컴포넌트 간 통신기본적인 통신 규칙을 지키며 동레벨의 컴포넌트에게 데이터를 전달하기 위해서는, 해당 컴포넌트들의 공통 상위 컴포넌트를 통해 전달해야 한다.즉, 하위 컴포넌트1 -&gt; 공통 상위 컴포넌트 -&gt; 하위 컴포넌트2의 방식으로 전달되야 하는데, 이를 해결하기 위한 방법이 이벤트 버스이다.&lt;html&gt;  &lt;head&gt;    &lt;meta charset=\"utf-8\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;Vue Event Bus Sample&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"app\"&gt;      &lt;child-component&gt;&lt;/child-component&gt;    &lt;/div&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js\"&gt;&lt;/script&gt;    &lt;script&gt;      var eventBus = new Vue();      Vue.component('child-component', {        template: '&lt;div&gt;하위 컴포넌트 영역입니다.&lt;button v-on:click=\"showLog\"&gt;show&lt;/button&gt;&lt;/div&gt;',        methods: {          showLog: function() {            eventBus.$emit('triggerEventBus', 100);          }        }      });      var app = new Vue({        el: '#app',        created: function() {          eventBus.$on('triggerEventBus', function(value){            console.log(\"이벤트를 전달 받음. 전달 받은 값 : \", value);          });        }      });    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;위 코드는 show 버튼을 클릭했을 때, 이벤트 버스를 이용하여 상위 컴포넌트로 데이터를 전달하는 코드이며 다음과 같은 흐름으로 진행된다.  show 버튼 클릭  showLog() 실행  eventBus의 이벤트 발생  상위 컴포넌트 created()에 있는 eventBus.$on()에서 전달 받음  콘솔에 전달된 인자 값 100이 출력  위와 같이 이벤트 버스를 활용하면 props 속성을 이용하지 않고 원하는 컴포넌트 간의 데이터 교환이 가능하다.하지만 컴포넌트가 많아지면, 어디서 어디로 보내는지 관리가 되지 않는 문제점이 발생한다.이 문제를 해결하기 위해서는 Vuex라는 상태 관리 도구가 필요하다.끝마치며여태까지 뷰의 기본적인 개요 및 인스턴스와 컴포넌트에 대하여 알아보았다.다음 포스팅에서는 뷰의 라우터와 HTTP통신 방법에 대하여 알아보자.",
        "url": "/devlog/2020/10/26/web-7.html"
      }
      ,
    
      "devlog-2020-10-21-web-6-html": {
        "title": "[Vue] 인스턴스",
        "subtitle":"vue.js에 대한 이해 - 2",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "vue",
        "content": "들어가기 앞서뷰로 웹 개발을 하기 위해 필수적인 인스턴스와 컴포넌트에 대해 알아보고, 각 요소들의 필요성에 대해 알아보자.  본 글에 앞서, 크롬 익스텐션 Vue.js devtools를 설치 후, 실행하는 것을 권장합니다.  설치법은 이곳을 참조1. Hello Vue.jsindex.html 파일을 하나 생성 한 후, 다음과 같이 작성한다.&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Vue Sample&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"app\"&gt;      { { message }}    &lt;/div&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js\"&gt;&lt;/script&gt;    &lt;script&gt;      new Vue({        el: '#app',        data: {          message: 'Hello Vue.js!'        }      });    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;해당 파일을 크롬 브라우저를 통해 열게되면, 화면에 Hello Vue.js! 라는 문구가 뜨게 된다.이제 각 속성들에 대하여 알아보도록 하자.2. 뷰 인스턴스의 정의와 속성뷰에서 인스턴스(Instance)는 뷰로 화면 개발을 위해 필수적으로 생성해야 하는 기본 단위이다.  뷰 인스턴스 생성  뷰 인스턴스는 다음과 같은 형식으로 생성한다.      // 인스턴스  new Vue({     el: '#app', // el 속성     data: {       // data 속성       message: 'Hello Vue.js!'     }  });        ‘Hello Vue.js!’ 텍스트를 화면에 표시하기 위해, new Vue()를 통해 인스턴스를 생성한다.  그 후, 인스턴스 안에 el 속성으로 뷰 인스턴스가 그려질 위치를 지정하고, data 속성에 message 값을 정의하여 화면의 { {message}}와 연결한다.    뷰 인스턴스 생성자  new Vue()로 인스턴스를 생성할 때, Vue를 생성자라고 한다.3. 뷰 인스턴스 옵션 속성뷰 인스턴스 속성은 인스턴스를 생성할 때, 재정의할 data, el, template등의 속성을 포함한다.그 중, el속성은 뷰로 만든 화면이 그려지는 시작점을 의미하며, 렌더링 시 화면이 그러질 위치의 돔 요소를 지정해 주어야한다.  &lt;div id=\"app\"&gt;    { { message }}  &lt;/div&gt;  new Vue({    el: '#app',  })  #app값은 화면의 돔 요소 중, app이라는 아이디를 가진 요소를 의미위 서술한 속성 외에도, template, methods, created 등이 존재4. 뷰 인스턴스의 유효범위뷰 인스턴스를 생성하면 HTML의 특정 범위 안에서만 옵션들이 적용되어 나타나며, 이는 el 속성과 밀접한 관련이 있다.  new Vue({    el: '#app',    data: {      // 아래의 message 값이 message에 치환되어 출력      message: 'Hello Vue.js!'    }  })&lt;!-- 치환전 --&gt;  &lt;div id=\"app\"&gt;    { { message }}  &lt;/div&gt;&lt;!-- 치환 후 --&gt;  &lt;div id=\"app\"&gt;    &lt;!-- el 태그가 부착된 이 div 태그 아래 값들만 치환되는 유효범위 --&gt;    Hello Vue.js!  &lt;/div&gt;el 속성에 인스턴스가 부착되고 나면, 인스턴스에 정의한 옵션 객체의 내용이 el 속성에 지정한 화면 요소와 그 이하 레벨의 화면요소에 값이 적용되어 값이 치환 된다.5. 뷰 인스턴스 라이프 사이클인스턴스의 상태에 따라 호출할 수 있는 속성들을 라이프 사이클(life cycle) 속성이라고 한다.그리고 각 라이프 사이클 속성에서 실행되는 커스텀 로직을 라이프 사이클 훅(hook)이라고 한다.  뷰 라이프 사이클 다이어그램라이프 사이클은 크게 인스턴스 생성, 생성된 인스턴스를 화면에 부착, 인스턴스 내용의 갱신, 인스턴스의 소멸 4가지로 이루어진다.각 라이프 사이클에는 다시 2단계로 나뉘어 다음과 같은 총 8 단계로 구성된다.  beforeCreate  인스턴스가 생성되고 가장 처음으로 실행되는 단계, 속성 및 DOM에 접근이 불가  created  인스턴스가 화면에 부착되기 전 단계, data와 method에는 접근 가능하나 template 속성에 정의된 돔 요소에 접근 불가  data, methods 등의 속성이 정의되어 서버에 데이터를 요청하여 받아오는 로직을 수행하기 알맞음  beforeMount  DOM에 인스턴스를 부착하기 전 단계, render() 함수가 호출되기 직전의 로직을 추가  mounted  el 속성에서 지정한 요소에 인스턴스가 부착되고 나면 호출되는 단계  template에 접근 가능하여 화면 요소를 제어하는 로직을 수행하기 알맞음  beforeUpdate    관찰하고 있는 데이터가 변경 시, 가상DOM으로 화면을 다시 그리기 전 호출하는 단계  변경 예정 데이터의 값과 관련된 로직을 미리 넣기 알맞음  updated  데이터가 변경되고나서 가상DOM으로 화면을 다시 그리고 나면 실행되는 단계  데이터 변경 후, 화면 요소 제어와 관련된 로직을 추가하기 알맞음          이 단계에서 데이터를 변경하면 무한 루프에 빠질 수 있기 때문에 값 변경을 위해서 computed, watch 속성을 사용해야 함  따라서 데이터 값을 갱신하는 로직은 가급적 beforeUpdate에 추가하고, updated에서는 변경 데이터의 화면요소(DOM) 로직을 추가해야 함        beforeDestory  인스턴스가 파괴되기 직전 단계, 인스턴스의 데이터를 삭제하기 알맞음  destroyed  뷰 인스턴스가 파괴되고 호출되는 단계  모든 속성이 제거되고 하위 인스턴스가 모두 파괴끝마치며뷰의 인스턴스와 라이프 사이클에 대하여 알아보았다.다음 포스팅에서는 뷰 컴포넌트에 대하여 알아보도록 하자.",
        "url": "/devlog/2020/10/21/web-6.html"
      }
      ,
    
      "devlog-2020-10-21-web-5-html": {
        "title": "[Vue] Vue.js 시작",
        "subtitle":"vue.js에 대한 이해 - 1",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "vue",
        "content": "들어가기 앞서Front-End를 담당하는 프레임워크 중 3대장은 Vue, React, Angular이 있다. 그 중, 가장 최근에 나온 Vue에 대하여 알아보기 위해 포스팅을 시작한다.  본 시리즈는 다음의 교재를 바탕으로 학습에 목적을 둔 글임을 밝힙니다.          교재: Vue.js 입문      저자: 장기효      1. Vue.js란 무엇인가Vue.js는 웹 페이지 개발을 위한 프론트엔드 프레임워크이다.창시자인 Evan You는 앵귤러와 리액트의 장점을 살려 Vue를 만들었다고 한다. 2. Vue.js 장점다음은 Vue.js 장점이라고 알려진 특징이다.  배우기가 쉽다.  리액트와 앵귤러에 비해 성능이 뛰어나다.  리액트와 앵귤러의 장점을 갖고 있다.          앵귤러의 데이터 바인딩 특성과 리액트의 가상 돔 기반 렌더링 특징을 가지고 있다.      3. Vue.js의 특징Vue.js는 다음과 같이 크게 4가지 특징을 지닌다.3-1. UI 화면단 라이브러리Vue.js는 MVVM 패턴에 해당하는 화면단 라이브러리이다.  이러한 방식을 채택함으로써, 화면의 요소들을 제어하는 코드와 데이터 제어 로직을 분리하여 코드를 더 직관적으로 이해가 가능하며, 추후 유지보수가 용이하다.  MVVM 패턴이란 화면을 모델(Model) - 뷰(View) - 뷰 모델(ViewModel) 방식으로 구조화하여 개발하는 방식을 의미3-2. 컴포넌트 기반 프레임워크컴포넌트(component)란 레고 블럭과 같다. 뷰의 컴포넌트들을 잘 쌓아서 화면이 구성 가능한데, 이러한 방식의 장점은 다음과 같다.  높은 재사용성  HTML 코드에서 화면의 구조를 직관적으로 파악 가능3-3. 리액트와 앵귤러의 장점을 가진 프레임워크뷰는 앵귤러의 양방향 데이터 바인딩과 리액트의 단방향 데이터 흐름의 장점을 모두 결합한 프레임워크이다.  양방향데이터 바인딩이란, 화면에 표시되는 값과 프레임워크 모델 데이터 값이 동기화되어, 한쪽의 변경이 다른쪽에 자동 반영되는 것이며,단뱡향 데이터 흐름은 항상 상위 컴포넌트에서 하위 컴포넌트로 단방향 전달하도록 되어있는 구조를 의미3-4. 가상 돔 사용뷰는 빠른 화면 렌더링을 위해 가상 돔(Virtual DOM) 방식을 적용하여, 사용자 인터렉션이 많은 요즘 웹 화면에 적합한 동작 구조를 지닌다.  가상 돔을 사용하면, 특정 돔 요소를 추가하거나 삭제하는 변경이 일어날 때 화면 전체를 다시 그리지 않고,프레임 워크에서 정의한 방식대로 화면을 갱신하여 성능을 높임끝마치며간단하게 뷰의 특징과 장점에 대해서 알아보았지만, 백앤드 개발을 주로 하는 나에게는 잘 다가오지 않는다..역시 Hello world를 한 번 해봐야 알 것 같다. 그런 의미에서 다음 글에서는 간단한 프로젝트를 만들어 보도록 하겠다.",
        "url": "/devlog/2020/10/21/web-5.html"
      }
      ,
    
      "devlog-2020-10-19-etc-8-html": {
        "title": "[PSQL]PostgreSQL 설치 및 data 저장 위치 변경",
        "subtitle":"CentOS 7 PSQL",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "etc",
        "content": "들어가기 앞서본 문서에서는 PSQL CentOS 7 설치 및 Data directory 변경 방법에 대하여 기술한다.PSQL 설치  설치     sudo yum install postgresql94-server postgresql94-contrib sudo /usr/pgsql-9.4/bin/postgresql94-setup initdb sudo systemctl enable postgresql-9.4        기동     sudo systemctl start postgresql-9.4          PSQL 기본 설정  listen 변경     설정파일 - /var/lib/pgsql/9.4/data/postgresql.conf org #listen_address = 'localhost' change listen_address = '*'        권한 변경     설정파일 - /var/lib/pgsql/9.4/data/pg_hba.conf org local   all             all                        peer host    all             all    127.0.0.1/32        trust change local   all             all                        trust host    all             all             0.0.0.0/0            trust          PSQL DATA DIRECTORY 변경  현재 data directory 확인     sudo -iu postgres postgres=# show data_directory;        db 중지     sudo systemctl stop postgresql-9.4        db 설정 파일 수정     설정파일 - /var/lib/pgsql/9.4/data/postmaster.opts /user/pgsql-9.4/bin/postgres \"-D\" \"&lt;&lt;to directory&gt;&gt;\"        서비스 설정 파일 수정     설정파일 - /etc/lib/systemd/system/postgresql-9.4.service Environment=PGDATA=&lt;&lt;to directory&gt;&gt;        기존 데이터 복사     mv &lt;&lt;org directory&gt;&gt; &lt;&lt;to directory&gt;&gt;        서비스 재시작     systemctl daemon-reload systemctl start postgresql-9.4        현재 data directory 확인 (1번방법)",
        "url": "/devlog/2020/10/19/etc-8.html"
      }
      ,
    
      "devlog-2020-03-13-etc-7-html": {
        "title": "[Thanos]프로메테우스의 스케일링 tool",
        "subtitle":"Prometheus: 오픈소스 모니터링 tool - 3",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "etc",
        "content": "들어가기 앞서프로메테우스는 좋은 모니터링 툴이지만, 앞선 글에서 언급했듯이 클러스터링 구조를 지원하지 않기 때문에 다음과 같은 결정적인 두 가지 문제점을 지닌다.  확장성의 어려움  가용성의 어려움이 중 확장성의 문제는 디스크를 사서 붙이는 것으로 어느 정도 해결이된다. 하지만 데이터의 양이 방대해지고 많아질 경우, 이러한 방식으로 매 번 증축할 수 없고 결국 하나의 프로메테우스 인스턴스로는 감당이 되지 않는 문제가 발생한다.이러한 문제를 해결하기 위해 프로메테우스에서는 Federation이라는 방법을 권장한다. 프로메테우스 인스턴스를 여러개 만들어 Master-Slave 구로조 관리를 하여 계층적으로 관리를 하는 방법이다. 약간은 지저분하고 또 복잡해 보이지만, 위의 구조를 사용함으로써 어느정도 보완이 되었다. 하지만 여전히 이러한 구조는 단점을 지닌다.가용성의 문제가 바로 그것인데, 프로메테우스는 기본적으로 하나의 서버로 기동된다. 따라서 실행중인 서버가 다운되거나 장애 및 재시작 등의 업무로 인해 생기는 공백의 기간동안은 메트릭을 수집할 수 없다. 클러스터링 기능이 존재하지 않기 때문에 이러한 문제점을 해결하기 위해서는 다음의 그림과 같이 프로메테우스 인스턴스를 두 개 띄우고 같은 대상으로부터 메트릭을 수집해야 한다.  여전히 마음에 들지 않는다.1. Thanos란위와 같은 문제를 해결하기 위해 등장한 것이 바로 Thanos이다.타노스의 기본 구조는 위와 같다. 여러개의 프로메테우스에서 메트릭 정보를 받아 전체적인 정보를 제공해준다. 또한 수집된 메트릭을 스케일이 가능한 스토리지에 저장해서 특정 프로메테우스 인스턴스가 다운이 되더라도, 그 인스턴스가 담당하는 메트릭을 조회할 수 있도록 해준다. 2. Thanos 아키텍처타노스의 전반적인 이해를 돕기 위해 타노스의 아키텍처를 살펴본다.2-1. Thanos Side car &amp; Querier\b타노스는 프로메테우스 서버에 타노스 에이전트(Thanos Sidecar)를 설치하여 데이터를 조회할 수 있도록 한다. 프로메테우스는 수집된 메트릭 데이터를 로컬 디스크에 저장하기 때문에 타노스 에이전트는 디스크에 저장된 내용을 읽어 필요시 쿼리 엔진에게 전달한다. 이러한 구조로 이루어져 있기 때문에 사용자가 관리하고 바라보는 것은 Thanos Query 하나로 줄어들게 된다.2-2. HA 지원타노스의 HA(High Availability, 서버 이중화)는 기존과 동일하다. 프로메테우스 인스턴스를 두 개 띄워서 같은 대상을 모니터링 하는 것이다. 기존 방식에서는 프로메테우스 인스턴스를 각각 모니터링 해야하지만, 타노스는 특정 그룹의 프로메테우스 인스턴스들을 하나로 처리해서 메트릭을 보여준다. 즉, 두 인스턴스에서 수집된 메트릭을 합쳐서 보여줄 수도 있고, 중복값을 제거해주는 De-duplication 기능을 지원한다.2-3. 오래된 값 저장프로메테우스는 로컬에 데이터를 저장하기 때문에 일정 기간이 지난 데이터는 삭제된다. 따라서 기간이 오래된 데이터는 조회가 불가능하다. 이 문제는 여러 대의 프로메테우스를 모니터링하게 되므로 타노스에서도 발생하는데, 메모리와 로컬디스크의 용량 문제로 여러 프로메테우스 모니터링이 불가능하게 된다. 이를 해결하기 위해 타노스는 외부 스토리지를 사용한다.프로메테우스에서 수집된 데이터는 2시간 정도 메모리에 저장된 후, 로컬 디스크로 덤프되어 저장된다. 이 데이터를 타노스 에이전트가 수집하여 외부 스토리지에 저장한다. 외부 스토리지는 Ceph와 같은 분산형 파일 시스템 혹은 Google Cloud Storage, AWS S3와 같은 클라우드 스토리지를 사용한다.즉 쿼리 엔진에서 최근의 데이터를 조회할 때는 타노스 에이전트를 통해서 가져오고, 오래된 데이터는 Thanos Sotrage Gateway를 통해 조회한다. 이 게이트웨이는 외부 스토리지에 저장된 데이터를 Storage API를 통해 쿼리 엔진과 통신하는 역할 및 캐싱 기능을 제공한다.데이터가 많이 축적되게 되면, 오래된 데이터를 조회하는 경우 많은 양을 조회하기 때문에 성능에 문제가 발생한다. 이러한 문제를 피하기 위해 Compactor가 존재하는데, 데이터 파일을 압축하고 다운 샘플링을 한다.  다운 샘플링: 1분단위로 저장된 데이터를 10분이나 1시간 단위로 샘플링 기준을 낮춰서(해상도 낮춤) 전체 데이터 저장용량을 낮추는 방법끝마치며본 포스팅은 조대협님의 블로그 글을 참조하여 학습용으로 작성된 글임을 밝힙니다.katacoda 타노스 튜토리얼",
        "url": "/devlog/2020/03/13/etc-7.html"
      }
      ,
    
      "devlog-2020-03-13-etc-6-html": {
        "title": "[Grafana]프로메테우스 &amp; 그라파나 연동",
        "subtitle":"Prometheus: 오픈소스 모니터링 tool - 2",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "etc",
        "content": "들어가기 앞서프로메테우스가 메트릭의 정보를 가져오는 모니터링 툴이었다면, 그라파나는 가져온 메트릭 정보를 시각화 해주는 오픈소스 도구이다. 그라파나는 다음과 같은 장점들로 인해 널리 사용되고 있다.  Graphite, Prometheus, InfluxDB등 다양한 데이타베이스와 메트릭수집 시스템을 지원  하나의 대시보드에 동시에 여러 메트릭 시스템들의 지표를 표시  설치 및 사용이 쉬움  프로메테우스를 잘 지원함그라파나의 설치는 공식문서를 따라 진행하면 된다. 본 문서에서 이용한 환경은 이전 포스팅과 동일하게 katacoda에서 그라파나 듀토리얼을 사용한다.  그라파나 듀토리얼1. 그라파나 설치 및 접속  로그인 화면의 기본 ID/PW는 amdin/admin 이다.  연동되었다면, Add data source를 눌러 프로메테우스를 연결한다.  본 문서에서는 프로메테우스를 localhost:9090에 실행중이므로, 사진과 같이 정보를 입력 후 savt &amp; test 를 누른다.  Create your first dashboard를 눌러 Graph를 누르면 위와 같이 빈 그래프가 생성된다.  이때 panel title 버튼을 눌러 메트릭을 추가한다.  사진과 같이 Metrics 란에 node_cpu를 입력하여 원하는 메트릭 정보를 입력한다.  그래프에 해당 메트릭이 표시되는 것을 알 수 있다.2. 그라파나 템플릿 사용그라파나의 장점은 이미 만들어진 다양한 Template이 존재한다는 것이다. 사용자들이 다양한 템플릿을 만들어 공유하는데, 템플릿은 https://grafana.com/dashboards/22에 가서 볼 수 있다. 본 예제에서는 프로메테우스의 node_exporter에 의해 제공되는 템플릿을 import할 예정이다.  상단의 Node exporter single server를 클릭하여 Import Dashboard를 누른다.  Json 파일로 템플릿을 저장할 수도 있지만, 제공하는 공식 탬플릿 중 ID:22 대시보드의 URL을 입력한다.  성공적으로 인식되었다면, 위의 사진과 같이 창이 변경되고 prometheus란을 사진처럼 설정 후 Import 버튼을 누른다.  모든 과정이 완료되면 사진처럼 준비된 대시보드가 로딩되게 된다.끝마치며본 포스팅은 조대협님의 블로그 글을 참조하여 학습용으로 작성된 글임을 밝힙니다.",
        "url": "/devlog/2020/03/13/etc-6.html"
      }
      ,
    
      "devlog-2020-03-13-etc-5-html": {
        "title": "[Prometheus]프로메테우스 개념 구조 및 quick start",
        "subtitle":"Prometheus: 오픈소스 모니터링 tool - 1",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "etc",
        "content": "들어가기 앞서프로메테우스는 오픈 소스 기반의 모니터링 시스템이다. ELK 와 같은 로깅이 아니라, 대상 시스템으로 부터 각종 모니터링 지표를 수집하여 저장하고 검색할 수 있는 시스템이다. 구조가 간단해서 운영이 쉽고, 강력한 쿼리 기능을 가지고 있으며, 그라파나(Grafana) 를 통한 시각화를 지원한다. 무엇보다 넓은 오픈 소스 생태계를 기반으로 해서, 많은 시스템을 모니터링할 수 있는 다양한 플러그인을 가지고 있는 것이 가장 큰 장점이다. 특히 이런 간편함 때문에 특히나 쿠버네티스의 메인 모니터링 시스템으로 많이 사용되면서 요즘 특히 더 주목을 받고 있다.1. 기본 구조1-1. Metric 수집수집을 하려는 대상 시스템이 Target system이다. MySQL이나, Tomcat 또는 VM 과 같이 여러가지 자원이 모니터링 대상이 될 수 있다. 이 대상 시스템에서 메트릭을 프로메테우스로 전송하기 위해서는 Exporter 라는 것을 사용한다.1-2. pulling 방식프로메테우스가 Target System에서 메트릭을 수집하는 방식은 풀링 방식을 사용한다. 프로메테우스가 주기적으로 Exporter로 부터 메트릭 읽어와서 수집하는 방식이다. 보통 모니터링 시스템의 에이전트 들은 에이전트가 모니터링 시스템으로 메트릭을 보내는 푸쉬 방식을 사용한다. 특히 푸쉬 방식은 서비스가 오토 스켈링등으로 가변적일 경우에 유리하다. 풀링 방식의 경우 모니터링 대상이 가변적으로 변경될 경우, 모니터링 대상의 IP 주소들을 알 수 가 없기 때문에 어려운 점이 있다.이러한 문제를 해결하기 위한 방안이 서비스 디스커버리라는 방식인데, 특정 시스템이 현재 기동중인 서비스들의 목록과 IP 주소를 가지고 있으면 된다. 예를 들어 앞에서 VM들을 내부 DNS에 등록해놓고 새로운 VM이 생성될때에도 DNS에 등록을 하도록 하면, DNS에서 현재 기동중인 VM 목록을 얻어와서 그 목록의 IP들로 풀링을 하면 되는 구조이다.1-3. Service Discovery프로메테우스도 서비스 디스커버리 시스템과 통합을 하도록 되어 있다. 앞에서 언급한 DNS나, 서비스 디스커버리 전용 솔루션인 Hashicorp사의 Consul 또는 쿠버네티스를 통해서, 모니터링해야할 타겟 서비스의 목록을 가지고 올 수 있다.1-4. ExporterExporter는 모니터링 에이전트로 타겟 시스템에서 메트릭을 읽어서, 프로메테우스가 풀링을 할 수 있도록 한다. 또한, 단순히 HTTP GET으로 메트릭을 텍스트 형태로 프로메테우스에 리턴한다. 요청 당시의 데이타를 리턴하는 것일뿐, Exporter 자체는 기존값(히스토리)를 저장하는 등의 기능은 없다.1-5. Retrieval서비스 디스커버리 시스템으로 부터 모니터링 대상 목록을 받아오고, Exporter로 부터 주기적으로 그 대상으로 부터 메트릭을 수집하는 모듈이 프로메테우스내의 Retrieval 이라는 컴포넌트이다.1-6. 저장이렇게 수집된 정보는 프로메테우스 내의 메모리와 로컬 디스크에 저장된다. 뒷단에 별도의 데이타 베이스등을 사용하지 않고, 그냥 로컬 디스크에 저장하는데, 그로 인해서 설치가 매우 쉽다는 장점이 있지만 반대로 스케일링이 불가능하다는 단점을 가지고 있다.  대상 시스템이 늘어날 수록 메트릭 저장 공간이 많이 필요한데, 단순히 디스크를 늘리는 방법 밖에 없다.프로메테우스는 구조상 HA를 위한 이중화나 클러스터링등이 불가능하다. (클러스터링 대신 샤딩을 사용한다. HA는 복제가 아니라 프로메테우스를 두개를 띄워서 같은 타겟을 동시에 같이 저장 하는 방법을 사용한다. 이 문제에 대한 해결 방법은 Thanos 라는 오픈 소스를 사용하면 된다고 한다.)1-7. 서빙이렇게 저장된 메트릭은 PromQL 쿼리 언어를 이용해서 조회가 가능하고, 이를 외부 API나 프로메테우스 웹콘솔을 이용해서 서빙이 가능하다. 또한 그라파나등과 통합하여 대쉬보드등을 구성하는 것이 가능하다.이 외에도 메트릭을 수집하기 위한 gateway, 알람을 위한 Alert manager 등의 컴포넌트등이 존재한다.2. 장/단점위의 내용을 기반으로 확장한 프로메테우스의 장/단점은 다음과 같다.2-1. 장점  pull 방식의 구조를 채택함으로써, 모든 메트릭의 정보를 중앙 서버로 보내지 않아도 됨대부분의 모니터링 구조는 push인데, 각 타겟 서버에서 부하가 걸릴 경우 push 방식은 fail point가 될 가능성이 있음  Kubernetes 환경에서 설치가 간단하고, grafana와의 연동을 통한 운영이 쉽다.  다양한 metric exporter 제공Linux, Window등의 OS metric 뿐 아니라 각종 Third-party의 exporter를 제공  장기간 데이터 유지와 확인데이터 저장소가 시계열 데이터 저장소로 구성되어있어, 많은 양의 정보를 빠르게 검색 가능2-2. 단점프로메테우스는 장점이 확실한 만큼 다음과 같이 단점도 확실하다.  위의 그림처럼, 각 Region에 프로메테우스를 배치 한 뒤, 이를 Master에 Aggregate하는 방식이 프로메테우스가 공식적으로 권장하는 다중화 방식즉 Clustering과는 거리가 멈  싱글 호스트 아키텍처이기 때문에 저장용량이 부족하면 디스크 용량을 늘리는 것 밖에 방법이 없음  프로메테우스 서버가 다운되거나, 설정 변경 등을 위해서 재시작을 할 경우 그간의 metric은 유실됨  일정 풀링 주기를 기반으로 metric을 가져오기 때문에 풀링하는 순간의 스냅샷 정보만 알 수 있음스냅샷의 연속된 모음이기 때문에 근사값의 형태3. Hello Prometheus프로메테우스를 이해하기 위해 간단한 테스트를 https://www.katacoda.com/ 에서 진행하였다.3-1. 설정 파일 정의프로메테우스의 설정은 prometheus.yml 파일에 다음과 같이 정의한다.global:  scrape_interval:     15s  evaluation_interval: 15sscrape_configs:  - job_name: 'prometheus'    static_configs:      - targets: ['127.0.0.1:9090', '127.0.0.1:9100']        labels:          group: 'prometheus'  scrape_interval: 타겟시스템으로부터 메트릭을 읽어오는 주기  evaluation_interval: 읽어온 메트릭을 기반으로 alert를 보낼지 말지 판단하는 주기  scrap_configs: 데이터 수집 대상과 방법을 정의  job: 대상 그룹에서 메트릭을 수집해오는 내용을 정의위의 경우, 127.0.0.1:9090과 127.0.0.1:9100으로 부터 메트릭을 수집하도록 job이 정의앞 부분은 프로메테우스 시스템 자체의 케트릭, 두 번째는 프로메테우스가 기동괴고 있는 VM의 메트릭을 수집하도록 정의3-2. 프로메테우스 서버와 node exporter 기동설정이 끝난 후, 다음의 명령을 통해 간단하게 docker로 기동한다.$ docker run -d --net=host \\     -v /root/prometheus.yml:/etc/prometheus/prometheus.yml \\     --name prometheus-server \\     prom/prometheus프로메테우스가 기동되면 다음의 명령으로 docker를 통해 node exporter를 설치해서 기동한다.$ docker run -d \\   -v \"/proc:/host/proc\" \\   -v \"/sys:/host/sys\" \\   -v \"/:/rootfs\" \\   --net=\"host\" \\   --name=prometheus \\   quay.io/prometheus/node-exporter:v0.13.0 \\     -collector.procfs /host/proc \\     -collector.sysfs /host/sys \\     -collector.filesystem.ignored-mount-points \"^/(sys|proc|dev|host|etc)($|/)\"node exporter가 제대로 동작하는지 확인하기 위해, 다음의 명령을 통해 메트릭 정보를 얻는다.$ curl https://{프로메테우스 서버 IP}:9100/metrics3-3. 프로메테우스 Dashboard 접속프로메테우스와 exporter가 기동이 되었으면, 제대로 메트릭이 수집되는지 확인하기 위해 다음의 주소에 접속하여 대쉬보드를 확인한다.  http://{프로메테우스 서버 ip}:9090 검색 쿼리 부분에 메트릭 쿼리를 입력하면 그래프등의 형태로 볼 수 있다.끝마치며본 포스팅은 조대협님의 블로그 글을 참조하여 학습용으로 작성된 글임을 밝힙니다.",
        "url": "/devlog/2020/03/13/etc-5.html"
      }
      ,
    
      "devlog-2020-03-11-web-4-html": {
        "title": "[Oauth] Oauth2.0의 4가지 인증 방식",
        "subtitle":"oauth2.0 이해 및 구현 - 2",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "web",
        "content": "들어가기 앞서지난 글에서 oauth2.0의 기초 및 구성에 대하여 알아보았다. 이번 글에서는 실제로 다음과 같은 oauth2.0의 인증 방식에 대하여 알아볼 예정이다.  Authorization Code Grant Type  Implicit Grant Type  Resource Owner Password Credentials Grant Type  Client Credentials Grant Type1. Authorization Code Grant Type  클라이언트는 리소스 주인이 권한 서버에게 Client ID, Redirect URI, Response_type을 code로 지정하여 전달하도록 유도  인증이 된다면 code값을 돌려 받음  클라이언트는 전달 받은 code를 사용해 필요한 정보들과 함께 access token 획득 요청을 권한서버에게 보냄  획득한 access token을 사용해 리소스 서버에 사용자의 데이터를 요청2. Implicit Grant  클라이언트는 리소스 주인이 권한 서버에게 Client ID, Redirect URI, Response_type을 code로 지정하여 전달하도록 유도  인증이 된다면 token을 돌려 받음  획득한 access token이 유요한지 검증  검증에 대한 응답을 돌려줌  획득한 access token을 사용해 리소스 서버에 사용자의 데이터를 요청3. Resource Owner Password Credentials Grant  리소스 주인이 인증을 진행, 대부분 ID/PW로 자격증명을 수행  클라이언트는 전달 받은 정보를 기반으로 권한 서버에 access token 획득 요청  Access token을 돌려줌  획득한 access token을 사용해 리소스 서버에 사용자의 데이터를 요청4. Client Credentials Grant Type 방식  리소스 주인이 access token 정보를 직접 권한 서버에 요청  Access token을 돌려줌  획득한 access token을 사용해 리소스 서버에 사용자의 데이터를 요청끝마치며Oauth2.0의 인증 방식에 대하여 간략하게 알아보았다. 다음 포스팅에서는 각 방식을 직접 구현할 예정이다.",
        "url": "/devlog/2020/03/11/web-4.html"
      }
      ,
    
      "devlog-2020-03-11-etc-4-html": {
        "title": "[Mac]백 쿼트(`) 입력하는 법",
        "subtitle":"원화(₩) 대신 백 쿼트(`)입력하기",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "etc",
        "content": "(`) 입력하기맥을 사용하다보면, 한글을 타이핑하다가 (`)버튼을 누르면 원하는 grave는 나오지 않고 (₩)가 나오는 것을 볼 수 있다. Markdown 문서나 개발자들에게는 여러모로 불편한 일인데, 다음과 같은 해결법을 공유한다.기본 키 설정 파일 생성다음의 내용을 터미널에서 입력한다.# Keybindings 디렉토리 생성cd ~/Librarymkdir KeyBindings# DefaultkeyBinding.dict 파일 생성cd KeyBindingstouch DefaultkeyBinding.dict설정 파일 변경DefaultkeyBinding.dict 파일에 다음과 같은 내용을 추가한다.{    \"₩\" = (\"insertText:\", \"`\");}  맥을 재부팅하자 변경사항이 적용될 것이다.",
        "url": "/devlog/2020/03/11/etc-4.html"
      }
      ,
    
      "devlog-2020-03-11-web-3-html": {
        "title": "[Oauth] Oauth2.0의 등장배경, 역할 및 기본 정보",
        "subtitle":"oauth2.0 이해 및 구현 - 1",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "web",
        "content": "들어가기 앞서Oauth2.0의 기초에 대해 알아보고자 한다. 많은 자료가 있지만, 정확한 이해를 위해 oauth2.0의 개념부터 구현까지 직접하며 글을 남기고자 한다.  자세한 개념 설명은 다음과 같은 더 좋은 글들을 찾아보기 바란다.  생활코딩 oauth2.01. 인증 vs 인가본격적으로 oauth2.0를 살펴보기 전에 다음과 같은 용어의 의미를 짚고 가자.  인증(Authentication)인증이란, 신원을 확인 하는 행위이다.즉, 어떠한 주권을 행사할 자격이 있는지를 검증하는 단계이다.그렇기 때문에 인증을 한다고 해서, 주체에게 새로운 권한이 부여되지는 않는다.  인가(Authorization)인가란 승인이라고도 불리는데, 권한을 부여하는 행위이다.즉, 인가를 받은 대상이 새로운 자격을 얻게 되어 제한된 리소스에 접근이 가능하다.2. Oauth2.0의 등장배경권한이 각 사용자에게 부여되는 경우에는 반드시 권한 소유자에 대한 인증절차를 거치게 된다. 웹에서 이러한 가장 보편적인 방법은 ID/PW 방식으로 로그인하는 것이다. 사용자가 입력한 정보를 서버에 전송하여 인증이 성공할 경우, 쿠키에 세션 값을 저장함으로써 권한이 부여된다. 이런 방식은 한 번의 로그인으로 세션이 종료되기 전까지 제한된 기능을 수행할 수 있어, 간편하고 효율적인 방식으로 널리 사용된다. 하지만 이러한 쿠키 기반 권한 부여는 다음과 같은 단점을 지닌다.  서버에 요청이 올때마다 DB를 통해 현재 상태를 매번 확인하는 낭비가 발생한다.  모바일 앱에 적합하지 않다.  서로 다른 서비스 간에 정보를 공유하기 어렵다.이러한 단점을 해결하기 위해 IETF는 Oauth라는 프레임워크를 만들게 된다.  oauth1과 oauth2는 완전히 다른 프로토콜이며, 호환되지 않는다.3. Oauth2.0의 4가지 역할Oauth2.0의 시나리오에는 다음과 같은 4가지 역할이 존재한다.  Resource Owner  사용자로서 자신의 리소스에 대한 접근 권한을 가지고 있는 주체이다.  Client  사용자가 접근하는 서비스로서 사용자의 데이터에 대한 요청을 보내는 주체이다.  Resource Server  사용자의 데이터를 보유한 기관으로서 유효한 권한을 부여받은 client가 요청할 경우 제공한다.  Authorization Server   사용자의 데이터에 접근할 권한을 제공하는 서버이다. client의 요청에 따라 사용자에게 정보제공 동의를 받은 후, 권한을 부여한다.          규모가 작을 경우, Resource Server와 Authorization Server를 하나의 서버로 구현하기도 한다.      4. Oauth2.0의 기본 정보Oauth2.0에는 다음과 같은 세 가지의 기본 정보가 존재한다.  등록정보  서비스를 제공하는 Client는 사전에 Authorization Server에 등록해야한다.   새로운 서비스가 출시될 때마다 정보를 갱신하여 제출한다.  Redirect URI  Authorization Server는 사용자가 정보제공 동의를 하게되면 사용자를 등록된 Redirect URI로 이동시킨다.   만약 등록되지 않은 Redirect URI를 담은 요청이 들어오면 무효 처리한다.  Client ID &amp; Client Secret  새로 등록하는 Client는 Authorization Server로 부터 Client ID와 Client Secret을 발급받는다.   Client ID는 노출되어도 상관 없지만, Client Secret는 절대 노출되어서는 안된다.끝마치며Oauth2.0에 대하여 간략하게 알아보았다. 다음 포스팅에서는 oauth2.0의 4가지 인증 방식에 대하여 알아볼 예정이다.",
        "url": "/devlog/2020/03/11/web-3.html"
      }
      ,
    
      "devlog-2020-01-29-aws-7-html": {
        "title": "[AWS] IAM",
        "subtitle":"AWS 권한설정",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "aws",
        "content": "들어가기 앞서본 포스팅에서는 IAM에 대해 살펴보고, 접근 제어 및 권한 설정을 하는 방법에 대해 알아볼 예정이다.1. IAM이란?IAM은 Identity and Access Management의 약자로, AWS 리소스에 대한 접근을 안전하게 제어할 수 있는 웹 서비스이다.이 설정을 통해 리소스를 사용하도록 인증하거나, 권한을 부여할 수 있다.처음 AWS 계정을 생성하게 되면, 해당 계정에 모든 리소스에 접근할 수 있는 권한이 부여된 root 계정이 생성된다.이러한 사용자는 root 사용자라고 부르며, 로그인할 때 Email을 입력하여 로그인하게 된다.이에 AWS는 일상작업뿐 아니라 관리작업에도 이 루트사용자를 사용하는 것을 비권장한다.대신 이곳과 같은 방법으로 IAM 사용자를 생성할 때만 사용하도록 권장한다.  즉 루트 사용자는 계정 및 서비스 관기 작업에만 사용하기를 권장한다.2. IAM의 기능IAM은 다양한 기능을 제공하지만, 주로 사용하게 될 기능은 다음과 같다.  AWS 계정에 대한 공유 접근제어  권한을 세분화하여 부여  MFA(멀티 팩터 인증)  더 구체적인 사항은 AWS 공식 홈페이지를 참고하기 바란다.3. IAM 유저 생성  콘솔에 로그인하여 내 보안자격 증명을 눌러준다.  위와 같은 팝업창이 뜨게 되는데 여기서 빨간 사각형의 버튼을 클릭한다.          혹은 서비스에서 IAM을 검색하여 들어가도 된다.        사용자 추가 버튼을 눌러 새로운 IAM 사용자를 추가해준다.  생성할 사용자의 이름을 입력한다.  액세스 유형은 콘솔로 설정한다. (추후, 키를 발급받을 수 있다.)  권한 설정에서 그룹 생성을 클릭한다.그룹에 권한을 설정하고 유저를 추가하면, 관리가 편리하다.          만약 특정 유저에게서 권한을 제거하고 싶다면, 그룹에서 사용자를 제거하면 된다.        그룹 이름을 지정후, AdministratorAccess를 체크하여 관리자 권한을 해당 그룹에 부여한다.  그룹 생성을 클릭한다.  위와 같이 성공적으로 추가되었음을 확인할 수 있고, 다음 단계로 넘어간다.          다음 단계는 태그이지만, 딱히 추가할 태그가 없으므로 검토로 가도록 한다.        생성한 정보를 확인 후, 사용자 만들기를 클릭한다.  사용자들이 접속할 콘솔 주소가 표시되며, 해당 주소를 통해 IAM 유저로 로그인이 가능하다.  사용자의 액세스 키(액세스 키 ID &amp; 보안 액세스 키)를 확인하려면, 표시 버튼을 눌러 확인한다.  액세스 키를 저장하려면, .csv 다운로드 버튼을 클릭한 후 안전한 위치에 저장한다.          보안 액세스 키는 이 단계에서만 확인 및 다운로드가 가능하다.다시는 확인하거나 다운로드 할 수 없으므로 주의하자.        IAM 유저가 생성됨을 확인할 수 있다.앞으로는 IAM유저로 로그인하여 네트워크를 구성하면 된다.4. 루트계정 MFA 활성화AWS에서 제공하는 MFA는 보안을 강화하는 수단이다. AWS계정 및 개별 IAM 사용자들에 대해 AWS MFA를 활성화할 수 있다.루트계정에는 MFA를 활성화하는것이 권장되며, 현재는 토큰 기반의 가상 MfA 어플리케이션만 존재한다.  2019.02.01 이후로 SMS 문자 메세지 기반 방식은 더이상 지원되지 않는다.  좌측메뉴의 대시보드를 누른 후, 사진처럼 MFA 관리 버튼을 클릭한다.  MFA 활성화 버튼을 클릭한다.  가상 MFA 디바이스를 체크하고 계속을 클릭한다.  QR 코드 표시를 클릭하여 나오는 QR 코드를 Google OTP를 설치하여 스캔하면 MFA 코드가 생성된다.  생성된 2개의 MFA 코드를 입력하여 할당을 누른다.  성공적으로 할당시, 사진과 같이 성공했다는 표시가 되며, 루트계정 로그인은 MFA 인증을 해야한다.  루트 계정으로 로그인할 시 MFA 코드를 입력하는 화면이 뜨게되며,  Google OTP에서 코드를 입력하면 로그인할 수 있다.5. IAM 역할 부여IAM에서 제공하는 기능중 역할을 사용하면 특정 인스턴스에 제약을 걸 수 있다.이어지는 실습에서는 특정 EC2에게 S3버킷에 대한 접근 제어 역할을 부여하겠다.  좌측 메뉴에서 역할을 클릭 후, 역할 만들기를 클릭한다.  우리는 특정 EC2에게 역할을 부여할 것이므로, 사진처럼 EC2를 클릭 후 다음을 누른다.          다른 AWS 계정을 눌러 특정 계정에게 역할을 부여할 수도 있다.이런 경우, 계정 ID는 이메일 형식의 로그인ID가 아니라, 내 정보에서 볼 수 있는 12자리 숫자 ID이다.        특정 EC2에게 S3버킷에 접근할 역할을 부여할 것이므로, amazons3fullaccess를 검색 후 체크하여 다음을 클릭한다.          이어지는 태그는 건너뛰고 검토를 클릭한다.        역할의 이름을 지정하고 방금 지정한 정책이 맞는지 확인 후, 만들기를 클릭한다.  생성한 역할이 지정한 이름과 할당한 서비스를 표시함을 확인할 수 있다.  EC2를 생성할 때, 우리가 지정한 역할을 부여할 수 있음을 알 수 있다.이렇게 생성된 EC2 인스턴스는 S3외의 다른 서비스의 접근은 불가능해진다.6. 끝마치며공부하며, 내용을 정리하다 보니 문득 정책과 역할의 차이가 모호해져 찾아보게 되었다.내가 이해한 바로는 정책은 어떤 일을 할 수 있는 권한과 관련이 있고,역할은 그러한 권한들의 논리적인 집합이라는 것이다.자세한 내용은 다음의 두 링크를 참조하자.AWS 홈페이지이현수님 포스팅IAM, VPC, EC2 이 3가지는 굉장히 중요하다고 한다.꼭 잘 설정하여 좋은 환경을 구축하기를 바란다.",
        "url": "/devlog/2020/01/29/aws-7.html"
      }
      ,
    
      "devlog-2020-01-28-cicd-2-html": {
        "title": "[CI/CD] Travis CI 파이프라인 구축하기",
        "subtitle":"Jenkisn & Code Deploy로 Unity 앱 빌드 및 무중단 배포 - 2",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "devops",
        "content": "들어가기 앞서AWS 기초 시리즈에서 AWS의 구성을 살펴보았으니, 배운 것을 활용할 겸 AWS를 적극 사용하려한다.물론 AWS에서 제공하는 Code Build나 Code Pipeline까지 활용해야 적극 활용이라 할 수 있지만, CI는 Jenkins를 이용하고 CD는 Code Deploy를 이용하여 구축하겠다.  AWS Code Deploy는 AWS에서 제공하는 배포 서비스로, EC2에서 사용하는 경우 무료이다. On-premise에서 Code Deploy를 사용하는 경우는 업데이트당 0.02USD가 과금된다.1. Why Jenkins?나는 처음에 다음과 같은 이유로 Travis를 사용하여 환경을 구축하려 했다.  무료(오픈소스에 한해서)  GitHub와의 강력한 연동  추가적인 서버 필요 없음하지만 다음과 같은 결정적인 단점이 존재하였고, 이는 굉장히 치명적이었다.  래퍼런스 문서가 없음아무것도 아닌 문제처럼 보일 수 있으나, 정말 심각하게 내가 원하는 방향에 관련된 문서가 없었다.Jenkins는 다양한 플러그인과 이를 Script로 표현하여 설정하는 다양한 문서들이 존재하는 반면에, Travis는 Unity를 배포하는 방법에 관련된 문서가 없었다.그나마 존재하는 문서들은 Mac 환경에서 진행된 개발이 전부였고, Window와 Ubuntu에서 진행하는 내게 이는 상당한 부담으로 다가왔다.  아무것도 안하고 이 일만 하면 모를까 회사일과 병행하며 삽질을 하기에는 무리였다..결국 하루의 삽질과 고민 끝에 Jenkins로 노선을 변경했다. AWS를 공부하고 배웠으니 이렇게 된김에 free tier가 유지되는 동안에 적극 활용해보자는 다짐과 함께.  만약, AWS CI/CD에 관심이 있다면 AWS Code Build &amp; Code Pipeline을 사용하는 것을 추천한다.AWS도 훌륭한 빌드 툴과 전체적인 파이프라인을 관리하는 툴을 제공한다.하지만 Code Build는 빌드 시간으로, Code Pipeline은 활성화된 파이프라인 개수로 과금한다.물론 프리티어를 제공하지만, 장기적으로 생각을 잘해서 선택하기를 바란다.여기 훌륭한 자료가 있어 링크를 공유한다.2. 전체 구성내가 구성한  CI/CD의 전체 구성도는 위와 같은데, Jenkins를 이용하여 CI를 구축하고 Code Deploy를 이용해 CD를 구축하기로 했다.둘 사이의 연결은 Jenkins에서 제공하는 Code Deploy Pulgin을 사용할 계획이다.이러한 파이프 라인을 통해 S3에 빌드 결과물을 저장하고, AWS Code Deploy에서 해당 결과물을 가지고 우리가 가동할 APP 서버에 배포하는 방식이다.여기서 Jenkins Build Server와 배포를 위한 앱 서버는 모두 EC2를 사용할 것이며, VPC와 IAM 설정을 통해 해나갈 것이다.App은 Unity를 사용하여 만들고 구글 플레이스토어에 배포할 계획이며, 하나의 App 서버를 두고 가동할 예정이다.  배포하는 방식은 이 글을 작성하는 시점에서 아직 다른 개발자와 협의가 이루어지지 않아 미완성으로 남겨놓았다.추후, 논의되어 합의가 이루어지면 업데이트할 예정이다.",
        "url": "/devlog/2020/01/28/cicd-2.html"
      }
      ,
    
      "devlog-2020-01-16-aws-6-html": {
        "title": "[AWS] Private Subnet, NAT, ELB, Elastic IP, S3 (실습)",
        "subtitle":"AWS 기초 - 6",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "aws",
        "content": "들어가기 앞서본 포스팅에서는 다음과 같은 구성요소들을 살펴볼 예정이다.  Private Subnet을 구성하는 방법  Bastion Host를 통해 Private Subnet에 접근하는 방법  NAT  ELB  Elastic IP  S31. Private Subnet 구성 및 접근우선 구성하는 방법은 간단하다. 그냥 라우팅 테이블을 하나 만들고,인터넷 게이트웨이를 설정하지 않으면 그만이다.접근 또한 마찬가지로 어렵지 않은데, 우선 Bastion Host로 접속 후다시 내부적으로 접속을 진행하면된다.  대략적으로 그려보면 다음과 같다.외부 접속 –&gt; Bastion Host –&gt; Private Subnet약간의 문제가 있다하면 ssh 접속을 위한 키 페어 관리인데,내부 private subnet에 접속하기 위해 Bastion Host는 각 서브넷의키 페어를 가지고 있어야 한다.이런 경우, 관리자들이 적절한 보안 규칙을 세워 키 페어 관리를 해야한다.그렇지 않으면 Bastion Host에 접속하여 모든 private subnet에 접근이 가능해,그냥 모두 public으로 만든 것이랑 별반 다름이 없을 수 있기 때문이다.2. NAT(Network Access Translation)NAT는 설명했듯이, 인터넷 게이트웨이를 통해 outbound만 허용한다.이는 AWS의 정책으로 외부에서 접근이 불가하다.설정하는 방법은 다음과 같이 두 가지 방법이 존재한다.  인스턴스를 생성하여 설정  게이트웨이로 생성하여 설정또한 Elastic IP를 설정하며 유료 서비스다.  Elastic IP를 사용하는 경우, 서버 재부팅 시에도 IP가 고정된다.3. ELB(Elastic Load Balancer)생성은 서비스에서 EC2를 검색 후, 좌측 메뉴에서 로드밸런서에서 할 수 있다.생성 시, 3개 중 하나를 고르라고 하는데 기본적으로 Classic을 선택하면 된다.그 후 대략 다음의 단계에 따라서 구성한다.  본인의 VPC와 서브넷을 잘 선택  보안그룹 할당: 기존그룹에서 생성한 그룹 선택  EC2 인스턴스 추가: 이 단계에서 우리의 public 인스턴스를 추가한다.위와 같은 설정의 이점은 EC2에 ELB를 거치치 않고 들어오는 경우를 막는 것이다.즉, prviate EC2에 웹 프로토콜로 접속 시, ELB를 통해서 접근해야 한다. 이를 통해 다음과 같은 흐름으로 Inbound를 설정할 수 있다.  ACL –&gt; ELB –&gt; EC2ELB와 Bastion Host를 제외한 나머지 subnet은 private 설정을 해야한다.또한 EC2는 다음과 같은 3가지 방법으로 구분이 되는데,  private IP  Public IP + address  Unique ID(Instance ID)이 중, 3번째 방법인 유니크한 ID가 ELB에 제공되어야 밸런싱을 잘 해준다고 한다.4. Elastic IP(탄력적 IP)AWS에서 Elastic IP를 가지고 있지 않은 리소스의 경우,재부팅 시 IP의 변경이 일어난다.이러한 현상을 막기 위해 Elastic IP를 설정하면 IP가 고정된다.이러한 서비스는 Floating되어 있다고 한다.무슨 말이나면, 특정 객체에 묶여있는 것이 아니라상황에 따라 이리 붙었다 저리 붙었다가 가능하다는 뜻이다.이러한 특징 때문에 특정 서비스가 다운되면 Elastic IP를다른쪽으로 붙여서 트래픽을 그 쪽으로 유도해 장애에 대처할 수 있게 된다.  End-User에게 보여지는 IP는 고정된 IP이기 때문이다.혹은 서비스를 이관할 때도 이 서비스를 이용하여유동적으로 트래픽을 처리할 수 있게 된다.5. S3(Simple Storage Service)S3는 VPC 외부에 존재하는 서비스로써 Bucket 단위로 구분하며,AWS에서 S3 서비스를 검색하여 시작할 수 있으며 다음과 같은 특징이 있다.      S3는 내부적으로 2군데 더 미러링을 한다.현재 내 region에 1개 + 가장 가까운 region에 1개에 구성함으로써,어떤식으로 장애가 나더라도 대응 할 수 있는 구조이다.        S3는 외부에 보여지지 않으므로, 버킷레벨로 권한을 설정하거나파일레벨로 권한을 설정할 수 있다.        S3는 스토리지 서비스 이므로, DB와의 연동은 안된다.즉 S3에는 Static Data만 저장할 수 있다.이러한 특징으로 인해, 서버사이드 언어를 저장하고 돌려도 작동하지 않는다.        S3는 AZ 밖에 존재하게 되므로,VPC 안에 있는 객체들과의 통신은 과금을 유발하게 된다.이 문제를 피하기 위해, S3에서 인증토큰을 이용하여 허용된 REST API만 받아주면 된다고 한다.  6. 끝마치며AWS에 대해서 배워볼까? 로 시작했던 시리즈의 포스팅이 끝났다.단순하고 짧게 쓰려고 했지만, 쓰다보니 점점 길어지게 되었다.AWS는 늘 t2.micro 인스턴스 하나만 띡 만들어서 대충 써봤던게 전부였는데,이번 기회로 새로운 눈이 뜨여지게 된 것 같다.배웠으니 앞으로 어딘가에 적용하기를 기대하고,누군가에게 이 글이 도움이 되었길 바라며 포스팅을 마친다.",
        "url": "/devlog/2020/01/16/aws-6.html"
      }
      ,
    
      "devlog-2020-01-16-aws-5-html": {
        "title": "[AWS] EC2 인스턴스(실습)",
        "subtitle":"AWS 기초 - 5",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "aws",
        "content": "들어가기 앞서이전 포스팅에서는 실제 인스턴스를 생성하기 전 기본적인 구성을 끝마쳤다.본 편에서는 다음의 요소를 구성하고 설정할 예정이다.  EC21. 키 페어 생성  인스턴스 생성하기 전, 인증에 사용되는 키 페어를 만들기 위해사진처럼 EC2를 검색하여 이동한다.  좌측의 메뉴에서 키 페어를 클릭 후, 키 페어 생성을 눌러 생성한다.  규칙에 따라 사진처럼 keypair-apne2-dev-public으로 이름을 지정 후,생성을 누른다.  사진처럼 키 페어가 생성됨이 확인되고, 다운로드가 시작이 된다.          이때 생성되는 키 페어는 단 한번만 다운로드가 가능하므로, 주의하자잃어버릴 시, 키 페어를 새로 생성해야 한다.        하나의 키 페어로 모든 인스턴스에 적용하는 것은 매우 위험하다.따라서 적절한 보안 규칙을 세워 키 페어를 관리해야한다.2. 인스턴스(EC2) 생성  좌측의 메뉴에서 인스턴스를 클릭 후, 생성을 클릭한다.2-1. AMI 선택  사진처럼 맨 위의 AMI를 선택한다.          선택된 이미지는 아마존에서 지원하는 기본 이미지이다.또한, 사진 좌측의 AWS Marketplace나 커뮤티니 AMI등에서여러가지 옵션으로 준비된 이미지를 선택할 수 있다.      2-2. 인스턴스 유형 선택  우리는 프리티어를 사용하므로, 사진처럼 녹색으로 표시된 t2.micro를 선택한다.          여기서 유형 앞에 t가 붙는 것은 개발용이거나 테스트용이라는 의미이다.또한 t뒤에 숫자는 세대를 의미하며 클수록 최신이다.        선택을 하였다면 다음: 인스턴스 세부 정보 구성을 눌러 진행한다.          여기서 검토 및 시작을 누르게되면 우리가 원하는 VPC구성을 진행할 수 없다.그러므로 주의해서 진행하도록 하자.      2-3. 인스턴스 구성  사진의 첫 번째 빨간 사각형에서 다음과 같은 설정을 진행한다.          네트워크는 기본 VPC로 선택이 되어있는데, 우리가 만든 VPC를 선택한다.      서브넷은 우리가 인스턴스를 생성할 서브넷을 지정해준다.      퍼블릭 IP 자동할당은 활성화를 해준다.                  외부와 통신하는 서비스는 활성화를 해줘야한다.  서비스를 재실행시, Public IP는 고정되지만, Private IP는 변경되기 때문이다.                      두 번째 사각형에서는 다음과 같은 설정을 진행한다.          종료 방지 기능 활성화는 체크하여준다.      모니터링은 활성화하는 것을 권장한다.        위의 설정이 되었다면, 다음을 눌러 진행한다.2-4. 스토리지 &amp; 추가  딱히 수정할 사항은 없으므로 다음을 눌러 진행한다.2-5. 보안 그룹 구성  보안그룹은 이름을 참조하여 기존에 생성한 그룹을 선택한다.하단에 표시되는 프로토콜 규칙을 확인 후, 검토 및 시작을 누른다.2-6. 검토  화면에 표시되는 정보들을 확인하여 제대로 설정되었는지 검토 후, 시작하기를 누르면사진과 같은 키 페어 선택화면이 표시된다.  이때 기존 키 페어를 선택하고, 체크박스에 체크하여 시작한다.2-7. 확인  제대로 설정이 되었는지 확인하기 위해 빨간 사각형들을 살펴본다.          인스턴스 상태: 생성 직후는 노란색으로 Pending이라 표시되지만 당황하지 말자.  아직 준비 중이라는 뜻이며, 곧 사진처럼 초록색으로 running이 표시될 것이다.      인스턴스 ID, 상태, 유형을 확인한다.      가용영역과 보안그룹이 제대로 설정되었는지 확인한다.      키 페어 이름을 확인한다.      퍼블릭 DNS와 퍼블릭 IP를 확인한다.  추후 ssh로 접속할 때 , 이 주소를 사용할 것인다.      VPC가 제대로 할당되었는지 확인한다.      3. 인스턴스(EC2) SSH 접속  새로 생성한 인스턴스에 접속하기 위해 사진처럼 연결을 눌러 가이드를 확인한다.3-1. Mac &amp; Linux  다운로드 받은 키 페어가 있는 디렉토리로 이동한다.     $ cd (디렉토리위치)        키 페어 파일의 권한을 다음 명령어로 변경한다.     $ chmod 400 keypair-apne2-dev-public.pem        ssh를 이용해 다음 명령으로 접속한다.     // 가이드에서 제공하는 DNS로 접속하는 방법 // 사진에서 제공하는 명령어를 그대로 사용하면 된다.   $ ssh -i \"keypair-apne2-dev-public.pem\" ec2-user@ec2-1X-XXX-XXX-XXX.ap-northeast-2.compute.amazonaws.com // 퍼블릭 IP를 이용해 접속하는 방법 $ ssh -i \"keypair-apne2-dev-public.pem\" ec2-user@(본인의 퍼블릭 IP)        성공적으로 접속되었다면, 다음과 같은 접속 허용 여부를 묻는 문구가 등장한다.(에러 발생시 6번으로)     The authenticity of host '1X.XXX.XXX.XXX (1X.XXX.XXX.XXX)' can't be established. ECDSA key fingerprint is SHA256:+Kxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx. Are you sure you want to continue connecting (yes/no)? yes        터미널 창에 yes를 입력해주면 다음과 같은 성공화면이 뜨게 된다.             __|  __|_  )         _|  (     /   Amazon Linux 2 AMI         ___|\\___|___| https://aws.amazon.com/amazon-linux-2/ 2 package(s) needed for security, out of 13 available Run \"sudo yum update\" to apply all updates. [ec2-user@ip-10-0-1-97 ~]$        만약 위 과정중 다음과 같은 에러를 마주할 때 몇 가지 대안을 소개한다.     ssh: connect to host 1X.XXX.XXX.XXX port 22: Connection timed out              ssh용 22번 포트가 열려있는지 확인      VPC - 라우팅 테이블 설정에서 인터넷 게이트웨이의 설정 확인      VPC - 보안그룹 설정에서 인바운드 규칙을 클릭하여 규칙 편집을 눌러 소스에서 내 ip를 눌러 갱신                  핫스팟 환경등 접속한 IP가 달라질 경우, 보안그룹의 설정을 갱신해야한다.                            그래도 안 될 경우, 이전 포스팅을 참고하여 차분히 하나씩 되짚어 보자.      3-2. Window  윈도우의 경우 여기를 확인하여 진행한다.  Putty를 설치한다.  Puttygen을 이용하여 다운로드 받은 .pem 파일을 .ppk 파일로 변환한다.  Host Name에 사진의 빨간 사각형의 정보를 붙여넣기 한다.    Connection(연결) - SSH - Auth를 클릭하여 변경한 .ppk파일을 넣어준다.    Open을 눌러 접속을 진행하면 mac &amp; linux의 경우와 동일하게 접속에 성공한다.  만약 에러가 발생하거나, 접속이 안된다면, 위의 mac &amp; linux 6번을 참조한다.이로써 VPC를 하나 생성하고, 각종 설정들을 한 뒤 실제 인스턴스 EC2를 만들어 보았다.생성한 EC2 인스턴스는 Bastion Host 역할을 하는 인스턴스로써,VPC 내부의 Private 서브넷들을 관리하는 역할을 한다.4. Public subnet을 통한 Apache 서버 구축Bastion Host도 생성하였으니, 이번에는 간단한 웹 서버 역할을 하는 인스턴스를 생성한다.동일한 방식으로 다음 조건의 서브넷과 인스턴스를 하나 더 생성한다.  VPC: 동일  Subnet          이름: subnet-apne2c-dev-web        Routing Table          이름: rt-apne2-dev-web      인터넷 게이트웨이: 기존 것과 동일        Security Group          이름: sg_apne2_dev_web        EC2(web server instance)          이름: ec2-apne2c-dev-web      키 페어: 기존 것과 동일                  실제 개발을 진행할 때는 규칙을 정하여 다른 키 페어로 하자.                    성공적으로 생성하였다면, 새로 생성한 인스턴스에 ssh 접속을 하여 다음 명령을 실행한다.$ sudo yum update$ sudo yum install httpd$ sudo systemctl start httpd$ curl localhost  sudo yum update 명령어를 사용하면 꽤 시간이 걸리는데 당황하지말고 그대로 두자.다음과 같은 화면이 나오면 정상 실행이 된 것이다.끝마치며이로써 VPC 구성부터 시작해 인스턴스의 구성까지 길었던 과정이 끝났다.간단하게 Bastion Host와 Web Server를 구축하여 ssh 접속까지 해보았다.실습에서 전부 다루지 못했던 부분은 다음과 같은데,이어지는 포스팅에서 추가 설명으로 대체하겠다.  Private Subnet을 구성하는 방법  Bastion Host를 통해 Private Subnet에 접근하는 방법  NAT  ELB  Elastic IP  S3",
        "url": "/devlog/2020/01/16/aws-5.html"
      }
      ,
    
      "devlog-2020-01-15-aws-4-html": {
        "title": "[AWS] 서브넷, 라우팅 테이블, 보안그룹, 인터넷 게이트웨이(실습)",
        "subtitle":"AWS 기초 - 4",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "aws",
        "content": "들어가기 앞서이전 포스팅에 이어서 AWS에서 VPC를 구성 후,다음의 구성 요소들을 생성하거나 설정하는 방법에 대해 포스팅할 예정이다.  Internet Gateway  Subnet  ACL  Security Group  Routing Table1. 인터넷 게이트웨이 생성 및 설정  좌측의 인터넷 게이트웨이 생성 버튼을 눌러기본 인터넷 게이트 웨이는 두고 생성을 진행한다.  생성하는 인터넷 게이트웨이는 Naming Rule을 따라 사진처럼 명명한다.  성공적으로 생성하게되면, 사진처럼 우리가 지정한 ID의 정보를 보여주며 상태는 detached가 된다.  이때, 마우스 우클릭을 하여 VCP에 연결을 누른다.  우리가 생성한 VPC를 클릭한 후 연결을 누른다.  다시 상태를 확인해 보면, attached로 변경되었음을 확인할 수 있다.2. 서브넷 생성 및 설정  마찬가지 방법으로 서브넷을 클릭 후,기본 VPC에 할당된 3개의 서브넷은 그대로 두고 서브넷 생성을 눌러준다.      이름은 규칙에 따라 subnet-apne2-dev-ssh라 입력한다.추후, 이 서브넷은 ssh로 접속하는 bastion으로 사용할 것이다.        VPC는 드롭박스를 클릭하면 사진처럼 뜨게 되는데,그 중 전 포스팅에서 만든 VPC를 클릭해 주면된다.        CIDR 블록은 VPC CIDR 블록 범위 내에서 생성하면 된다.VPC: 10.0.0.0/16서브넷: 10.0.1.0./24같은 방식으로 VPC내부에 존재하도록 지정하며,3번째 숫자가 적어질수록 security가 높아지게 cidr블록을 설정한다.          현재 사진에서는 편의상 1로 지정했지만, 실제로 생성할 때는 다음같은 나름의 규칙을 적용하자.  10.0.1.0/16 ~10.0.99.0/16 : 내부 통신10.0.100.0/16 ~10.0.199.0/16: 외부 통신같이 설정하여, IP만 보고도 security 정도를 알 수 있도록 한다.        성공적으로 생성하였다면, 사진의 빨간 사각형처럼 우리가 명명한 이름으로 등록되며,우리가 생성한 VPC에 할당되었음을 확인할 수 있다.3. ACL 확인  서브넷까지 생성한 후, 좌측 메뉴에서 ACL을 클릭하면 사진과 같이 새로 추가 되었음이 확인된다.빨간 사각형 부분을 보면, 우리가 생성한 서브넷과 VPC에 적용됨을 알 수 있다.          ACL 설정은 변경할 것도, 추가할 것도 없으므로 확인만 하자.      4. 보안그룹 생성 및 설정  좌측 메뉴에서 보안그룹을 클릭하면, 사진처럼 2가지가 존재한다.하나는 기본 VPC용, 다른 하나는 우리가 만든 VPC용이다.          우리는 서브넷별로 다른 보안그룹을 할당할 것이므로 새로 생성을 하자.        사진처럼 규칙에 따라 sg_apne2_dev_ssh로 이름을 작성한다.          이때 이름에 하이픈’-‘이 존재하면 생성이 되지 않으므로 주의하자.(이유는 모르겠다.. 연산자라 그런지도)여태는 다 하이픈을 사용했으나.. 이번에만 언더바’_‘를 사용하도록 한다.        설명에는 본인이 알아볼 수 있도록 작성하면 된다.          위와 비슷한 이유로 설명에 한글이 들어가면 안된다고 발광을 하니 주의하자.사실 설명 없이도 한 눈에 알아볼 수 있는 이름이 중요하다.        마지막으로 VPC는 우리가 생성한 VPC를 선택하여 준다.      성공적으로 생성했다면, 사진처럼 우리가 정한 이름으로 생성한 VPC에알맞은 설명으로 생성됨이 확인된다.        이때, 방금 작성한 보안그룹을 클릭 후 사진처럼 인바운드 규칙을 누른 후,규칙 편집을 클릭한다.    규칙 추가를 눌러 사진처럼 HTTP와 SSH를 추가해준다.  이때 소스는 특별한 경우가 아니면 내 IP로 지정한다.(혹은 직접 지정하여 선택할 수도 있다.)          위치 무관으로 지정하는 순간 엄청난 공격을 받게 될 것이다.실제 내 지인 또한 이 설정을 하지 않아 과금된 사례가 있었다.이러한 경우 AWS에 문의하면 로그를 확인하고, 과금을 취소해준다.        규칙을 추가한다면, 사진처럼 두 가지 프로토콜에 대한 인바운드 규칙이 생긴다.5. 라우팅 테이블 생성 및 설정  좌측 메뉴에서 라우팅 테이블을 클릭한 후, 라우팅 테이블 생성을 클릭한다.  규칙에 따라 rt-apne2-dev-ssh 이름을 선택 후,우리가 생성한 VPC를 선택하여 생성한다.  생성한 라우팅 테이블을 선택하고, 서브넷 연결을 누르고 서브넷 연결 편집을 클릭한다.  목록에서 우리가 만든 서브넷을 선택 후, 저장을 누른다.  명시적으로 우리가 만든 서브넷과 연결되었다는 정보를 확인할 수 있고,하단에도 정보가 노출된다.  다음으로 라우팅의 라우팅 편집을 눌러준다.  라우팅 추가를 누른 후, 왼쪽 대상에는 0.0.0.0/0을 입력하고, 오른쪽 대상에는 Internet Gateway를 눌러준다.그 후 왼쪽 검은 사각형처럼 정보가 노출되고, 우리가 만든 인터넷 게이트웨이를 클릭하고 저장한다.  등록 후, 사진처럼 연결한 인터넷 게이트웨이가 표시된다.  라우팅 테이블의 인터넷 게이트웨이 포함 유무로 public과 private로 구분한다.          특정 서브넷을 라우팅 테이블에 추가하여 인터넷 게이트웨이를 붙히지 않으면private이 되는 것이다.        이로써 외부로 인터넷 게이트웨이를 통하여 통신할 준비가 완료 되었다.끝마치며이번 포스팅을 통해 Internet Gateway, Subnet, ACL,Security Group, Routing Table등을 생성하고 설정하였다.어이지는 포스팅에서는 EC2 인스턴스를 생성하고,VPC내부에 구성을 해보도록 하겠다.",
        "url": "/devlog/2020/01/15/aws-4.html"
      }
      ,
    
      "devlog-2020-01-15-aws-3-html": {
        "title": "[AWS] VPC 만들어보기(실습)",
        "subtitle":"AWS 기초 - 3",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "aws",
        "content": "들어가기 앞서이번 포스팅은 aws에서 VPC를 구축해보는 실습(?)에 관련된 포스팅이다.깊게 들어가지는 않고 간단하게 VPC를 구성하는 방법을 써 볼 예정이다.  앞으로 이어질 모든 실습 내용에서 이름 만큼은 직관적이고 확실하게 지어주자이름만 보고도, 해당 객체가 어떤 일을 수행하는지 알 수 있어야 실수를 방지한다.진행되는 모든 Naming Rule은 다음을 따른다.  Object 이름 / Region-code / AZ-code / 서비스 약칭(dev, stg, prod)본 예제에서는 Single AZ만을 사용하므로, 중간 AZ-code가 생략될 예정이다.  마지막으로, 모든 사진은 클릭 시, 확대기능을 제공한다.1. AWS 계정 생성다음의 링크로 접속하여 aws 홈페이지에 들어가보자.https://aws.amazon.com/ko/우측 상단에 aws 계정생성 버튼을 눌러 가입을 진행하면 된다.  가입할 때, 신용카드 정보를 입력을 하게 되는데 갑자기 결제가 되었다고 놀라지 말자.aws에서 결제가능한 카드인지 확인하기 위해 1$ 정도를 결제했다가 취소하는 것이다.2. 콘솔 로그인  우측 상단의 AWS Management Console을 클릭하여 로그인을 진행하자.  지역은 서울로 선택한다. 3. VPC 생성  서비스에서 VPC를 검색후 클릭한다.  로그인에 성공하면 AWS Management Console 화면이 나타나고, VPC를 검색하여 클릭한다.  기본 VPC가 1개 있음을 볼 수 있고, 해당 VCP에 관한 정보가 하단에 공개된다.이제 좌측 상단의 VPC 생성을 클릭하여 새로운 VPC를 만든다.      VPC를 생성할 때는, 앞서 설명한 Naming Rule을 따라 vpc-apne2-dev-test로 작성한다.CIDR블록은 특별한 경우가 아니면, 가이드대로 10.0.0.0/16으로 한다.        2016년 6월 1일부터 App Store에 배포되는 모든 앱은 IPv6 네트워크를 지원해야 한다. IPv6가 지원이 안 될 경우 배포가 안된다고 하니, 필요시 체크를 한다.    방금 우리가 작성한 이름을 가진 이름으로 VPC가 하나 생성되었음을 확인 할 수 있다.  마지막으로 방금 생성한 VPC를 우클릭 후, 사진처럼 DNS 호스트 이름 편집을 눌러준다.  기본 값은 비활성화지만, DNS 호스트 이름을 활성화하여 이름을 주도록 한다.여기까지 진행 함으로써, 기본적인 VPC구성은 완료되었다.다음으로 구성된 VPC에 대해 기본요소들을 살펴보자.4. 기본구성 살펴보기4-1. 서브넷  좌측에서 서브넷을 클릭하면, 사진처럼 기본적으로 구성되어있는 총 3개의 서브넷이 확인 가능하다.이때 각 서브넷은 서울 지역에 존재하는 AZ3개(a,b,c)에 하나씩 꾸려진 모습이다.          이 서브넷은 우리가 구성한 VPC가 아니라 기본 VPC에 존재하는 것으로 수정하지 말자.아직 우리는 어떠한 서브넷도 생성하지 않았다.      4-2. 라우팅 테이블  다음으로 라우팅 테이블을 클릭하면,사진에서 보이는 바와 같이 방금 생성한 VPC에 할당된 라우팅 테이블이 생성되었음을 알 수 있다.(사진속 빨간 사각형 안에 우리가 정한 이름으로된 VPC에 할당되어있다.)앞으로는 이 VPC의 라우팅 테이블에 규칙을 추가하며 각종 네트워크 규칙을 설정할 것이다.4-3. 인터넷 게이트웨이  인터넷 게이트웨이 또한 아직 생성된 것이 없어 기본 VPC에 부착된것만 보인다.인터넷 게이트웨이는 기본적으로 VPC 내부 요소들이 외부와 통신하는 징검다리 역할을 한다.          이 인터넷 게이트웨이를 생성하여 우리가 생성한 VPC에 붙여줘야 비로소 통신이 가능해지는 것이다.다음 글에서는 이러한 게이트웨이 생성 및 설정법을 다룰 것이다.      4-4. ACL  ACL을 눌러보면 사진처럼 우리가 생성한 VPC에 할당된 ACL을 확인할 수 있다.          아직은 어떠한 서브넷을 생성하지 않아, 연결된 서브넷이 없음이 확인된다.주로 ACL의 설정은 건드리지 않으며, 더 세밀한 설정이 되는 보안그룹의 설정을 변경한다.      4-5. 보안그룹  보안그룹을 확인해보면, 사진의 빨간 사각형 부분에 방금 만든 VPC ID로 설정되었음이 확인된다.          이 보안그룹의 인바운드 설정을 변경하여 앞으로 진행할 것이다.      끝마치며여태 진행한 과정을 통해 VPC를 하나 설정하고 기본요소들에 대하여 살펴보았다.이는 서울 Region 내에 나만의 IDC가 하나 생긴것과 마찬가지이다.다음 포스팅에서는 각 기본요소들을 설정하는 방법 및 서브넷 &amp; 인스턴스 생성과실제로 우리가 생성한 서브넷의 인스턴스에 접속하는 방법을 설명하겠다.",
        "url": "/devlog/2020/01/15/aws-3.html"
      }
      ,
    
      "devlog-2020-01-10-aws-2-html": {
        "title": "[AWS] Region, AZ, VPC, Subnet등 구성",
        "subtitle":"AWS 기초 - 2",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "aws",
        "content": "들어가기 앞서기초적인 내용을 들어가기 전에 여담으로 aws 사용에 대한 이야기를 잠깐 하고 가겠다.퍼블릭 클라우드가 그러하듯이, aws 또한 모든것이 가상화 되어있다.이 말은 내가 신경쓰고 관리해야할 것이 전혀 없다는 말이고 모든 것을 aws가 알아서 해주는 것이다.하지만 이러한 이유로 하드웨어적 장애가 생겼을 때, 반대로 내가 할 수 있는 것은 전혀 없다.무슨 말이냐면, 하드웨어적 결함으로 어떤 에러가 발생하였을 때그게 내 문제인지, aws의 문제인지 알지 못할 수도 있다는 의미이다.생각보다 이러한 이유가 굉장히 스트레스 받는 일이 된다고 우리팀의 시니어분께서 말씀해 주셨다.  실제로 어떤 기업의 세미나에서 aws 기반 서비스를 개발하던 중, 이런 장애를 만나서 고생한 이야기를 들었다.장애의 원인이 본인들의 문제인지, aws의 결함인지 알지 못하여 문의로 해결을 받기까지 고생한 이야기인데,알 수 없는 에러와 싸우며 몇날 몇일을 고생했다고 하셨다..  하지만 이런 단점에 비해 얻는 장점이 월등히 많으므로 전세계가 aws에 열광하는 것이 아닐까각설하고 본격적으로 aws의 기초 구성에 대해 알아보도록 하자.AWS Public Cloud의 구성  출처: https://blog.leedoing.com/46AWS의 기본적인 구성요소의 단위는 다음과 같다.  region  AZ(Availability Zone)  VPC(Virtual Private Cloud)1. region구성요소 중 가장 큰 단위이며, 논리적인 단계이다.2. AZ(Availability Zone)실제 IDC 단위로써, aws 정책에 따라 하나의 region안에는 반드시 2개 이상의 AZ가 존재한다고 한다.(그림에서도 2개의 AZ가 존재한다.)시스템을 구성할 때 single AZ로 할 것인지, multi AZ로 할 것인지는 사용자의 선택사항이다.  multi AZ로 구성하여 data들을 이원화하여 안전하게 보관하는 것도 하나의 방법이고,Elastic Load Balancer를 통해 각각의 AZ가 다른 일을 수행하게 하는 것도 하나의 방법이다.3. VPC(Virtual Private Cloud)AZ 밑의 단위로써, 논리적인 구조로 하나의 IDC 처럼 동작한다.  약간 웃긴것이 분명 public 서비스인데, private가 붙었다.그 이유는 논리적인 하나의 IDC를 만들어서 개인이 사용할 수 있기 때문이라고 한다.모든 리소스는 VPC에 저장되며 한 region에 5개까지 VPC를 생성할 수 있다.(필요시 제한용량 해제 신청)물론 VPC 없이도 서버를 생성할 수 있지만, 권장되지 않는다고 한다.계정을 생성하면 기본 VPC가 생성되고 그 안에 기본적인 구성요소들이 생성된다.  이 기본 VPC는 건들지 말자. 어떤 에러들이 발생한다고 한다.  출처: https://cloudaffaire.com/create-a-vpc-interface-endpoint/위 그림에서도 볼 수 있듯이, VPC의 구성은 다음과 같이 이루어진다.  IGW(Internet Gate Way): 외부로 연결되는 인터넷 게이트웨이  Subnet: VPC의 가장 기본적인 하나의 단위로써, 각 서브넷은 public, private 중 설정이 가능private은 외부에서 접속할 수도, 외부로 나갈 수도 없음  ACL: 서브넷의 설정을 위한 방화벽  Security Group: 서브넷 하나의 보안을 설정, 주로 ACL은 두고, SG를 설정하여 보안관리  ELB(Elastic Load Balancing): 로드밸런싱과 보안 설정을 해줌private 서브넷을 만들경우, 외부와 통신이 안되는데 이때 ELB를 사용해서 외부에서 접근하도록 설정(로드밸런싱과 허용된 매서드만 접근이 가능해진다고 함)ELB의 종류는 다음과 같이 3가지 존재          Classic: 예전 방식      Application: 도메인 하위 레벨(/users 등)에 따라 다르게 웹 서버에 구성하고 이를 밸런싱      Network: 모든 프로토콜(http(s) + 커스터마이징 프로토콜)에 대해 밸런싱      3-1. Subnet과 EC2 인스턴스하나의 VPC에는 여러개의 서브넷을 생성할 수 있다.(10.1.10.100 / 10.1.10.110 등..)이때 ip를 구분하여 용도에 맞게 할당해 내부적으로 영역을 구분한다.(x.x.x.100대 이상은 외부통신, 미만은 내부통신 같은 방식)이렇게 만들어진 서브넷 하나에 만드는 서버를 우리가 아는 EC2라고 한다.오브젝트를 만들고 메모리에 올려 사용하는 것을 인스턴스라 칭하므로,가상화된 환경에 올려 사용자가 사용할 수 있도록 한 것을 EC2 인스턴스라 부른다.3-2. Bastion  출처: https://www.youtube.com/watch?v=edi1kyxznE0VPC를 구성할 때, 내부 서브넷들을 전부 private으로 설정하고 하나만 관리용 public 서브넷으로 설정한다.이 public 서브넷으로 다른 private 서브넷들을 관리하며, 이러한 관리자를 bastion이라 한다.이런 방법을 사용하려면 SG(Security Group)을 설정해 한정된 IP만 bastion에 접근하도록 허용해야 한다.  만약 전부 public으로 서브넷을 만든다면, 관리자 중 한 명만 퇴사해도 모든 서브넷의 key를 갱신해야 한다.매 번 이렇게 서브넷을 업데이트 할 수 없으므로, 전부 private으로 설정한다.3-3. NAT하지만 문제는 여전히 존재한다. 전부 private으로 만들어 버렸으니, 각 서브넷의 외부와 통신이 안된다.그럼 각 서브넷의 OS 업데이트는 어떻게 하는가?  출처: https://blog.2dal.com/2017/09/12/aws-vpc-basic/정답은 하나의 서브넷을 public으로 설정 후 outbound는 가능하게, inbound는 불가능하게 만들면 된다.이런 역할을 NAT이라 부르며 하나의 서브넷에 bastion과 NAT을 둘다 포함시킬 수도 있다.  이전에는 NAT 인스턴스를 생성해야 했으나, NAT gateway를 생성하여 서브넷 안에 포함시키면 작동하도록 변경되었다.3-4. Dev, Manage, Product VPC실제 개발 및 배포를 진행할 때는 VPC 구성을 어떻게 해야할까?여러가지 방법이 있겠지만, aws는 각 단계별로 VPC를 따로 구성하는 것을 추천한다.  출처: https://aws.amazon.com/ko/quickstart/architecture/compliance-uk-official/위의 그림은 aws 공식 홈페이지에서 가져온 것인데, Dev/Managemnet/Production 총 3단계로 구성되있다.이렇게 Stage 별로 VPC를 따로 구성해서 관리하는 것이 복잡한 서브넷간 설정을 피할 수 있기 때문이다.  물론 하나의 VPC 안에서 서브넷을 나눠 그룹별로 관리할 수도 있으나, 규모가 커졌을 때 서브넷간의 복잡한 설정으로 어려움이 따르게 된다.4. S3(Simple Storgae Service)  출처: https://www.megazone.com/techblog_191113_aws-privatelink/S3는 단순하게는 하나의 저장소이다.하지만 활용법에 따라 효율적인 정보의 전달이 가능한데, 이는 S3가 웹서버 역할을 제공하기 때문이다.이는 다음의 과정을 거쳐 이루어지게 된다.S3는 기본적으로 VPC 밖에 구성된 하나의 웹서버로써 이곳에 html 같은 정적인 파일을 주로 배치한다.End-user에게는 이곳을 보도록 설정하고, user가 원하는 요청을 수행하도록 그 파일에 스크립트로 짜놓는다.User가 해당 요청을 하게되면 스크립트가 브라우저에서 실행되어, VPC를 거쳐 EC2까지 요청을 전송한다.이러한 과정을 통해 User는 VPC를 신경쓸 필요없이 S3의 html로 결과를 받을 수 있게 된다.이러한 방식은 사실상 업계의 표준이라고 하며, 다른 오브젝트들이 이러한 S3호환 프로토콜을 제공한다.5. RDS(Relation DB Service)하나의 서브넷을 구현하고, 그 안에 DB 서버를 구축하여 운영하는 것이 기존의 방식이었다면,aws에서 제공하는 Paas의 일종인 RDS를 이용하여 더 효율적인 관리를 할 수 있다.이는 aws가 DB의 업데이트, 설치, 운영 그리고 관리까지 지원하기 때문이며, 지원하는 엔진은 다음과 같다.MySQL/Oracle/SQL Server/PostgreSQL/MariaDB/Aurora(MySQL과 호환)또한 RDS에서 Multi-AZ 옵션을 설정하면, 다른 AZ에 복제된 DB를 바로 사용할 수 있다.주로 data를 백업하여 이원화하는 용도로 많이 쓰이게 된다.  Aurora는 aws에서 제공하는 자체 DB로써 장애발생 및 AZ를 이용한 자체복구등 추가 기능을 지원한다고 한다.끝마치며aws의 기초에 대해 유능하신 어떤 분께 배운 내용을 토대로 작성된 글이다.인터넷을 찾아보면 훨씬 전문적이고 깊은 이해를 돕는 글들이 있지만,이 포스팅의 목적은 최대한 간단하게, 이해가 되도록 작성하는 것이었다.너무 긴 글이라 두개로 분리할까 고민했는데, 혹시 지치신 분들이 있다면 위로가 있기를…다음에는 간단하게 AWS VPC를 구성하는 실습을 진행해 볼 예정이다.  이번 포스팅에는 사진에 달려있는 출처들이 reference 역할을 하기 때문에 따로 참조를 달지 않았다.",
        "url": "/devlog/2020/01/10/aws-2.html"
      }
      ,
    
      "devlog-2020-01-10-aws-1-html": {
        "title": "[AWS] 퍼블릭 클라우드 vs 프라이빗 클라우드",
        "subtitle":"AWS 기초 - 1",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "aws",
        "content": "클라우드이제는 이 단어가 개발자가 아닌 주변 내 지인들에게도 전혀 낯설지 않은 단어가 되었다.그만큼 클라우드가 우리 일상에 가져오는 영향은 굉장히 크다고 할 수 있는데,이번 시리즈에서 클라우드의 기본 개념과 AWS의 기초개념 및 실습을 포스팅 하고자 한다.시리즈의 시작으로 각 클라우드의 장단점 및 고려사항부터 써보고자 한다.  클라우드의 기본 개념과 기존에 정리가 잘 된 많은 글들이 있으니,혹시 궁금한 것이 있다면 다른 글을 찾아보는 것을 추천합니다.Public Cloud나같은 일반 개발자나, 기업을 대상으로 서비스를 제공하는 클라우드 인프라를 퍼블릭 클라우드라 한다.클라우드 서비스를 제공하는 다양한 업체들(AWS, Google, MS, Alibaba, Naver)등은 가상환경 내의 서버를 임대해 준다.이러한 클라우드 서비스는 Pay-as-you-go으로 사용한 만큼 과금하는 방식을 채택하며 별도의 하드웨어가 필요하지 않다.Private Cloud하나의 조직에 전용 클라우드 환경을 제공하는 모델을 프라이빗 클라우드라 한다.(VMware, OpenStack등)사내 전용 클라우드로써, 각 조직이 더 효율적으로 관리할 수 있으나, 퍼블릭 클라우드에 비해 비용이 많이든다.각 조직에 on-premise 방식으로 적용될 수도 있고, 퍼블릭 클라우드 제공업체에서 off-premise로 호스팅 될 수도 있다.조달된 하드웨어와 가상화된 레이어 위에서 동작하기 때문에 시간이 절약되는 이점이 존재하지만,HW 관리자 – 하이퍼바이저 관리자 – SW 관리자 이런식의 구성으로 인해 하이퍼바이저의 관리가 또다른 비용발생으로 다가올 수 있다.또한 각 OS별로 라이센스를 일일히 구매해야 하므로 추가적인 비용이 발생할 수 있다.  개인적인 의견으로는 일반 사기업이 하기에는 어렵지 않나 싶다.Hybrid CloudVPN등의 보안연결을 통해서 하나 이상의 퍼블릭 클라우드 + 프라이빗 클라우드 환경을 결합하는 방식이다.두 개의 클라우드 간의 트래픽은 유동적으로 조정이 가능하여 유연한 대처가 가능하다.  프라이빗 클라우드에 많은 트래픽이 몰릴경우, 퍼블릭 클라우드로 버스팅하여 유동적인 대처가 가능하다.앞으로진행하게될 포스팅은 위에 언급한 것 중, 당연히 퍼블릭 클라우드인 aws를 이용하여 진행할 예정이다.  무료로 사용해 볼 수 있고, 가장 대중적이며 개인이 작은 규모로 해보기에 가장 좋기 때문이다.",
        "url": "/devlog/2020/01/10/aws-1.html"
      }
      ,
    
      "devlog-2020-01-09-etc-2-html": {
        "title": "[보안] 파일 업로드 취약점",
        "subtitle":"파일 업로드의 취약점과 공격,방어 방법",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "etc",
        "content": "1. 파일 업로드 취약점이란주로 게시판 등에서 파일 업로드 기능을 악용하여 시스템 권한을 획득할 수 있는 취약점을 의미한다.나처럼 보안에 대한 지식이 얕은 사람은 위의 문장이 생소하게 느껴질 것이기에, 다시 풀어 써본다.  악성 스크립트가 업로드 된 후, 서버상에서 스크립트를 실행하여 쉘을 획득하는 등의 행위로 서버를 장악할 수 있다.즉, 흔히 말하는 웹쉘의 업로드를 통해 시스템의 권한을 장악한다는 이야기이다.그렇다면 어떤 파일들이 웹에서 구동되는가? 웹 서버에서 실행 가능한 확장자는 다음과 같다.            언어      확장자                  asp, aspx      asp, aspx, htm, html, asa              php      phtml, php, php3, php4, php5, inc, htm, html              jsp, java      jsp, jspx, jsw, jsv, jspf, htm, html              perl      pl, pm, cgi, lib, htm, html              coldfusion      cfm, cfml, cfc, dbm, htm, html      이러한 악성 파일이 업로드 된다면, 접근권한, 정보유출, 악성코드 배포 등의 문제를 야기할 수 있다.2. 공격방법이러한 취약점을 찾아 공격하는 방법은 크게 4가지 정도이다.2-1. 취약점 점검가장 간단한 방법으로 다음과 같은 과정을 거친다.  파일 업로드시에 확장자 제한이 없는지 확인하고,  업로드된 파일에 접근 및 실행이 가능한지 확인하여 공격하는 것이다.2-2. Proxy 툴을 이용해 확장자 검사 우회 파일 업로드파일타입 변조등의 우회공격을 통해 확장자 검사를 피하는 것을 의미한다.업로드 시 파일의유형 정보를 알려주는 헤더 중, Content-type 속성을 프록시를 이용해 우회하여 공격할 수 있다.  자세한 사항은 다음 링크를 참조하시기를..https://bit.ly/2tIJ21w2-3. Null을 이용한 파일 업로드널(%00)문자가 문자의 끝을 의미하기 때문에 특정 확장자를 숨기기 위한 목적으로 사용될 수 있다.해당 부분의 취약점은 내부 API를 호출할 때 발생될 가능성이 있다.  널바이트(%00)와 .jpeg확장자를 함께 접목하여 업로드하면 %00 다음의 문자열은 무시하게 된다.            언어      우회패턴      처리패턴                  php      test.php%00.jpeg      test.php              asp      test.asp%00.jpeg      test.asp              jsp      test.jsp%00.jpeg      test.jsp      2-4. SQL Injection을 이용한 파일 업로드2가지 정도의 방법이 존재하는데, 다음과 같다.MySQL의 into outfile() 함수를 이용하여 웹서버에 파일을 생성할 수 있다.MSSQL의 저장 프로시저(xp_cmdshell)을 이용하여 echo와 » (파이프) 명령어를 통해 특정 파일에 삽입할 수 있다.3. 방어방법모든 부분을 전부 작성할 수는 없지만, 대략적으로 다음과 같은 방법을 통하여 기초적인 방어를 할 수 있다.  확장자 검사  대소문자 구분하지 않고 확장자 비교  특수문자가 포함된 경우 업로드 금지  업로드된 파일명, 확장자를 난수화하여 변경  업로드된 파일을 url 요청으로 직접 접근이 불가능한 위치에 저장Reference  https://4rgos.tistory.com/4",
        "url": "/devlog/2020/01/09/etc-2.html"
      }
      ,
    
      "devlog-2020-01-09-cicd-1-html": {
        "title": "[CI/CD] Jenkins vs GitLabCI vs Travis",
        "subtitle":"Jenkisn & Code Deploy로 Unity 앱 빌드 및 무중단 배포 - 1",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "devops",
        "content": "이번 시리즈에서는CI/CD 환경을 구축하여 App을 배포해보는 것이 목적이다.이를 위해 Jenkins를 이용하여 앱을 빌드하고, AWS Code Deploy를 이용해 배포하는 환경을 구축할 것이다.본격적으로 시작하기 전에 CI/CD 파이프라인 구축을 위한 서비스들이 무엇이 있는지 살펴보고,다음과 같은 솔루션들의 장단점을 분석하고자 한다.  Travis  GitLab CI  Jenkins1. Trvais별도의 회사였으나, GitHub에서 인수하였다.(GitHub는 MS가 인수함)오픈소스용 무료 travis.org와 Private Repo를 위한 유료 travis.com을 별도로 운영하고 있고, 내용은 동일하다.장점  GitHub와의 연동(그냥 깃허브 계정으로 로그인하며 된다.)  YML 파일을 통한 쉬운 설정  다양한 래퍼런스  직접 서버를 운영할 필요 없이, Travis에서 알아서 VM으로 호스팅해 줌  모든 job이 독립적(서로 간의 영향을 받지 않음)단점  Jenkins에 비해 플러그인의 종류가 적음  유료 서비스를 사용할 경우, 가격이 꽤 비쌈(기본: 69$/month, 일반: 129$/month)2. GitLab CIGitLab 서비스에 내장되어 있다.On-Premise 방식으로 설치하여 사용할 수도 있고, 웹 서비스로 사용할 수도 있다.GitLab CI만 Runner를 직접 호스팅하여 사용할 수 있는데, 이를 통해 고성능 혹은 서비스에 트고하된 환경에서 실행할 수 있다.  Runner: repo로부터 소스코드를 받아 해당 스크립트를 돌리는 작업을 수행GitLab의 경우shared runner를 사용해서 계획적으로 돌릴 수 있다.On-Premise 방식에서는 당연히 지원하고,GitLab의 클라우드 서비스를 사용하는 경우에도, Runner만 따로 운용할 수 있다.장점  GitLab과의 손쉬운 연동  Runner가 Docker 컨테이너 기반이라, Docker 친화적임(Docker Repo 무료 제공)  UI가 쉽고 간편함  모든 job이 독립적단점  역시나 Jenkins에 비해 플러그인의 종류가 적음  모든 job에 대해 artifact를 정의 및 업로드/다운로드를 해야함3. JenkinsJava 기반의 오픈소스로 구성되어 있으며, CI계의 아버지라 불린다.제일 오래된 만큼 다양한 플러그인을 지원하며, 사용자도 관련 문서도 많이 존재한다.장점  무료  다양한 IDE를 지원하며, 커스터마이징이 다양  많은 사용자들을 보유하고 있고, 관련 문서가 다양  호스팅을 직접해야하기 때문에 관련된 모든 부분을 관리할 수 있음단점  다양한 플러그인 -&gt; 플러그인 지옥  규모가 작은 프로젝트의 경우, 설정하는데 리소스 낭비가 발생할 수 있음  호스팅을 직접해야하기 때문에 서버 운영 및 관리 비용이 발생개인적인 견해로는CI/CD를 적용해야 한다는 생각에 제일 유명한 Jenkins를 사용하려는 사람들이 많은것 같다.하지만, Jenkins는 오래된 만큼 장단점이 확실한 솔루션임을 알고 사용했으면 좋겠다.특히 Build Server를 직접 구매 및 운영해야 하기 때문에 발생하는 단점이 생각보다 크게 다가오게 된다.하나부터 열까지 전부 환경설정을 구축해야하며, 서버를 관리하는데 발생하는 비용이 낭비가 될 수 있기 때문이다.  Jenkins를 사용할 때, 각종 방화벽 작업이나 서버의 관리 및 운용등은 생각보다 많은 리소스를 요구한다.따라서 규모가 크지않은 프로젝트거나, 외부 클라우드 서비스를 이용하는 상황등이라면 Jenkins말고 다른 서비스도 고려해볼 가치가 있다고 생각한다.내가 글을 작성하는 이 블로그 또한 Travis를 사용하여 간단한 CI/CD 형태로 빌드 및 배포하게 되어있다.개발을 하면서 느끼는 거지만, 모든 일에 정답은 없다.상황에 맞게 최선의 방법을 채택하여 가장 높은 효율을 낼 수 있는 방안을 선택하는 것도 일류 개발자의 자질이 아닐까.  이 글에서는 언급하지 않았지만, AWS, CircleCI등 수많은 다른 방법도 존재한다.Reference  https://about.gitlab.com/devops-tools/jenkins-vs-gitlab.html  https://hackernoon.com/continuous-integration-circleci-vs-travis-ci-vs-jenkins-41a1c2bd95f5  https://www.thecodecampus.de/blog/jenkins-vs-gitlab-ci/  https://blog.cookapps.io/cook-dev/tech-stack/#ci-cd",
        "url": "/devlog/2020/01/09/cicd-1.html"
      }
      ,
    
      "devlog-2020-01-08-etc-1-html": {
        "title": "[Linux] 기본 설정으로 포트 확인하기",
        "subtitle":"ping, telnet, nc, curl, bash",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "etc",
        "content": "외부 서버의 포트가 살아있는지 open여부를 점검하기이런 저런 이유로, 명령어들을 사용할 수 없는 경우가 존재한다.나도 원격 서버가 살아있는지 점검해야 하는데, host 서버에 telnet등이 지원하지 않아 고생한 경험이 있다.이러한 경우를 대비해, 서버와 통신이 되는지 확인하는 명령어를 종류에 따라 정리해 보았다.다음은 지극히 주관적인 (쉬운?) 순서대로 방법이다.1. Ping포트고 뭐고 필요 없을 때  ping은 port를 사용하지 않는다.이유는 TCP/IP 계층에서 사용되고, port가 사용되는 상위 계층인 TCP/UDP 와는 상관이 없기 때문이다.즉, ping으로는 port 확인이 불가능하다.$ ping [IP]// 예시$ ping 8.8.8.82. Telnet특정 port를 확인해야 할 경우$ telnet [IP] [PORT]  // 예시$ telnet 100.1.1.1 80803. nc(NetCat)일반적으로 UNIX의 cat명령과 비슷한 사용법 이지만, 대상이 파일이 아니라 network connection이다.포트 확인 기능 말고도 다양한 기능으로 사용이 된다.$ nc -z [IP] [PORT]// 예시$ nc -z 100.1.1.1 80804. curl대부분 서버는 telnet이 설치되어 있지만, 보안이슈나 최소 설치를 한 경우 사용이 불가능한 경우가 있다.그런 경우 다음의 명령을 사용하자. 아무리 최소 설치를 해도 curl은 설치되어 있기 때문이다.  curl의 parameter중 URL telnet 스키마를 사용하여 서버 통신 확인$ curl -v telnet://[IP]:PORT  // 예시$ curl -v telnet://100.1.1.1:80805. bash약간 하드한 방법이다. shell에 익숙하지 않은 사람들은 4번에서 끝내기를 권장한다.TCP 연결을 간단하게 bash의 내장된 기능으로 확인할 수 있다.$ timeout 5 bash -c 'cat &lt; /dev/null &gt; /dev/tcp/[IP]/[PORT]'; echo $?// 예시$ timeout 5 bash -c 'cat &lt; /dev/null &gt; /dev/tcp/100.1.1.1/8080'; echo $?// 결과$ 0   // 성공 $ 1   // 실패 연결 전 에러(hostname not known등 오류)$ 124 // 실패 Timeout 에러  echo $?는 UNIX에서 바로 전 실행의 결과를 보여주는 명령어이다.",
        "url": "/devlog/2020/01/08/etc-1.html"
      }
      ,
    
      "devlog-2020-01-08-devops-4-html": {
        "title": "[DevOps] 그래서 CI/CD가 뭔데?",
        "subtitle":"DevOps Full Chain - 4",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "devops",
        "content": "드디어CI/CD까지 도착하여 포스팅을 하게 되었다.긴 시간이었고, 나 또한 그동안 배우고 겪었던 것들을 글로 풀어내느라 시간을 꽤 썼다.인터넷을 찾아보면 CI/CD에 관련된 수 많은 자료가 나오므로, 자세한 설명보다는 내가 배우고 느낀대로 적어보겠다.들어가기 앞서CI/CD라는 단어를 사용하기 전에 우리는 왜 CI/CD를 적용해야 하는가를 생각해야 한다.앞선 글 DevOps란 무엇인가?에서 설명했듯이,고객에게 가치를 빠르고 안정적으로 전달하는 것이 DevOps의 목적이고, 이를 위해 CI/CD를 활용하는 것이다.더 상세한 설명을 하기 전에,CI = 지속적인 통합 + 자동화CD = 지속적인 배포 + 자동화개발 -&gt; CI -&gt; CD 순으로 Flow가 진행됨을 먼저 알고가면 좋을 것 같다.CI / CD  출처: https://dzone.com/articles/the-complete-introduction-to-cicd-1인터넷을 찾아보면 수 많은 CI/CD pipe-line 관련 이미지가 나온다.그 중 위 이미지는 가장 간략하고 정확하게 CI/CD의 개요에 대해 설명하는 그림인것 같아 가져와봤다.이 중, 개발자가 혼자서 진행하는 부분은 CI, CD 파이프라인 중 어디에도 속하지 않는다.다시 말해서 CI/CD의 파이프라인을 태운다는 것은 협업을 기반으로 한다는 의미이다.  물론 규모가 작아 혼자서도 CI/CD 파이프 라인을 구축할 수도 있다.하지만 CI/CD 파이프라인의 극적인 효율은 협업을 할 때 나오게 된다.CI = Continuous IntegrationCI는 개발자들의 코드를 지속적, 자동적으로 빌드하고, 단위테스트를 거치며, 통합테스트를 하는 과정이다.CI의 파이프라인이 구축되어 있지 않은 극적인 상황을 생각해 보자.10명의 개발자가 각자 빌드 후, 유닛테스트를 하고 통합테스트를 진행한다.문제는 단위테스트와 통합테스트를 하는 시점이 모두에게 동일하고 명확하게 정의되기가 어렵다는 점이다.만약, 10명의 개발자가 각자 개발 후 통합테스트를 한 번에 진행한다면…?  상상은 각자의 몫이다.이제 CI를 적용해서 각 개발자들 간의 Ground Rule을 다음과 같이 세웠다고 생각해보자.  모든 개발자들은 퇴근 전 각자의 코드를 Main 코드와 통합한다.  각자의 코드가 잘 동작하는지 테스트한다.  통합테스트를 진행한다.  버그가 발견된다면, To-Do 목록에 작성하고 다음 날 업무를 수행한다.CI를 적용하기 전 상황보다는 효율적이고 소스코드의 관리도 훨씬 잘 될 것이다.하지만 글을 쓰면서도 위의 모든 과정이 너무나도 귀찮다.  당신이 개발자라면 위와 같은 과정을 수작업으로 하겠는가?누군가가 나 대신 빌드와 테스트들을 해주고 버그를 기록해준다면 얼마나 좋을까.그래서 CI/CD 파이프라인에는 필연적으로 자동화가 포함이 된다.자동화가 적용된 위의 WorkFlow는 다음과 같이 간소화 된다.  퇴근 전 각자의 코드를 Main 코드와 통합한다.  다음날 출근 후, 버그 리포팅을 기반으로 코드를 수정한다.  개발자들이 게을러야 하는 이유가 단적으로 드러나지 않는가?CD = Continuous Deploy/DeliveryCD는 개발된 SW가 배포되는 시점에 신뢰할 수 있는 수준을 유지하도록 지속적으로 관리하는 것이다.CI의 연장선상에 있으며, 이상적으로는 CI가 지속적/자동적으로 이루어진다면,CD 또한 지속적/자동적으로 이루어질 수밖에 없다.  실제로 CI/CD 파이프 라인을 구축해서 배포를 해본다면, 얼마나 효율적인지 알 수 있다.이론은별거없다. CI/CD의 등장배경과 특징 및 장점을 살펴보았지만, 이해하기 어려운 개념은 아니다.하지만 실제로 CI/CD 자동화 파이프라인을 구축하기 위해서는 많은 삽질이 필요하다.어떤 프로세스를 언제 어떻게 적용하고, 결과는 어떤 방법으로 처리할지 등이 고려되어야 한다.바닥부터 구축하라고하면 차라리 안하는게 나을수도 있지만, 역시 누군가가 만들어놓은 솔루션이 있다.Jenkins, Travis, GitLabCI 등의 CI 서버가 있고 각 솔루션의 장단점을 분석한 후에 단계별 Stage의 tool들을 살펴보러가겠다.Reference  https://dzone.com/articles/the-complete-introduction-to-cicd-1  https://www.redhat.com/ko/topics/devops/what-is-ci-cd  https://itholic.github.io/qa-cicd/",
        "url": "/devlog/2020/01/08/devops-4.html"
      }
      ,
    
      "devlog-2020-01-07-devops-3-html": {
        "title": "[DevOps] Scrum? Agile?",
        "subtitle":"DevOps Full Chain - 3",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "devops",
        "content": "Scrum이란Scrum은 그 자체로 하나의 방법론이자, Agile의 실천 도구 중 하나이다.이 말은, Agile로부터 Scrum이 등장한 것이 아니라는 이야기이다.다른 실천 도구들(칸반, XP - extreme programming, 린SW개발)등은 Agile이라는 용어 정의 전에 이미 여러 형태로 존재하였다.이후  Agile 선언문이 발표되며 이러한 방법들이 Agile 이라는 깃발 아래 모여들었고, 그 중 우리에게 익숙한 것이 Scrum이다.  결국 스크럼은 작은 개발팀, 짧은 개발 주기 및 팀원들의 생산성을 유지시켜 SW개발을 하는 대표적인 Agile 방법론이다.Scrum의 특징다음 특징들로 Scrum을 정의할 수 있다.  프로젝트 관리: 역할, 정의에 중점  시간 설정: 15분의 Daily Meeting, 1~4주 정도의 개발주기  관리체계: 요구사항(BackLog)관리, 업무 진행 가시화  팀 중심: 5~9명으로 팀 구성, 본인 task보다 급한 task를 우선시  이러한 특성은 유연하게 개발하기에 최적화 되어있는데, 특히 팀원의 수는 피자 한 판을 시켰을 때 나눠먹기 좋은 인원이라고 한다.스크럼의 5가지 가치  출처: https://www.scrum.org/resources/blog/5-scrum-values-take-center-stage항상 이러한 가치를 볼 때 손과 발이 없어지는 경험을 하지만, 그래도 정의해 보도록 한다.  Courage(용기): 갈등과 도전을 통해 일을 할 수 있는 용기  Focus(집중): 모두가 스프린트동안 같은 목표를 향해 나아가는 것  Commitment(확약): 세운 목표를 실행하는 것  Respect(존중): 팀원간 다른 객체임을 인정하고, 존중하는 것  Openess(정직): 업무상태를 공개하고, 일의 효율성을 높이는 것  일할 때 기본적으로 너무 당연한 자세 아닌가 싶지만, 실제로 스크럼을 해보면…특히 한국인의 수직적인 정서상, 팀원 간의 존중이 가장 어려운부분인것 같다.Scrum Process  출처: https://brainhub.eu/blog/differences-lean-agile-scrum/Scrum 진행은 Broduct Backlog에서 한 Sprint에 수행할 작업들을 도출한 뒤, 매일 이루어지는 Daily scrum을 통해 팀원들의 업무 진척 상황을 공유하고 필요시 지원을 하는 방식으로 이루어진다.해당 Sprint가 끝나면 Sprint 리뷰를 통해 다음 Sprint의 완급을 조절하며 이 과정을 반복한다.각 단계별 구성요소는 다음과 같다.  Product Backlog: 전체 기간동안 개발해야하는 기능, 특성 및 기술에 대한 나열. 요구사항의 우선순위 나열 필수  Sprint Planning Meeting: 해당 스프린트의 기간, 수행해야할 목록등 해당 스프린트 계획 수립  Sprint Backlog: 해당 Sprint 기간 동안 수행하는 Task 목록. Product Backlog에서 우선순위순으로 선택Scrum에서는 각 구성원이 주어진 역할을 잘 해내는것이 중요한데, 구성원들은 다음의 역할 중 하나를 따르게 된다.  Product Owner(PO):          고객, 관리자 및 팀원 간의 합의를 도출해 목표 설정      요구사항 정의, Product Backlog 간의 우선순위 조정      Product Backlog 업데이트 수행      제품을 사용할 고객이 직접 하거나, 비지니스 요구사항을 정의할 수 있는 사람        Scrum Master(SM):          팀원들이 Scrum을 올바르게 할 수 있도록 가이드하는 역할      최대한 객관적인 시각에서 Scrum의 원칙이 잘 적용될 수 있도록 도움      문제 발생시, 해결하는 역할      일이 끝났을 때, 잘 끝났는지 확인      직책에 상관없이 수행 가능        Scrum Team:          Backlog에 따라 Sprint 동안 개발하는 팀원      Cross-functional한 롤을 가진 팀원들로 구성(개발자, 디자이너, 설계자 등)      그 외 산출물로써는 Burn Down Chart가 존재하며, 각 Task별로 작업량을 측정한 뒤 작업량의 총 합에서 완료한 Task들의 작업량을 빼가며 그래프의 하강 기울기를 통해 다음 Sprint의 진행을 조절한다.  기존의 Top-Down방식과는 달리 Scrum에는 PM과 같은 직책이 존재하지 않는다.그저 서로간의 존중을 바탕으로 팀원간의 소통과 협업을 최대로 이끌어내며 일하는 것이 목표이며,Scrum Master는 권력자나 리더가 아니라 그저 조력자에 불과한 직책으로 늘 팀원들에게 귀기울이며 의견을 들어야 한다.  또한, 실제로 Scrum을 하다보면 Daily meeting이 서로 간의 감시와 업무 보고의 연장선이라고 느낄 수 있다.하지만 Scrum Master가 팀원들을 강압적으로 압박하지 않고, Daily meeting의 목적이 우선순위에 따라 Task를 수행하며 우선순위가 높은 Task에 도움이 필요하다면, 자발적으로 팀원들이 본인의 Task를 제쳐두고 도움을 주는 것임을 팀원들이 숙지하도록 도와주는 것이 중요하다.  Reference  https://brunch.co.kr/@insuk/13  https://needjarvis.tistory.com/317",
        "url": "/devlog/2020/01/07/devops-3.html"
      }
      ,
    
      "devlog-2020-01-07-devops-2-html": {
        "title": "[DevOps] Agile..?",
        "subtitle":"DevOps Full Chain - 2",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "devops",
        "content": "Agile  Agile: 날렵한, 민첩한Agile의 사전적 의미는 위와 같다.그 중, 나는 후자에 가까운 의미가 더 어울린다는 생각이 든다.민첩하게 무언가를 한다는 것은 고객에게 빠르게 가치를 전달하는 요즘 개발의 방식과 잘 맞기 때문이다.결국 Agile은 하나의 방법론이다. 민첩하게 개발을 하기 위한 방법론.그렇다면 왜 항상 Agile은 DevOps와 함께 거론되며, 어떠한 배경이 있었기에 새로운 방법론이 나오게 되었는지 알아보도록 하자.기존에는 무엇이 문제였는가?늘 새로운 것이 나오는 이유는, 기존에 존재하던 것이 현 상황에 잘 맞지 않기 때문이라 생각한다.그렇다면 이 전에 존재하던 방법론은 무엇이었길래 문제였는가?답은 Waterfall 이라 불리는 일명 ‘폭포수모델’은 개발 생태계를 지배하던 방법론이었다.계획수립 - 요구분석 - 설계 - 개발 - 테스트 - 배포의 과정을 거치는 이 방법론은 다음과 같은 장점으로 오랫동안 생태계에 군림했다.  적용사례가 풍부  전체 /현재 과정의 이해가 쉬움  문서의 관리가 쉬움이 중, 1번 장점은 생각 외로 정말 큰 장점이다.프로젝트의 크기가 크지 않고, 새로운 방법으로 도전할 리소스가 안된다면 충분히 재고할 가치가 있는 것이다.하지만 이러한 방법은 치명적인 단점을 안고 있는데, 바로 개발이병행되거나 반대로 진행되지 않는다는 것이다.시장의 변화속도가 매우 빠르고, 다양한 요구사항이 등장하는 현대에는 적용하기 어려운 방법이기 때문이다.더이상 테스트 중에 요구사항이 변경되어 처음부터 다시 시작해야하는 방법으로는 한계에 봉착한 사람들은 새로운 방법을 몰색하였고, 그 결과 Agile이 등장하게 되었다.  하지만 나는 늘 무조건 새로운 것이, 트렌디한 것이 정답은 아니며,상황에 맞는 방법을 잘 가져다가 쓰는 것이 훌륭한 선택이고 좋은 결과를 도출할 확률이 높다고 생각한다.waterfall도 요구사항이 단순하고 변경 가능성이 적거나, 프로젝트의 규모와 난이도가 낮다면 충분히 고려할 만한 방법이라는 뜻이다.그래서 Agile은단어 그대로 민첩한 개발에 중점을 두고 있다.큰 계획을 수립하지 않고 주어진 요구 사항을 스프린트에 맞춰 작은 단위로 유연하게 개발하는 방식이다.인터넷을 찾다보면 여러가지 어려운 말로 Agile을 설명하지만 결국 나는 하나의 문화라고 생각한다.  빠르고 유연하게 개발하는 문화. 이 이상으로 Agile한 것이 무엇이 있을까스프린트는다음과 같은 과정으로 이루어 진다.  고객의 피드백  다양한 방법(스크럼등)을 통해 스프린트 목표 설정  스프린트 진행  배포  1로 복귀          피드백을 받으며 지속적으로 배포하는 스프린트를 여러 번 진행하여 개발하는 것이 Agile 이다.      우리도 Agile하게 일해봐야지라는 생각은 충분히 고려를 한 후, 적용하는 것이 좋다.위에서도 언급했지만, 늘 Agile이 정답은 아니다.많은 준비를 마친 후에 비로소 걸어가야 한다고 생각한다.그래서 DevOps와 Agile은연장선상에 있다고 생각한다.Agile의 목표가 빠른 소비자 피드백을 기반하여 개발을 진행 한다면,DevOps는 개발자와 운영자의 간극을 좁혀 더욱 민첩한 개발 &amp; 배포가 가능하기 때문이다.Reference  https://blog.sonim1.com/238  https://www.sangheum.com/149",
        "url": "/devlog/2020/01/07/devops-2.html"
      }
      ,
    
      "devlog-2020-01-07-devops-1-html": {
        "title": "[DevOps] DevOps란 무엇인가?",
        "subtitle":"DevOps Full Chain - 1",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "devops",
        "content": "DevOps 등장배경  DevOps = Development + Operations하나의 소프트웨어를 개발하기 위해 여러 개발자가 동시에 협업하여 빠르게 개발할 수 있는 환경이 필요하며, 수많은 사용자를 상대로 서비스를 오픈하기 위해 안정적인 인프라가 필요하다.이러한 모순되는 두 가지, 신속함과 안정성에서 개발자와 운영자간의 충돌이 발생하게 된다.이러한 배경에서 등장하게 된 것이 DevOps이다. 자동화를 핵심으로 두 역할 간의 간극을 좁히게 해주며,업무와 정보 또한 쉽게 공유하게 해준다. 더이상 통합 빌드를 특정 시점에 진행하는 것이 아니라,주기적으로 수행하며 오류를 사전에 방지하고 시간을 단축한다.DevOps 핵심요소DevOps의 핵심요소는 CALMS로 다음과 같은 5가지 요소로 이루어져있다.  Culture(문화)  Automation(자동화)  Lean(간소화)  Measurement(측정)  Share(공유)Culture(문화)  DevOps 문화 = 협업DevOps의 문화는 도구의 문제가 아니라, 사람 간의 문제를 해결하기 위해 등장했다.Automation(자동화)  개발, 테스트 및 배포의 핵심요소자동화를 통해 막대한 이익을 얻을 수 있으며, 이는 곧 CI(지속적인 통합)과  CD(지속적인 배포)로 구성된다.또한 개발자와 운영자가 서로 업데이트한 내용을 자동화하여 확인함으로써, 즉각적인 소통을 가능하게 한다.Lean(간소화)  낭비를 제거하고 고객에게 가치를 빠르게 전달끊임없이 문제를 찾고, 해결하고, 개선하는 사고방식을 의미한다.Measurement(측정)  여러가지를 측정하고, 측정 결과를 가시화하여 보여줌실질적인 데이터를 가시화하여 제공하므로써, 지속적인 개선을 향한 노력이 실제 개선으로 나아가는지 확인 가능하다.Share(공유)  성공 여부와 상관없이 서로의 경험을 공유서로 경험을 공유함으로써, 마찰을 줄이고 서로 간의 경계를 허무는 발판이 된다.Reference  https://www.atlassian.com/ko/devops  https://www.redhat.com/ko/topics/devops#?  https://devops.com/using-calms-to-assess-organizations-devops/",
        "url": "/devlog/2020/01/07/devops-1.html"
      }
      ,
    
      "devlog-2020-01-07-devops-0-html": {
        "title": "[DevOps] 데브옵스, 에자일 그리고 CI/CD 시리즈",
        "subtitle":"DevOps Full Chain - 0",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "devops",
        "content": "개발을 하다 보면DevOps, Agile, CI/CD와 같은 이야기들이 여기저기서 들린지 꽤 되었다.사실 이러한 단어와 개념들이 나온지는 오래되었지만, 우리나라에서 적용되고 진행된지는 몇 년 안된 것 같다.들어는 보았지만 각 용어에 대한 지식이 얕기에, 이번 기회에 본 시리즈를 포스팅하며 학습할 예정이다.나는새로운 개념을 익힐 때, terminology(용어)를 굉장히 중요하게 생각하는 편이다.약간 꼰대같이 들릴 수도 있지만, 단어를 먼저 이해하는 것이 지식의 본질에 접근하는 가장 정직하고 빠른 길이라고 느껴지기 때문이다.이러한 관점에서, 새로운 단어의 의미를 알기 위해서는 그 단어가 나오게 된 배경을 아는 것이 이해를 위한 첫 걸음이라 생각하며 포스팅을 시작하고자 한다.앞으로이어지게 될 CI/CD 포스팅 시리즈는 각 개념에 대해 정의와 등장배경을 포스팅하며, 크게 다음과 같은 내용을 다룰 예정이다.  DevOps  Agile  CI/CD와 각 stage별 플랫폼여전히부족한 것이 많아 본 시리즈를 포스팅하면서도, 틀린 부분이 있을 수 있으니 언제든 피드백은 환영합니다.",
        "url": "/devlog/2020/01/07/devops-0.html"
      }
      ,
    
      "devlog-2020-01-06-web-2-html": {
        "title": "[Web] JSTL &amp; c tag",
        "subtitle":"자바 서버페이지와 c tag에 대한 분석",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "web",
        "content": "들어가기 앞서  본 문서에서는 JSTL 및 c tag에 대하여 알아보도록 한다.  출처: https://bit.ly/2OpbwWJ, https://bit.ly/2oboH2w1. JSTLJSTL(JSP Standard Tag Library)는 JSP페이지에서 많이 사용되는논리적인 판단, 반복처리, 포맷처리를 위한 커스텀 태그를 표준으로 만들어 정의한 라이브러리1-1. Why JSTL  JSP는 HTML 코드와 스크립트릿, 표현식등의 스크립트 코드가 섞여 가독성이 떨어짐  이를 해결하기 위해 HTML 태그와 비슷한 코드를 사용해 처리하는 것이 JSTL1-2. JSTL 사용법  JSTL 사용법으로는 다음과 같이 두 가지 방법이 존재          pom.xml에 maven 의존 설정           &lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet&lt;/groupId&gt;       &lt;artifactId&gt;jstl&lt;/artifactId&gt;       &lt;version&gt;1.2&lt;/version&gt;   &lt;/dependency&gt;                    jar 파일을 WEB-INF/lib 디렉토리에 복사      1-3. JSTL이 제공하는 태그  JSTL의 태그는 다음과 같은 종류가 존재  코어          주요기능: 변수지원, 흐름제어, URL 처리      접두어: c      관련 URL: http://java.sun.com/jsp/jstl/core        XML          주요기능: XML 코어, 흐름 제어, XML 변환      접두어: x      관련 URL: http://java.sun.com/jsp/jstl/xml        국제화          주요기능: 지역, 메시지 형식, 숫자 및 날짜 형식      접두어: fmt      관련 URL: http://java.sun.com/jsp/jstl/fmt        DataBase          주요기능: SQL      접두어: sql      관련 URL: http://java.sun.com/jsp/jstl/sql        함수          주요기능: 컬렉션 처리, String 처리      접두어: fn      관련 URL: [http://java.sun.com/jsp/jstl/functions])(http://java.sun.com/jsp/jstl/functions)        이 중, 제일 많이 사용되는 태그는 c tag(코어)2. C Tag코어 태그 라이브러리는 변수 설정이나 논리 처리에 사용되는 스크립트 코드를 대체하는 태그를 제공  변수 지원:          set, remove        흐름 제어:          if, choose, forEach, forTokens        URL 처리:          import, redirect, url        기타 태그:          catch, out      2-1. set, remove (변수 설정)  &lt;c:set&gt; 태그는 EL 변수 값 혹은 EL 변수의 프로퍼티 값을 지정하거나, JSTL 태그에서 사용할 변수의 값을 처리할 때 다음과 같이 사용          &lt;c:set var=\"varName\" value=\"varValue\" [scope=\"지정영역\"] /&gt;      &lt;c:set target=\"대상\" property=\"프로퍼티 이름\" value=\"값\" /&gt;          &lt;!-- 첫번째 사용법 (jstl 변수를 생성하여 사용하는법) --&gt;  &lt;c:set var=\"test1\"  value=\"니나노\"/&gt;  &lt;!-- 두번째 사용법 (빈즈활용) --&gt;  &lt;!-- 자바 빈즈가 필요함. 한페이지에서 설명하기위해.. map 으로 대체 --&gt;  &lt;% Map&lt;String, String&gt; member = new HashMap&lt;String, String&gt;();  member.put(\"name\", \"홍길동\");  %&gt;          &lt;c:set var=\"member\"  value=\"&lt;%=member%&gt;\"/&gt;  &lt;div style=\"background-color: yellow;\"&gt;${member.name}&lt;/div&gt;  &lt;c:set target = \"&lt;%=member%&gt;\" property = \"name\" value = \"홍길동2\"/&gt;                          실행결과니나노홍길동홍길동2홍길동2                      &lt;c:remove&gt; 태그는  태그로 지정한 변수를 `삭제`할 때 다음과 같이 사용          &lt;c:remove var=\"varName\" [scope=\"지정영역\"] /&gt;          &lt;c:set var=\"test1\"  value=\"니나노\"/&gt;  &lt;div style=\"background-color: yellow;\"&gt;${test1}&lt;/div&gt;  &lt;!-- c:remove 사용하여 c:set 변수를 삭제 --&gt;  &lt;c:remove var = \"test1\"/&gt;  &lt;div style=\"background-color: yellow;\"&gt;${test1}&lt;/div&gt;                          실행결과니나노(빈 텍스트가 출력 됨)                    2-2. if, choose (조건문)  &lt;c:if&gt; 태그는 조건의 참/거짓 유무에 따라 분기하며 다음과 같이 사용          else는 따로 존재하지 않음, 따라서 choose를 사용              &lt;c:if test=\"조건\" [var = \"testResult\"]/&gt;          &lt;c:set var=\"test1\"  value=\"3\"/&gt;  &lt;c:if test=\"${test1 &gt; 1}\"&gt;      &lt;div style=\"background-color: yellow;\"&gt;1보다 크다&lt;/div&gt;  &lt;/c:if&gt;  &lt;c:if test=\"${test1 &lt; 1}\"&gt;      &lt;div style=\"background-color: yellow;\"&gt;1보다 작다&lt;/div&gt;  &lt;/c:if&gt;                          실행결과1보다 크다                      &lt;c:choose&gt;, &lt;c:when&gt;, &lt;c:otherwise&gt; 태그를 else if, else 대신 다음과 같이 함께 사용          &lt;c:chose&gt;&lt;c:when test=\"조건\"&gt;실행문&lt;/c:when&gt;&lt;c:otherwise&gt;실행문&lt;/c:otherwise&gt;&lt;/c:chose&gt;          &lt;c:set var=\"test1\"  value=\"3\"/&gt;  &lt;c:choose&gt;      &lt;c:when test=\"${test1 &lt; 1}\"&gt;          &lt;div style=\"background-color: yellow;\"&gt;1보다 작음&lt;/div&gt;      &lt;/c:when&gt;      &lt;c:when test=\"${test1 == 3}\"&gt;          &lt;div style=\"background-color: yellow;\"&gt;3과 같음&lt;/div&gt;      &lt;/c:when&gt;      &lt;c:otherwise&gt;          &lt;div style=\"background-color: yellow;\"&gt;쩌리&lt;/div&gt;      &lt;/c:otherwise&gt;  &lt;/c:choose&gt;                          실행결과3과 같음                    2-3. forEach, forTokens (반복문)  &lt;c:forEach&gt; 태그는 자바의 for문과 동일하며, 다음과 같이 사용          &lt;c:forEach var=\"변수\"  item = \"아이템\" [begin =\"시작값\" end=\"종료값\" step=\"증가값\" varStatus=\"현재의값\"]/&gt;          &lt;!-- memberList라는 구조체가 존재하며 프로퍼티 값은 name, age를 가짐 --&gt;  &lt;c:forEach var=\"member\" items=\"&lt;%=memberList %&gt;\" &gt;      &lt;div style=\"background-color: yellow;\"&gt;          이름 : ${member.name} 나이 : ${member.age}      &lt;/div&gt;  &lt;/c:forEach&gt;                          실행결과이름: 홍길동 나이: 21이름: 김순이 나이: 23                      &lt;c:forTokens&gt; 태그는 자바의 split 기능과 유사하며, 다음과 같이 사용          &lt;c:forTokens var=\"변수\" items=\"아이템\" delims=\"자를 문구\" [varStatus=\"status\"]/&gt;          &lt;c:set var=\"nameGroup\" value=\"철수,영미,나미,우솝,루피\"/&gt;  &lt;c:forTokens var=\"name\" items=\"${nameGroup}\" delims=\",\"&gt;      &lt;div style=\"background-color: yellow;\"&gt;          이름 : ${name}      &lt;/div&gt;  &lt;/c:forTokens&gt;                          실행결과이름: 철수이름: 영미이름: 나미이름: 우솝이름: 루피                    2-4. url, imnport, redirect (URL 처리)  해당 태그들은 문법만 정리  &lt;c:url value = \"링크\"/&gt;  &lt;c:import url=\"url\" [context=\"context\"] [var=\"varName\"]  [scope=\"{page|request|session|application}\"] [charEncoding=\"charEncoding\"]&gt;  &lt;c:redirect url=\"value\" [context=\"context\"]/&gt;2-5. catch, out (기타)  해당 태그들은 문법만 정리  &lt;c:catch var=\"명칭\"&gt;&lt;/c:catch&gt;  &lt;c:out value=\"value\" [escapeXml=\"{true|false}\"] [default=\"value가 없을 때 표시될 문자\"]  /&gt;",
        "url": "/devlog/2020/01/06/web-2.html"
      }
      ,
    
      "devlog-2020-01-06-web-1-html": {
        "title": "[Web] Get VS Post",
        "subtitle":"HTTP 프로토콜에 대한 분석",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "web",
        "content": "  본 문서에서는 GET / POST 방식에 대하여 알아보도록 한다.  출처: https://bit.ly/31M2YN8 0. 들어가기 앞서  사용자는 단순히 URL을 입력하여 페이지로 이동을 하지만, 서버 내부에서는 클라이언트의 요청에 응답하기 위해 처리를 해주어야 함  이 때,  클라이언트가 서버로 요청을 보내는 방법인 HTTP Method에는 크게 다음과 같은 2가지 방법이 존재          GET      POST      1. GET 방식GET은 어떤 정보를 가져와 조회하기 위해 사용하며, 간단한 데이터를 URL에 넣도록 설계된 방식으로 다음과 같은 특징을 지님1-1. GET 방식의 특징  URL에 변수(데이터)를 포함시켜 요청  데이터를 Header에 포함하여 전송  URL에 데이터가 노출  전송하는 길이에 제한  캐싱이 가능  형식          URL?변수명1=값1&amp;변수명2=값2&amp;변수명3=값3&amp;…      다음과 같이 직접 URI를 입력하여 요청가능                  /hello/test.php?name1=value1&amp;name2=value2                    2. POST 방식POST 방식은 데이터를 서버로 제출하여 추가 또는 수정하기 위해서 데이터를 전송하는 방식으로 다음과 같은 특징을 지님2-1. POST 방식의 특징  URL에 변수(데이터)를 포함하지 않고시켜 요청  데이터를 Body에 포함하여 전송  URL에 데이터가 노출되지 않음  전송하는 길이에 제한이 없음  캐싱이 불가능  형식          POST /hello/test.php HTTP/1.1    Host: jmnote.com    name1=value1&amp;name2=value2      ",
        "url": "/devlog/2020/01/06/web-1.html"
      }
      ,
    
      "devlog-2020-01-06-java-5-html": {
        "title": "[Java] JDBC / JPA &amp; Hibernate / Mybatis 차이",
        "subtitle":"SQL Mapper 와 ORM의 개념 및 차이점 분석",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "java",
        "content": "  본 문서에서는 JDBC, JPA/Hybernate, Mybatis에 대하여 알아보도록 한다.  출처: http://bitly.kr/C72t7zb0. 영속성  데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성  Persistence Layer: 프로그램 아키텍쳐에서 데이터에 영속성을 부여해주는 계층  Persistence Framework: JDBC 프로그래밍의 복잡함 없이 간단히 DB와 연동되는 시스템을 빠르게 개발할 수 있으며,안정성을 보장해주는 프레임크. 그 종류는 다음과 같다.          SQL Mapper      ORM      0-1. SQL Mapper  SQL &lt;- 매핑 -&gt; Object 필드  SQL문으로 직접 DB의 데이터를 다룸          종류: Mybatis, JdbcTemplates등      0-2. ORM  DB 데이터 &lt;- 매핑 -&gt; Object 필드  객체를 통해 간접적으로 DB의 데이터를 다룸          직관적 코드(매서드)를 통해 조작 가능      객체 간의 관계를 바탕으로 SQL을 자동 생성      종류: JPA, Hibernate등      0-3. ORM의 장,단점장점  객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와줌  재사용 및 유지보수의 편리성이 증가함  DBMS에 대한 종속성이 줄어듬단점  완벽한 ORM 으로만 서비스를 구현하기가 어려움  잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점 발생  프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어려움 1. JDBC(Java Database Connectivity)  JDBC는 DB에 접근할 수 있도록 java에서 제공하는 API  모든 Java의 Data Access 기술의 근간  모든 Persistence Framework는 내부적으로 JDBC API를 사용 2. JPA(Java Persistence API)  Java ORM 기술에 대한 API 표준 명세로 Java에서 제공하는 API  JPA의 구성요소          javax.persistence 패키지로 정의된 API      JPQL(Java Persistence Query Language)      객체/관계 메타데이터        사용자가 원하는 JPA 구현체를 선택해 사용 가능          Hibernate, EclipseLink, DataNucleus, OpenJPA, TopLink Essentails 등      2-1. Hibernate  Hibernate는 JPA의 구현체 중 하나  내부적으로 JDBC API를 사용해 SQL 구현  HQL(Hibernate Query Language)라 불리는 강력한 쿼리 언어 포함  장점          빠른 개발 가능      쿼리보다는 객체에 집중 가능      테이블 생성, 변경등 관리가 쉬움        단점          어려움(많은 것을 알아야 함)      오사용시 데이터 손실 및 성능 저하 유발       3. Mybatis  개발자가 정의한 SQL을 지원하는 SQL Mapper  DB의 레코드에 매핑하기 위해 XML과 Annotaion 사용 가능  장점          SQL에 대한 모든 컨트롤을 할 경우 적합      SQL 쿼리 최적화가 잘 되있을 경우 유용        단점          모든 관계에 대한 조작을 하고자 할 때는 적합하지 않음      ",
        "url": "/devlog/2020/01/06/java-5.html"
      }
      ,
    
      "devlog-2020-01-06-java-4-html": {
        "title": "[Java] 커넥션풀",
        "subtitle":"Java <-> DB 연결관계에 대한 해석",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "java",
        "content": "  본 문서에서는 커넥션 풀에 대하여 알아보도록 한다.1. 커넥션 풀 등장 배경  실제 서비스 운영 환경에서는 서로 다른 장비를 이용해 자바 프로그램과 DBMS를 실행이때 자바 프로그램에서 DBMS로 커넥션을 생성하는 시간은 성능 저하의 원인이 됨  동시 사용자수가 많으면 사용자마다 DB 커넥션을 생성해 DBMS에 부하를 줌  최초 연결에 따른 응답 속도 저하와 동시 접속자가 많을 때 발생하는 부하를 줄이기 위해 등장 2. 커넥션 풀의 개념 및 특징  커넥션 풀은 일정 개수의 DB 커넥션을 미리 만들어두는 기법  커넥션이 필요하다면, 풀에서 커넥션을 가져와 사용한 뒤 다시 풀에 반납  커넥션을 미리 생성하기 때문에 커넥션을 사용하는 시점에서 생성시간 단축  동시 접속자가 많더라도 생성 부하가 적기에 더 많은 동시 접속자 처리 가능  커넥션의 개수를 조절해 DBMS의 부하를 일정하게 조절 3. 커넥션 풀의 종류DB 커넥션 풀 기능을 제공하는 대표 모듈은 다음과 같다.  Tomcat JDBC  HikariCP  DBCP  c3p0",
        "url": "/devlog/2020/01/06/java-4.html"
      }
      ,
    
      "devlog-2020-01-06-java-3-html": {
        "title": "[Java] JDBC란",
        "subtitle":"Java <-> DB 연결관계에 대한 해석",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "java",
        "content": "  본 문서에서는 JDBC에 대하여 알아보도록 한다.  출처: https://bit.ly/2knY48N1. JDBC란?  Java DataBase Connectivity  JDBC는 자바 프로그램이 DBMS에 일관된 방식으로 접근할 수 있도록 API를 제공하는 자바 클래스들의 모임으로 다음의 특징을 가진다.          JDBC는 함수 호출용 SQL 인터페이스      JDBC는 ANSI SQL-92 표준을 지원      JDBC는 공통된 SQL 인터페이스를 바탕으로 함                  결과적으로 JDBC는 DB의 종류와 독립적인 API를 제공                    2. JDBC 구성 2-1. 응용프로그램  데이터베이스에 연결을 요청  데이터베이스에 SQL 문을 전송  SQL 문의 결과를 요청  오류가 발생하는 경우 오류 처리  트랜잭션을 제어2-2. 드라이버 매니저  데이터베이스에 맞는 드라이버 검색  JDBC 초기화를 위한 작업을 수행2-3. 드라이버  데이터베이스에 연결  데이터베이스에 SQL 문을 전달  응용프로그램에 검색 결과를 전달  필요한 경우 커서를 조작  필요한 경우 트랜잭션을 시작  커서란?      오라클에서 CURSOR란 시스템 글로벌 영역의 공유 풀 내에 저장공간을 사용하여 사용자가 SQL 문을 실행시키면 결과값을 저장공간에 가지고 있다가 원하는 시기에순차적으로 fetch해 처리하여 해당 결과 셋을 프로그래밍적으로 접근할수 있게 도와주는 기능    묵시적커서(Implicit Cursor)와 명시적커서(Explicit Cursor)가 존재  2-4. DB  데이터가 저장되어 있는 장소3. JDBC 코딩의 흐름  JDBC 드라이버 로드  DB 연결  DB에 데이터를 읽거나 쓰기 (SQL문)  DB 연결 종료",
        "url": "/devlog/2020/01/06/java-3.html"
      }
      ,
    
      "devlog-2020-01-06-java-2-html": {
        "title": "[Java] 추상화 클래스와 인터페이스 간의 관계",
        "subtitle":"Abstract class VS Interface",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "java",
        "content": "  본 문서에서는 추상화 클래스와 인터페이스의 공통점 및 차이에 대해 알아보도록 한다.  출처: https://bit.ly/2ZwNFGa1. 공통점  abstract class(추상 클래스)와 interface(인터페이스) 는 선언만 있고 구현 내용이 없는 클래스  자기 자신이 new를 해서 객체를 생성할 수 없으며,추상클래스를 extends 받거나, interface를 implements 한 자식만이 객체를 생성 가능  상속 받은 자식이 구현을 반드시 하도록 해야할 때 사용  선언된 type과 자식의 type이 같아야 함2. 차이점  추상화 클래스:          추상클래스의 정의는 abstract 메서드가 하나라도 존재하는 클래스를 일컫음(일부 구현된 매서드 + 구현 안된 추상화 매서드)      추상클래스를 상속받는 클래스는 반드시 추상 매서드를 구현해야 함      extends를 통해 부모 클래스를 상속        인터페이스:          인터페이스는 구현체 없이, 매서드에 대한 명세만 존재      인터페이스를 상속받는 클래스에서는 반드시 인터페이스에 있는 메소드를 모두 구현해야 함      implements를 통해 여러 개의 인터페이스를 구현      추상클래스는 단일상속이지만 interface는 다중 상속이 가능(extends + implements)      ",
        "url": "/devlog/2020/01/06/java-2.html"
      }
      ,
    
      "devlog-2020-01-06-java-1-html": {
        "title": "[Java] try~catch~finally return문 위치에 따른 결과",
        "subtitle":"문법",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "java",
        "content": "java에서 try ~ catch ~ finally 문에서 return 위치에 따른 결과  본 문서에서는 return 문의 위치에 따라 어떤 결과가 나오는지 살펴보도록 한다.  출처: https://bit.ly/2MGVKWY1. return이 try 문 안에 있을 경우public class TryCatchFinallyTrick {    public static void main(String[] args) {        System.out.println(\"The output is: \" + getName());    }    static int getName(){        int a = 3;        try{            System.out.println(\"I am try\");            a = 4;            return a;        } catch(Exception e){            System.out.println(\"I am catch\");            a = 5;        } finally {            System.out.println(\"I am finally.\");            a = 6;        }    }}  위의 예제 코드를 보며 실행 결과를 예측해보면 대부분 6이라 생각할 것이다.하지만 우리의 예상과는 달리 실행결과는 아래와 같다.          [실행결과] I am try  I am finally. The output is: 4        어째서 이런 결과가 발생할까?다른 예제를 통해 좀 더 깊게 살펴보도록 하자.2. return이 fianlly 문 안에 있을 경우public class TryCatchFinallyTrick2 {    public static void main(String[] args) {        System.out.println(\"The output is: \" + getName());    }    static String getName(){        String  name = \"a\";        try{            System.out.println(\"I am try\");            name = \"try\";            return name;        } catch(Exception e){            System.out.println(\"I am catch\");            name = \"catch\";        } finally {            System.out.println(\"I am finally.\");            name = \"finally\";            return name;        }    }}  또 다른 예제 코드를 보면, 위의 코드에서는 finally와 try 문 두 군데에 return이 위치함을 알 수 있다.  위와 같은 상황에서는 과연 어떤 실행결과를 출력할 것인가?  [실행결과]I am tryI am finally.The output is: finally",
        "url": "/devlog/2020/01/06/java-1.html"
      }
      ,
    
      "devlog-2019-12-30-spring-18-html": {
        "title": "[Spring] Spring Security",
        "subtitle":"첫걸음 - 18",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "0. 기본 보안 개념인증(Authentication)은 주체(Principal)의 신원(Identity)을 증명하는 과정  주체(Principal): 유저, 기기, 시스템 등          주로 유저(사용자)        크레덴셜(Credential): 주체가 인증을 위해 제시하는 신원 증명 정보          주체가 유저일 경우 주로 Password        인가(Authorization, 권한부여): 인증을 마친 유저에게 권한을 부여하여 특정 리소스에 접근을 허용          반드시 인증 이후에 수행        접근 통제(Access control, 접근 제어): 어플리케이션 리소스에 접근하는 행위를 제어          접근 통제 결정(Access control decision, 접근 제어 결정)이 뒤따름      1. URL 접근  Spring Security는 HTTP 요청에 서블릿 필터를 적용해 보안을 처리          AbstractSecurityWebApplicationInitializer 베이스 클래스를 상속해 구현        WebSecurityConfigurerAdapter 구성 어댑터의 configure() 매서드를 이용해 다음과 같은 기본 보안 설정 적용 가능          폼 기반 로그인 서비스      HTTP 기본 인증      로그아웃 서비스      익명 로그인      서블릿 API 연계      CSFR      보안 헤더          // TodoSecurityInitalizer.java  public class TodoSecurityInitializer extends AbstractSecurityWebApplicationInitializer {  public TodoSecurityInitializer() {      super(TodoSecurityConfig.class);  }  }                            1-1. URL 접근 보안  WebSecurityConfigurerAdapter 클래스의 configure(HttpSecurity http) 매서드는 기본적으로 다음의 특징을 지님          anyRequest().authenticated()해서 매번 요청이 들어올 때마다 반드시 인증을 받도록 강제함      HTTP 기본인증(httpBasic()) 및 폼 기반 로그인(formLogin()) 기능은 기본적으로 킴      로그인 페이지를 만들지 않으면 기본 로그인 페이지를 보이도록 구성            configure(HttpSecurity http) 매서드를 오버라이딩하여 더 정교한 인가 규칙을 적용 가능      // TodoSecurityConfig.java  @Configuration  @EnableWebSecurity  public class TodoSecurityConfig extends WebSecurityConfigurerAdapter {      @Override      protected void configure(AuthenticationManagerBuilder auth) throws Exception {          auth.inMemoryAuthentication()                  .withUser(\"user\").password(\"{noop}user\") // .password(\"user\")하면 인코딩 에러발생                  .authorities(\"USER\")                  .and()                  .withUser(\"admin\").password(\"{noop}admin\") // .password(\"admin\")하면 인코딩 에러발생                  .authorities(\"USER\", \"ADMIN\");      }      @Override      protected void configure(HttpSecurity http) throws Exception {          http.authorizeRequests() // URL 접근 보안의 시작                  .antMatchers(\"/todos*\").hasAuthority(\"USER\")                  .antMatchers(HttpMethod.DELETE, \"/todos*\").hasAuthority(\"ADMIN\")              .and()                  .formLogin()              .and()                  .csrf().disable();      }  }        URL 접근 보안은 authorizeRequests()부터 시작되며, 여러가지 매처를 통해 규칙을 지정가능          앞선 코드에서는 antMatchers로 규칙을 지정                  이때 “/todos*” 처럼 마지막에 와일드카드를 넣어줘야 쿼리 매개변수가 있는 URL도 걸림그렇지 않다면, 해커들이 아무 쿼리 변수나 덧붙여 URL 관문을 통과할 수 있음                      configure(AuthenticationManagerBuilder auth) 매서드를 통해 메모리에 유저 정보를 저장          이때, Spring5 부터 유저 정보를 메모리에 저장하면 PasswordEncoder를 찾지 못해 예외가 발생      이러한 예외를 방지하기 위해 앞선 코드처럼 {noop}를 붙여줌으로써, 내부적으로 NoOpPasswoedEncoder를 사용하겠다는 선언      위 클래스도 비권장 클래스라 좋은 방법은 아니지만, 실제 메모리에 정보를 저장하는 일은 거의 없으므로 임시사용        기본 접근 규칙 및 로그인 구성을 오버라이딩 했으므로, formLogin 기능을 다시 활성화 시켜줘야 함  앞선 코드처럼 구성하고, CSFR방어 기능을 키게 되면, 폼이 제대로 동작하지 않으므로 비활성화(활성방법 후술)1-2. CSRF 공격 방어  CSRF 방어기능은 스프링 시큐리티 기본 설정 그대로 켜두면 되지만, 필요시 csrf().disable() 로 해제 가능          CSRF 공격(Cross Site Request Forgery)은 웹 어플리케이션 취약점 중 하나로    인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격        Spring Security는 CsrfTokenRepository 인터페이스의 구현체를 이용해 토큰 값을 생성/보관하는 CsrfFilter를 추가  CSRF 방어기능이 켜진 상태로, 할 일을 완료하거나 삭제하려면 토큰이 없어서 실패          콘텐츠를 수정하는 요청을 할 때, 다음처럼 hidden input에 CSRF 토큰을 심어 서버에 재전송          &lt;input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/&gt;                            2. 웹 어플리케이션 로그인다음의 로그인 서비스는 HTTP 자동 구성을 활성화하면 자동 등록 되지만, 직접 커스터마이징 하는 경우 명시적으로 구성해야 함  예외 처리나 보안 컨텍스트 연계등 Spring Security 필수 기능      protected void configure(HttpSecurity http){      http.securityContext()          .and()          .exceptionHandling();  }        서블릿 API 연계 기능      protected void configure(HttpSecurity http){      http.servletApi();  }          2-1. HTTP 기본 인증  HTTP 기본 인증은 httpBasic()으로 구성  HTTP 기본 인증을 적용하면 대부분 브라우저는 로그인 대화상자를 띄우거나, 특정 로그인 페이지로 이동시킴      http      ...      .httpBasic();          2-2. 폼 기반 로그인  HTTP 기본 인증과 폼 기반 로그인을 동시에 활성화 할 경우, 폼 기반 로그인이 우선시 됨      formLogin() 매서드로 로그인 서비스를 구현하면, 유저가 로그인 정보를 입력하는 폼 페이지가 자동 랜더링 됨        http      ...      .formLogin();              기본 로그인 페이지가 아닌 다른 로그인 페이지를 사용하고 싶다면, login.jsp 파일을 작성 후 wepapp 루트디렉토리에 위치시킴          WEB-INF 안에 넣으면, USER는 접근조차 할 수 없음        커스텀 로그인 페이지의 URL을 다음처럼 loginPage()의 인수로 전달하고, 기본 리다이렉트 페이지 및 에러처리      http      ...      .formLogin()      .loginPage(\"/login.jsp\")      .defaultSuccessUrl(\"/messageList\")      .failureUrl(\"login.jsp?error=true\");        요청 URL에 쿼리 매개변수 error이 존재하는지 체크하고 있다면 세션 속성값을 이용해 다음처럼 최근 에러 메세지를 표시      &lt;form&gt;      ...      &lt;c:if test=\"${not empty parma.error}\"&gt;          Reason: ${sessionScope[\"SPRING_SECURITY_LAST_EXCEPTION\"].message}      ...  &lt;/form&gt;          2-3. 로그아웃 서비스  로그아웃 기능은 logout() 매서드로 구현      http      ...      .logout();        기본 URL은 /logout 이며, POST 요청일 경우에만 작동하며 로그아웃한 유저는 기본 경로(초기화면)으로 이동  다른 URL로 보내고 싶다면, 다음처럼 logoutSuccessUrl() 매서드에 지정      http      ...      .logout().logoutSuccessUrl(\"/logout.success.jsp\")      .and()      .headers();        로그아웃 이후 뒤로가기 버튼을 눌렀을 때, 브라우저가 페이지를 캐싱함으로 인해 로그인된 페이지로 이동하는 문제 발생          headers() 매서드로 보안 헤더를 활성화하여 브라우저의 페이지 캐싱을 방지      캐싱 뿐 아니라, content sniffing 방지 및 X-Frame 방어를 활성화하는 역할도 수행                  content sniffing: 바이트 스트림을 읽어 그 안의 데이터 형식을 추론하는 해킹, MIME 스니핑이라고도 불림X-Frame: 클릭 재킹은 웹 사용자를 클릭하여 사용자가 클릭 한 것으로 보이는 것과 다른 것을 클릭하여기밀 정보를 공개하거나 자신의 컴퓨터를 제어하는 악의적인 기법이다.                    2-4. 익명 로그인 구현  익명 로그인 서비스는 anonymous() 매서드에 유저명과 익명유저의 권한을 주어 다음과 같이 지정      http      ...      .and()      .anonymous().principal(\"quest\").authorities(\"ROLE_GUEST\");      // 간단하게 .anonymous()로 동작가능          2-5. Remember Me 구현  Remember Me 기능은 rememberMe() 매서드를 통해 구현          유저명, 패스워드, 리맴버 미 만료 시각, 개인키를 하나의 토큰으로 인코딩해 유저 브라우저 쿠키로 저장      재접속시 이 토큰값을 가져와 유저를 자동 로그인 시킴          http  ...  .rememberMe();                          그러나 정적인 리맴버 미 토큰은 해커가 얼마든지 빼낼 수 있어 잠재적인 보안 이슈가 존재이에 Spring Security는 토큰을 rolling 시키는 기술을 지원하며 토큰 저장을 위한 별도의 DB가 필요                    3. 유저 인증하기  Spring Security에서는 연쇄적으로 연결되 하나 이상의 인증 공급자를 이용해 인증을 수행하며, 모든 공급자의 인증 과정을 통과해야 함  대부분의 인증 공급자는 유저 세부 내용을 저장소(메모리, RDBMS, LDAP 저장소)등에서 가져온 결과와 대조하여 인증을 수행  유저 세부 내용을 저장할 때 패스워드는 해커의 공격을 당할 수 있어 주로 단방향 해시 함수를 이용해 암호화하여 저장          Spring Security는 패스워드 인코딩 알고리즘으로 MD5, SHA등을 지원        유저가 로그인할 때마다 저장소에서 조회하면 성능 저하를 유발하므로, Spring Security는 로컬 메모리와 저장 공간에 캐싱하는 기능 제공3-1. In memory 방식으로 유저 인증  유저가 적고, 정보를 수정할 일이 없을 경우      // TodoSecurityConfig.java  @Configuration  @EnableWebSecurity  public class TodoSecurityConfig extends WebSecurityConfigurerAdapter {      // 한 사람씩 withUser 매서드를 이용하여 추가      @Override      protected void configure(AuthenticationManagerBuilder auth) throws Exception {          auth.inMemoryAuthentication()                  .withUser(\"admin@ya2do.io\").password(\"secret\").authorities(\"ADMIN\",\"USER\").and()                  .withUser(\"marten@@ya2do.io\").password(\"{noop}user\").authorities(\"USER\").and()                  .withUser(\"jdoe@does.net\").password(\"unknown\").disabled(true).authorities(\"USER\");      }      ...          3-2. DB 조회 결과에 따라 유저 인증  유저의 세부 내용은 DB에 저장하는 경우가 압도적  Spring Security는 다음과 같은 두 매서드를 통해 SQL을 이용하는 조회 기능을 제공          usersByUserNameQuery()      authoritiesByUsernameQuery()          // TodoSecurityConfig.java  ...  @Override  protected void configure(AuthenticationManagerBuilder auth) throws Exception {      auth          .jdbcAuthentication()              .dataSource(dataSource())              .usersByUsernameQuery(\"SELECT username, password, 'true' as enabled FROM member WHERE username = ?\")              .authoritiesByUsernameQuery(                      \"SELECT member.username, member_role.role as authorities \" +                              \"FROM member, member_role \" +                              \"WHERE  member.username = ? AND member.id = member_role.member_id\");  }                            3-3. 패스워드 암호화  In memory 방식의 경우, passwordEncoder() 매서드에 패스워드 인코더를 지정해 암호화하여 저장 가능      // TodoSecurityConfig.java      ...      @Bean      public BCryptPasswordEncoder passwordEncoder() {          return new BCryptPasswordEncoder();      }      @Override      protected void configure(AuthenticationManagerBuilder auth) throws Exception {          auth              .jdbcAuthentication()                  .passwordEncoder(passwordEncoder())                  .dataSource(dataSource());      }              BCrypt: 단방향 해시 알고리즘으로 설계시 부터 패스워드 저장을 목적으로 설계되어 강력함      3-4. LDAP 저장소 조회 결과에 따라 유저 인증  LDAP: LDAP는 조직이나, 개체, 그리고 인터넷이나 기업 내의 인트라넷 등  네트웍 상에 있는 파일이나 장치들과 같은 자원 등의 위치를 찾을 수 있게 해주는 소프트웨어 프로토콜      LDAP의 저장소 구성은 ldapAuthentication() 매서드가 담당    유저 및 그룹을 검색하는 필터와 베이스는 콜백 매서드로 지정    Spring Security는 각 그룹마다 ROLE_ 접두어를 붙혀 권한으로 사용      // TodoSecurityConfig.java  ...  @Override  protected void configure(AuthenticationManagerBuilder auth) throws Exception {      auth          .ldapAuthentication()              .contextSource()                  .ldif(\"\")                  .url(\"ldap://ldap-server:389/dc=springrecipes,dc=com\")                  .managerDn(\"cn=Directory Manager\").managerPassword(\"ldap\")          .and()              .userSearchFilter(\"uid={0}\").userSearchBase(\"ou=people\")              .groupSearchFilter(\"member={0}\").groupSearchBase(\"ou=groups\")              .passwordCompare()                  .passwordEncoder(new BCryptPasswordEncoder())                  .passwordAttribute(\"userPassword\");  }              LDAP을 지원하는 자바 기반 오픈소스 디렉토리 서비스 엔진인 OpenDS는 기본적으로 SSHA를 사용하므로,LdapShaPasswordEncoder를 지정해야 함              SSHA: Salted Secure Hash Algorithm로서, 기존의 해싱의 단점(동일한 문자열에 대해 같은 해쉬값)을 극복하는 방법으로   무작위 문자열을 추가해 같은 문자열에 대해 매번 다른 해쉬값을 가지도록 하여 보안성을 높이는 기법            4. 접근 통제 결정      접근 통제 결정은 유저가 리소스에 접근 가능한지 판단하는 행위로서 유저 인증 상태와 리소스 속성에 따라 좌우되며,Spring Security에서는 AccessDecisionManager 인터페이스 구현을 통해 이를 판단    필요 시 직접 인터페이스를 구현할 수도 있지만, Spring Security는 거수 방식으로 동작하는 다음 3가지 결정 관리자를 기본 제공          AffirmativeBased: 하나의 거수기만 거수해도 접근 허용      ConsensusBased: 거수기 전원이 만장일치해야 접근 허용      UnanimousBased: 거수기 전원이 기권 또는 찬성해야 접근 허용(적어도 반대는 없어야 함)            위의 결정 관리자를 이용하기 위해, 접근 통제 결정에 대한 거수기 그룹을 구성해야 하며각 거수기는 AccessDecisionVoter 인터페이스를 구현하고, 유저의 리소스 접근에 대해 찬성, 기권, 반대중 하나의 의사를 표명    별도의 결정 관리자를 명시하지 않으면, AffirmativeBased를 기본 접근 통제 결정 관리자로 임명하고 다음 두 거수기를 구성          RolVoter: 유저 롤을 기준으로 접근 허용 여부를 거수, ROLE_ 접두어(다른 접두어도 가능)로 시작하는 접근 속성만 처리      AuthenticatedVoter: 유저 인증 레벨을 기준으로 접근 허용 여부를 거수하며, 다음 세 가지 접근 속성만 처리              IS_AUTHENTICATED_FULLY      IS_AUTHENTICATED_REMEMBERED      IS_AUTHENTICATED_ANONYMOUSLY                  위 3가지는 순서대로 인증레벨이 정해지며(1번이 가장 높음), 유저의 인증 레벨이 리소스 접근 레벨보다 높으면 찬성                    4-1. 표현식을 이용해 접근 통제 결정  Spring식 표현 언어인 SpEL(Spring Expression Language)를 사용  and, or, not등을 조합해 강력하고 유연한 표현식 사용 가능      // TodoSecurityConfig.java      ...      @Override      protected void configure(HttpSecurity http) throws Exception {      /*          * 유저가 ADMIN 롤을 가지고 있거나, 로컬 머신에서 로그인한 유저일 경우 삭제 권한 부여          * 유저 IP주소에 따라 허용 여부를 결정            * 주소가 127.0.0.1 또는 0:0:0:0:0:0:0:1 일때 찬성, 그렇지 않으면 반대          */          http.authorizeRequests()                  .antMatchers(\"/todos*\").hasAuthority(\"USER\")                  .antMatchers(HttpMethod.DELETE, \"/todos*\").hasAuthority(\"ADMIN\")                  .antMatchers(\"/messageDelete*)              .access(\"hasRole('ROLE_ADMIN') or hasIpAddress('127.0.0.1') or                    hasIpAddress('0:0:0:0:0:0:0:1')\")              ...      }            Spring Security는 앞선 내장 함수를 제공하지만, SecurityExpressionOperations 인터페이스를 구현해 직접 등록해 사용 가능      // ExtendWebSecurityExpressionRoot.java  /*  * 이 클래스가 상속받은 WebSecurityExpressionRoot 클래스의   * 상위 클래스인 SecurityExpressionRoot 클래스가   * SecurityExpressionOperations 인터페이스 구현 클래스  */  public class ExtendedWebSecurityExpressionRoot extends WebSecurityExpressionRoot {              public ExtendedWebSecurityExpressionRoot(Authentication a, FilterInvocation fi) {          super(a, fi);      }  /*      * 로컬 머신 로그인 여부를 체크하는 매서드를 구현해 추가      * 커스텀 표현식으로 원하는 표현식 유연하게 추가 가능       */      public boolean localAccess() {          return hasIpAddress(\"127.0.0.1\") || hasIpAddress(\"0:0:0:0:0:0:0:1\");      }  }        위와 같은 커스텀 표현식을 등록해 사용하기 위해서, SecurityExpressionHandler 인터페이스 구현체를 생성해야 함      // ExtendWevSecurityExpressionHandler.java  public class ExtendedWebSecurityExpressionHandler extends DefaultWebSecurityExpressionHandler {      private AuthenticationTrustResolver trustResolver = new AuthenticationTrustResolverImpl();      @Override      protected SecurityExpressionOperations       createSecurityExpressionRoot(Authentication authentication, FilterInvocation fi) {          // 앞선 코드에서 생성한 ExtendedWebSecurityExpressionRoot 인스턴스 생성          ExtendedWebSecurityExpressionRoot root =                  new ExtendedWebSecurityExpressionRoot(authentication, fi);          root.setPermissionEvaluator(getPermissionEvaluator());          root.setTrustResolver(trustResolver);          root.setRoleHierarchy(getRoleHierarchy());          return root;      }      ...  }        createSecurityExpressionRoot() 매서드를 오버라이드해 구현한 인스턴스를 생성  커스텀 표현식 핸들러를 다음처럼 expressionHandler() 매서드에 지정하여 커스텀 표현식을 활용      // TodoSecurityConfig.java      ...      @Override      protected void configure(HttpSecurity http) throws Exception {          http.authorizeRequests()                  .expressionHandler(new ExtendedWebSecurityExpressionHandler())                  .antMatchers(\"/todos*\").hasAuthority(\"USER\")                  .antMatchers(DELETE, \"/todos*\")                  .access(\"hasRole('ROLE_ADMIN') or localAccess()\") // 커스텀 표현식 사용              .and()      ...          4-2. Sprig Bean을 표현식에 넣어 접근 통제 결정  앞선 방식으로 Spring Security 클래스를 상속후 매서드를 오버라이드해 사용할 수 있지만, 비권장  표현식 내부에 커스텀 클래스를 만들어 사용하여, @ 어노테이션을 통해 Spring Bean으로 사용      // AccessChecker.java  public class AccessChecker {      public boolean hasLocalAccess(Authentication authentication) {          boolean access = false;          if (authentication.getDetails() instanceof WebAuthenticationDetails) {              WebAuthenticationDetails details = (WebAuthenticationDetails) authentication.getDetails();              String address = details.getRemoteAddress();              access = address.equals(\"127.0.0.1\") || address.equals(\"0:0:0:0:0:0:0:1\");          }          return access;      }  }        AccessChecker 클래스는 앞선 커스텀 표현식 핸들러와 동일한 기능을 제공하지만, Spring Security 클래스를 상속하지 않음  다음과 같은 방법으로 @accessChecker.hasLocalAccess(authentication) 표현식으로 호출 가능      // TodoSecurityConfig.java      ...      // 사용할 표현식 클래스를 Spring Bean으로 등록      @Bean      public AccessChecker accessChecker() {          return new AccessChecker();      }      @Override      protected void configure(HttpSecurity http) throws Exception {          http.authorizeRequests()                  .antMatchers(\"/todos*\").hasAuthority(\"USER\")                  .antMatchers(HttpMethod.DELETE, \"/todos*\")                  // 커스텀 매서드를 어노테이션을 통해 Bean을 부름으로써 사용                    .access(\"hasAuthority('ADMIN') or @accessChecker.hasLocalAccess(authentication)\")              .and()      ...          5. 매서드 호출 보안Spring Security는 빈 인터페이스나 구현 클래스에서 대상 매서드에 다음의 어노테이션을 선언함으로 매서드 호출을 보안  @Secured  @PreAuthorize / @PostAuthorize  @PreFilter / @PostFilter위와 같은 어노테이션을 붙인 후, 구성 클래스 레벨에 @EnableGlobalMethodSecurity를 붙이면 보안 모드로 작동5-1. 어노테이션을 붙어 매서드 보안  @Secured 어노테이션을 매서드에 붙이면 보안이 적용      // TodoServiceImpl.java  @Service  @Transactional  class TodoServiceImpl implements TodoService {      ...      @Override      @Secured(\"USER\")      public List&lt;Todo&gt; listTodos() {...}      @Override      @Secured(\"USER\")      public void save(Todo todo) {...}      @Override      @Secured(\"USER\")      public void complete(long id) {...}      @Override      @Secured({\"USER\", \"ADMIN\"})      public void remove(long id) {...}      @Override      @Secured(\"USER\")      public Todo findById(long id) {...}  }        각 매서드에 @Secured 어노테이션을 붙인 후, String[] 타입의 access 속성에 매서드별 접근 허용 권한 설정  매서드 보안을 활성화하기 위해 구성 클래스에 다음처럼 @EnableGlobalMethodSecurity를 붙이고, 속성값 설정      @Configuration  @EnableGlobalMethodSecurity(securedEnable = true)  public class TodoWebconfiguration{...}          5-2. 어노테이션 + 표현식으로 매서드 보안(@PreAuthorize, @PostAuthorize)  조금 더 정교한 보안 규칙은 @PreAuthorize, @PostAuthorize 같은 어노테이션에 SpEL 기반의 보안 표현식을 적용  이 두 가지 어노테이션을 사용하기 위해 @EnableGlobalMethodSecurity의 prePostEnabled 속성을 true로 설정      @Configuration  @EnableGlobalMethodSecurity(prePostEnabled = true)  public class TodoWebconfiguration{...}          // TodoServiceImple.java  @Service  @Transactional  class TodoServiceImpl implements TodoService {      ...      @Override      @PreAuthorize(\"hasAuthority('USER')\")      public List&lt;Todo&gt; listTodos() {...}      @Override      @PreAuthorize(\"hasAuthority('USER')\")      public void save(Todo todo) {...}      @Override      @PreAuthorize(\"hasAuthority('USER')\")      public void complete(long id) {...}      @Override      @PreAuthorize(\"hasAnyAuthority('USER', 'ADMIN')\")      public void remove(long id) {...}  /*      * returnObject 표현식으로 결과를 처리      * 할 일을 등록한 유저 이외의 다른 유저가 호출해 Todo 객체에 접근하면 보안 예외를 던짐      */      @Override      @PreAuthorize(\"hasAuthority('USER')\")      @PostAuthorize(\"returnObject.owner == authentication.name\")      public Todo findById(long id) {...}  }        @PreAuthorize는 매서드 호출 직전, @PostAuthorize는 매서드 호출 직후 각각 동작  보안 표현식을 사용하거나, returnObject 표현식으로 매서드 호출 결과를 받아올 수 있음5-3. 어노테이션 + 표현식으로 거르기(@PreFilter, @PostFilter)  앞선 두 어노테이션은 보안 규칙에 맞지 않을 경우 에러를 던지지만, @PreFilter/@PostFilter는 단순히 접근 권한을 체크  TodoList에 구현된 전체 데이터는 ADMIN만 볼 수 있고, USER는 본인의 일만 열람 가능하도록 다음처럼 제한을 둠      // TodoServiceImple.java      ...      @Override      @PreAuthorize(\"hasAuthority('USER')\")      @PostFilter(\"hasAnyAuthority('ADMIN') or filterObject.owner == authentication.name\")      public List&lt;Todo&gt; listTodos() {          return todoRepository.findAll();      }              @PreFilter/@PostFilter는 매서드 입출력을 필터링하는 편리한 수단이지만,결과가 대용량일 경우 성능저하를 심각하게 유발하므로 주의      6. 뷰에서 보안 처리Spring Security가 제공하는 보안 처리용 JSP 태그 라이브러리를 사용  JSP 스크립트릿 (&lt;% … %&gt;)을 사용하여 Spring Security API를 호출할 수 있지만, 좋은 방법이 아니라 비권장6-1. 인증 정보 표시  뷰 페이지 헤더에 주체명과 허용 권한을 설정      &lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;  &lt;%@ taglib prefix=\"sec\" uri=\"http://www.springframework.org/security/tags\" %&gt;        &lt;sec:authentication&gt; 태그를 이용하면, 현재 유저의 Authentication 객체를 가져올 수 있어뷰에서 원하는 프로퍼티를 property 속성에 명시하는 방법으로 랜더링 가능      &lt;!-- 유저 주체명은 name 프로퍼티로 가져와 표시가능 --&gt;  &lt;h4&gt;To-dos for &lt;sec:authentication property=\"name\" /&gt;&lt;/h4&gt;        위와 같이 직접 가져와 랜더링해도 되지만, JSP 변수에 프로퍼티 값을 옮겨담아 var 속성에 이름을 지정 가능      &lt;!-- 허용 권한 목록을 authorities 변수에 담고, &lt;c:forEach&gt; 태그로 하나씩 꺼내 랜더링  --&gt;  &lt;sec:authentication property=\"authorities\" var=\"authorities\" /&gt;  &lt;ul&gt;      &lt;c:forEach items=\"${authorities}\" var=\"authority\"&gt;          &lt;li&gt;${authority.authority}&lt;/li&gt;      &lt;/c:forEach&gt;  &lt;/ul&gt;          6-2. 뷰 콘텐트를 조건부 랜더링  &lt;sec:authorize&gt; 태그를 이용해 유저 권한에 따라 뷰 콘텐트를 다음 세 방법으로 조건부 표시 가능  전부 지니는 경우     &lt;!-- ROLE_ADMIN, ROLE_USER 권한을 모두 지녔을 경우만 태그로 감싼 부분을 랜더링 --&gt; &lt;td&gt;     &lt;sec:authorize access=\"hasRole('ROLE_ADMIN') and hasRole('ROLE_USER')\"&gt;         ${todo.owner}     &lt;/sec:authorize&gt; &lt;/td&gt;        하나만 지녀도 되는 경우     &lt;!-- 두 권한 중 하나만 가져도 랜더링하려면 다음처럼 hasAnyRole 사용 --&gt; &lt;td&gt;     &lt;sec:authorize access=\"hasAnyRole('ROLE_ADMIN', 'ROLE_USER')\"&gt;         ${todo.owner}     &lt;/sec:authorize&gt; &lt;/td&gt;        지니지 않을 경우     &lt;!-- 주어진 권한을 모두 갖고 있지 않은 유저에게만 보이게 하는 경우 --&gt; &lt;td&gt;     &lt;sec:authorize access=\"!hasRole('ROLE_ADMIN') and !hasRole('ROLE_USER')\"&gt;         ${todo.owner}     &lt;/sec:authorize&gt; &lt;/td&gt;          7. 도메인 객체 보안 처리Spring Security는 자체로 ACL(Access Control List, 접근 통제 목록)을 설정하는 전용 모듈을 지원하며,ACL에는 도메인 객체와 연결하는 ID를 비롯해 여러 개의 ACE(Access Control Entry, 접근 통제 엔트리)가 포함되며 ACE는 다음처럼 구성  퍼미션(Permission, 인가받은 권한): 각 비트 값은 특정 퍼미션을 의미하는 비트 마스크이며 각 비트는(READ: 0 or 1) (WRITE: 1 or 2) (CREATE: 2 or 4) (DELETE: 3 or 8) (ADMINISTRATION: 4 or 16)으로 구성          다섯 가지 기본 퍼미션과 해당하는 비트의 쌍으로 표현이 중 안쓰는 나머지 비트를 이용해 퍼미션을 임의로 지정 가능        보안 식별자(SID, Security Identity): 각 ACE는 특정 SID에 대한 퍼미션을 지님7-1. ACL 서비스 설정  Spring은 JDBC로 RDBMS에 접속하여 ACL 데이터를 저장/조회하는 기능을 기본 지원  Spring Security는 테이블에 저장된 ACL 데이터에 접근할 수 있는 고성능 JDBC 구현체 및 API를 지원하며,ACL은 도메인 객체마다 별도로 둘 수 있어 ACL 객체를 캐싱하는 기능을 제공          Class path root에 있는 ehcache.xml 파일에 설정          &lt;!-- ehcache.xml --&gt;  ...  &lt;cache name=\"aclCache\"      maxElementsInMemory=\"1000\"      eternal=\"false\"      timeToIdleSeconds=\"600\"      timeToLiveSeconds=\"3600\"      overflowToDisk=\"true\"          /&gt;                      어플리케이션에서 사용할 ACL 모듈은 Java로 구성이 안되므로, Bean 그룹으로 구성후 등록해야 하므로 설정 파일을 작성하고 위치 등록      public class TodoSecurityInitializer extends AbstractSecurityWebApplicationInitializer {      public TodoSecurityInitializer() {          super(TodoSecurityConfig.class, TodoAclConfig.class); // TodoAclConfig 파일 위치 등록      }  }        Spring Security에서 ACL 서비스 작업은 AclService, MutableAclService 두 인터페이스로 정의      AclService는 읽기 작업을, 그 하위 인터페이스 MutableAcleService는 나머지(생성, 수정, 삭제)를 각각 기술      // TodoAclConfig.java  @Configuration  public class TodoAclConfig {      private final DataSource dataSource;      public TodoAclConfig(DataSource dataSource) {          this.dataSource = dataSource;      }      @Bean      public AclEntryVoter aclEntryVoter(AclService aclService) {          return new AclEntryVoter(aclService, \"ACL_MESSAGE_DELETE\", new Permission[]{BasePermission.ADMINISTRATION, BasePermission.DELETE});      }      @Bean      public EhCacheCacheManager ehCacheManagerFactoryBean() {          return new EhCacheCacheManager();      }      @Bean      public AuditLogger auditLogger() {          return new ConsoleAuditLogger();      }      // 자신이 가지고 있는 Permission 값으로 주어진 SID에 ACL 접근을 허용할지를 결정      @Bean      public PermissionGrantingStrategy permissionGrantingStrategy() {          return new DefaultPermissionGrantingStrategy(auditLogger());      }  /*       * 각 프로퍼티 카테고리별로 필요한 권한을 지정하는 방식으로        * 주체가 특정 ACL 프로퍼티를 변경할 권한을 갖고 있는지 판단        * 해당 코드에서는 ADMIN 권한을 지닌 유저만 ACL 소유권, 감사 세부등 ACL/ACE 정보 수정 가능      */      @Bean      public AclAuthorizationStrategy aclAuthorizationStrategy() {          return new AclAuthorizationStrategyImpl(new SimpleGrantedAuthority(\"ADMIN\"));      }      @Bean      public AclCache aclCache(CacheManager cacheManager) {          return new SpringCacheBasedAclCache(cacheManager.getCache(\"aclCache\"), permissionGrantingStrategy(), aclAuthorizationStrategy());      }  /*      * 룩업 성능을 높이고자 고급 DB 기능을 사용하려면       * 직접 LookupStrategy 인스턴스를 구현해 룩업 전략을 만들어 사용      */      @Bean      public LookupStrategy lookupStrategy(AclCache aclCache) {          return new BasicLookupStrategy(this.dataSource, aclCache, aclAuthorizationStrategy(), permissionGrantingStrategy());      }          /*      * ACL 구성 파일의 핵심이 되는 JdbcMutableAclService 인스턴스      * 첫 번째 인수는 ACL 데이터를 저장할 DB에 사용하는 데이터 소스        * 두 번째 인수는 표준/호환 SQL문으로 기본 룩업을 수행하는 LookupStrategy 인터페이스 구현체      * 세 번째 인수는 ACL에 적용할 캐시 인스턴스        */      @Bean      public AclService aclService(LookupStrategy lookupStrategy, AclCache aclCache) {          return new JdbcMutableAclService(this.dataSource, lookupStrategy, aclCache);      }      @Bean      public AclPermissionEvaluator permissionEvaluator(AclService aclService) {          return new AclPermissionEvaluator(aclService);      }  }          7-2. 도메인 객체에 대한 ACL 관리  Back-end 서비스와 DAO에서는 DI를 이용해 앞서 정의한 ACL 서비스를 이용해 도메인 객체용 ACL을 관리          Todo-List에서는 할 일을 등록/삭제할 때마다 각각 ACL을 생성/삭제해야 함          // TodoServiceImple.java  @Service  @Transactional  class TodoServiceImpl implements TodoService {      ...  /*      * 유저가 할 일을 등록하면 할 일 ID와 ACL 객체의 ID를 이용해 ACL을 생성함      * 생성한 ACL에 대해서는 해당 USER와 ADMIN이 READ, WRITE, DELETE를 할 수 있도록 삽입      */      @Override      @PreAuthorize(\"hasAuthority('USER')\")      public void save(Todo todo) {          this.todoRepository.save(todo);          ObjectIdentity oid = new ObjectIdentityImpl(Todo.class, todo.getId());          MutableAcl acl = mutableAclService.createAcl(oid);          acl.insertAce(0, READ, new PrincipalSid(todo.getOwner()), true);          acl.insertAce(1, WRITE, new PrincipalSid(todo.getOwner()), true);          acl.insertAce(2, DELETE, new PrincipalSid(todo.getOwner()), true);          acl.insertAce(3, READ, new GrantedAuthoritySid(\"ADMIN\"), true);          acl.insertAce(4, WRITE, new GrantedAuthoritySid(\"ADMIN\"), true);          acl.insertAce(5, DELETE, new GrantedAuthoritySid(\"ADMIN\"), true);      }      // 유저가 등록한 할 일을 삭제하면 해당 ACL도 함께 삭제      @Override      @PreAuthorize(\"hasAnyAuthority('USER','ADMIN')\")      public void remove(long id) {          todoRepository.remove(id);          ObjectIdentity oid = new ObjectIdentityImpl(Todo.class, id);          mutableAclService.deleteAcl(oid, false);      }      ...  }        JdbcMutableAclService 입장에서는 호출 매서드 쪽에서 트랜잭션을 걸어놓아야 그 트랜잭션 안에서 SQL문 수행 가능          따라서, ACL을 관리하는 앞선 매서드의 @Transactional 어노테이션을 붙임        WebMvcConfigurer 구현 클래스에서는 다음처럼 트랜잭션 관리자를 추가하고, @EnableTransactionManagement를 붙임      @Configuration  ...  @EnableTransactionManagement  public class TodoWebConfig implements WebMvcConfigurer {      ...      @Bean      public DataSourceTransactionManager transactionManager(DataSource dataSource) {          return new DataSourceTransactionManager(dataSource);      }  }          7-3. 표현식을 이용해 접근 통제 결정  도메인 객체마다 ACL을 부착했으므로, 이 객체에 속한 매서드마다 접근 통제 결정을 내리는 것이 가능          유저가 할 일을 삭제하려고 하면 ACL을 보고 그 유저가 정말 삭제할 권한이 있는지 체크 가능        ACL을 직접 구현할 필요 없이 다음 애너테이션으로 간편하게 구현 가능          @PreAuthorize/@PreFilter로 유저의 매서드 실행, 특정 매서드 인수의 사용 권한이 있는지 체크 가능      @PostAuthorize/@PostFilter로 유저가 매서드 실행 결과에 접근하거나,ACL에 따라 그 결과를 필터링 할 수 있는지 체크 가능        이러한 애너테이션은 @EnableGlobalMethodSecurity의 prePostEnabled 속성을 true로 설정해 사용 가능      @EnableGlobalMethodSecurity(prePostEnabled = true)        표현식을 사용하여 ACL로 매서드를 보안하려면 커스텀 퍼미션 평가기를 다음처럼전역 레벨에서 매서드 보안을 활성화하는 구성 클래스에 반드시 설정      // TodoWebConfig.java  @Configuration  ...  public class TodoWebConfig implements WebMvcConfigurer {      ...      @Bean      public AclPermissionEvaluator permissionEvaluator(AclService aclService) {          return new AclPermissionEvaluator(aclService);      }  }        애너테이션과 표현식을 함께 사용한 최종 클래스는 다음과 같다.      @Service  @Transactional  class TodoServiceImpl implements TodoService {      ...  /*      * @PreAuthorize는 유저가 매서드를 수행할 퍼미션을 갖고 있는지 체크        * #message는 message라는 이름의 매서드 인수를 지칭        * hasPermission은 Spring Security의 기본 표현식        * @PostFilter는 컬렉션 중 현재 유저가 읽을 권한이 없는 원소를 제거, 표현식에 사용된 filterOject가 컬렉션의 원소        * @PostAuthorize는 하나의 결과값이 사용 가능한지(유저가 그에 맞는 권한을 지니는지)를 체크, 반환값은 returnObject 키워드로 사용      */      @Override      @PreAuthorize(\"hasAuthority('USER')\")      @PostFilter(\"hasAnyAuthority('ADMIN') or hasPermission(filterObject, 'read')\")      public List&lt;Todo&gt; listTodos() {...}      @Override      @PreAuthorize(\"hasAuthority('USER')\")      public void save(Todo todo) {...}      @Override      @PreAuthorize(\"hasPermission(#id, 'com.apress.springrecipes.board.Todo', 'write')\")      public void complete(long id) {...}      @Override      @PreAuthorize(\"hasPermission(#id, 'com.apress.springrecipes.board.Todo', 'delete')\")      public void remove(long id) {...}      @Override      @PostFilter(\"hasPermission(filterObject, 'read')\")      public Todo findById(long id) {...}  }      ",
        "url": "/devlog/2019/12/30/spring-18.html"
      }
      ,
    
      "devlog-2019-12-30-spring-17-html": {
        "title": "[Spring] 프로필과 프로퍼티 파일",
        "subtitle":"첫걸음 - 17",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 프로필개발 목적 설정과 실 서비스 복적의 설정을 구분해서 작성하는 방법으로 스프링이 제공하는 기능1-1. @Configuration 설정에서 프로필 변경하기  @Configuration 어노테이션을 이용한 설정에서 프로필을 지정하려면, 다음처럼 @Profile 어노테이션을 사용      // DsDevConfig.java  @Configuration  @Profile(\"dev\")  public class DsDevConfig {      @Bean(destroyMethod = \"close\")      public DataSource dataSource() {          ...      }  }  // DsRealConfig.java  @Configuration  @Profile(\"real\")  public class DsRealConfig {      @Bean(destroyMethod = \"close\")      public DataSource dataSource() {          ...      }  }        앞선 코드의 두 클래스는 모두 이름이 “dataSource()”인 Bean을 설정  두 Bean중 어떤 빈을 사용할지는 활성화한 프로필에 따라 달라짐  특정 프로필을 선택하기 위해 컨테이너 초기화전, setActivateProfiles() 매서드를 사용    // MainProfile.javapublic class MainProfile {  public static void main(String[] args) {      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();              // 어떤 프로필을 사용할지 선택함      context.getEnvironment().setActiveProfiles(\"dev\");      ...  }}              두 개 이상의 프로필은 다음과 같이 활성화context.getEnvironment().setActivateProfiles(“dev”, “mysql”);        위와 같은 방법을 거치지 않고도, 다음과 같은 2가지 방법에 의해 프로필 설정 가능          spring.profiles.active 시스템 프로퍼티에 사용할 프로필 값 지정      OS의 spring.profiles.active 환경 변수에 값을 설정                  프로필의 우선 순위는 다음과 같다.                      setActiveProfiles()            자바 시스템 프로퍼티            OS 환경 변수                              1-2. @Configuration을 이용한 프로필 설정  중첩 클래스를 이용해 프로필 설정을 한 파일에 모을 수 있음      // MemberConfigWithProfile.java  @Configuration  @EnableTransactionManagement  public class MemberConfigWithProfile {      ...          // 같은 이름의 Bean을 등록하는 두 클래스를 다른 프로필로 설정        @Configuration      @Profile(\"dev\")      public static class DsDevConfig {          @Bean(destroyMethod = \"close\")          public DataSource dataSource() {              ...          }      }      @Configuration      @Profile(\"real\")      public static class DsRealConfig {          @Bean(destroyMethod = \"close\")          public DataSource dataSource() {              ...          }      }  }              위와 같은 방법으로 중첩 클래스를 설정할 경우, 반드시 static으로 클래스를 선언해야 함      1-3. 다수 프로필 설정  스프링 설정은 두 개 이상의 프로필 이름을 가질 수 있음      @Configuration  @Profile(\"real,test\")  public class DataSourceJndiConfig{      ...        프로필 값을 지정할 때 다음 코드처럼 느낌표(!) 사용 가능      @Configuration  @Profile(\"!real\") // 프로필이 \"dev\", \"real\" 두 개만 있다면 해당 코드는 @Profile(\"dev\")와 동일한 코드  public class DsDevConfig {      ...              보통 특정 프로필이 사용되지 않을 때, 기본으로 사용할 설정을 지정하는 용도로 사용      1-4. 어플리케이션에서 프로필 설정하기  web.xml에서 다음과 같이 spring.profiles.active 초기화 파라미터를 이용해 프로필을 선택 가능      &lt;!-- web.xml --&gt;  ...      &lt;init-param&gt;              &lt;param-name&gt;spring.profiles.active&lt;/param-name&gt;              &lt;param-value&gt;dev&lt;/param-value&gt;      &lt;/init-param&gt;  ...          2. 프로퍼티 파일을 이용한 프로퍼티 설정스프링은 외부의 프로퍼티 파일을 이용해 스프링 Bean을 설정하는 방법을 제공    # db.properties    db.driver=com.mysql.jdbc.Driver    db.url=jdbc:mysql://localhost/spring5fs?characterEncoding=utf8    db.user=spring5    db.password=spring5위 파일의 프로퍼티 값을 자바 설정에서 사용가능2-1. @Configuration 어노티에션 이용 자바 설정에서의 프로퍼티 사용  자바 설정에서 프로퍼티 파일을 사용하려면 다음 두 가지를 설정          PropertySourcePlacholderConfigurer Bean 설정      @Value 어노테이션으로 프로퍼티 값 설정          // PropertyConfig.java  @Configuration  public class PropertyConfig {      @Bean      public static PropertySourcesPlaceholderConfigurer properties() {          PropertySourcesPlaceholderConfigurer configurer =                       new PropertySourcesPlaceholderConfigurer();          configurer.setLocations(                  new ClassPathResource(\"db.properties\"),                  new ClassPathResource(\"info.properties\"));          return configurer;      }  }                PropertySourcesPlaceholderConfigurer 타입의 Bean을 설정하는 매서드는 반드시 static으로 선언해야 함          // DsConfigWithProp  @Configuration  public class DsConfigWithProp {      @Value(\"${db.driver}\")      private String driver;      @Value(\"${db.url}\")      private String jdbcUrl;      @Value(\"${db.user}\")      private String user;      @Value(\"${db.password}\")      private String password;      ...        @Value 어노테이션은 ${구분자} 형식의 플레이스홀더를 값으로 가짐  이 경우, PropertySourcesPlaceholderConfigurer는 일치하는 프로퍼티 값으로 치환",
        "url": "/devlog/2019/12/30/spring-17.html"
      }
      ,
    
      "devlog-2019-12-30-spring-16-html": {
        "title": "[Spring] JSON 응답과 요청 처리",
        "subtitle":"첫걸음 - 16",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. Jackson 의존 설정  Jackson은 자바 객체와 JSON 형식 문자열 간 변환을 처리하는 라이브러리로 다음과 같이 pom.xml에 의존을 추가      &lt;!-- pom.xml --&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;      &lt;version&gt;2.9.4&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- java8 date/time --&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;      &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;      &lt;version&gt;2.9.4&lt;/version&gt;  &lt;/dependency&gt;          2. @RestController로 JSON 형식 응답Spring MVC에서 JSON 형식으로 데이터를 응답하는 방법은 @Controller 대신 @RestController를 사용    // RestMemberController.java    // 기존의 @Controller 대신 새로운 어노테이션 사용    @RestController    public class RestMemberController {        private MemberDao memberDao;        private MemberRegisterService registerService;        /*            * 다음 두 매서드에서 기존의 String 형태의 뷰 이름을 리턴하는 것이 아니라,            * 일반 객체를 리턴함            */        @GetMapping(\"/api/members\")        public List&lt;Member&gt; members() {            return memberDao.selectAll();        }                @GetMapping(\"/api/members2/{id}\")        public Member member2(@PathVariable Long id, HttpServletResponse response) throws IOException {            Member member = memberDao.selectById(id);            if (member == null) {                response.sendError(HttpServletResponse.SC_NOT_FOUND);                return null;            }            return member;        }            ...  @RestController 어노테이션을 붙인 경우 스프링 MVC는 요청 매핑 어노테이션을 붙인 객체가 리턴한 객체를알맞은 형식으로 변환해서 응답 데이터로 전송  이때 클래스 패스에 Jackson이 존재하면 JSON 형식의 문자열로 변환해서 응답          스프링 4버전 이전에는 @RestController 어노테이션이 없기 때문에 다음과 같이 @Controller, @ResponseBody를 함께 사용      @Controllerpublic class RestMemberController {     private MemberDao memberDao;     private MemberRegisterService registerService;          @RequestMapping(path=\"/api/members\", method = RequestMethod.GET)     @ResponseBody     public List&lt;member&gt; members(){           return memberDao.selectAll();     }}                  2-1. @JsonIgnore를 이용한 예외 처리  현재 구현된 응답 결과 JSON에는 비밀번호 같은 민감한 정보가 표기되므로 이를 제외해야 함  다음과 같이 @JasonIgnore 어노테이션을 이용하여 이를 처리      public class Member {      private Long id;      private String email;      @JsonIgnore      private String password;      private String name;      private LocalDateTime registerDateTime;          ...          2-2. 날짜 형식 변환 처리: @JsonFormat  앞선 코드를 보면 registerDateTime의 타입이 LocalDateTime으로써, 이는 다음과 같은 유닉스 타임 스태프로 날짜를 표기          “registerDateTime”: 1519870069000        숫자나 배열보다는 특정 형식으로 날짜를 표현하므로, 다음과 같이 @JasonFormat 어노테이션을 이용      public class Member {          private Long id;      private String email;      @JsonIgnore      private String password;      private String name;      @JsonFormat(shape = Shape.STRING)  // ISO-8601 형식으로 변환      private LocalDateTime registerDateTime;          ...              “registerDateTime”: “2019-09-30T11:07:49”        ISO-8601 형식이 아닌 원하는 형식일 경우 다음과 같이 @JsonFormat의 pattern 속성을 이용      @JsonFormat(pattern = \"yyyyMMddHHmmss\")    private LocalDateTime registerDateTime;              “registerDateTime”: “20190930111323”      2-3. 날짜 형식 변환처리: 기본 적용 설정  날짜를 지정하는 모든 형식의 앞선 어노테이션을 일일히 붙이는 것은 비효율적      Spring MVC의 설정을 변경함으로 해결 가능      // MvcConfig.java  public class MvcConfig implements WebMvcConfigurer {      ...      @Override      public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {          ObjectMapper objectMapper = Jackson2ObjectMapperBuilder // 스프링이 제공하는 클래스                  .json()                                  // 다음 매서드는 유닉스 타임스태프로 출력하는 기능을 비활성화(ISO-8601 사용)                  .featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)                  .build();                 /*                  * 미리 등록된 HttpMessageConverter에는 Jackson을 사용하는 것도 포함되어 있으므로,                    * 새로 생성한 HttpMessageConverter는 다음과 같이 인덱스 0에 위치(맨 앞)함                  */          converters.add(0, new MappingJackson2HttpMessageConverter(objectMapper));      }  }        extendMessageConverters() 매서드는 WebMvcConfigurer에 정의된 인터페이스로,HttpMessageConverter를 추가로 설정할 때 사용  새로 생성한 ObjectMapper를 사용하는 객체를 converters의 첫 번째 항목으로 등록하면 설정 완료4. @RequestBody로 JSON 요청 처리JSON 형식의 요청 데이터를 다음과 같이 커맨드 객체에 @RequestBody 어노테이션을 붙여 자바 객체로 변환    // RestMemberController.java    @RestController    public class RestMemberController {        ...        @PostMapping(\"/api/members\")        public ResponseEntity&lt;Object&gt; newMember(                            // 다음 어노테이션을 붙임으로, JSON 형식의 문자열을 해당 자바 객체로 변환                @RequestBody @Valid RegisterRequest regReq ) {            try {                Long newMemberId = registerService.regist(regReq);                URI uri = URI.create(\"/api/members/\" + newMemberId);                return ResponseEntity.created(uri).build();            } catch (DuplicateMemberException dupEx) {                return ResponseEntity.status(HttpStatus.CONFLICT).build();            }        }        ...    }4-1. JSON 데이터의 날짜 형식 다루기  별도의 설정을 하지 않으면, JSON에서는 다음 패턴의 문자열을 LocalDateTime과 Date로 변환          yyyy-MM-ddTHH:mm:ss        특정 패턴은 @JsonFormat 어노테이션의 pattern 속성을 사용해 지정 가능      @JsonFormat(pattern = \"yyyyMMddHHmmss\")  private LocalDateTime birthDateTime;        해당 타입을 갖는 모든 속성에 적용하려면 다음과 같이 스프링 MVC 설정을 변경      // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      ...      @Override      public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {          DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");          ObjectMapper objectMapper = Jackson2ObjectMapperBuilder                  .json()                  .featuresToEnable(SerializationFeature.INDENT_OUTPUTS)                              // 다음 두 줄에 걸쳐 스프링 MVC 속성을 설정                    .deserializerByType(LocalDateTime.class, new LocalDateTimeDeserializer(formatter))                  .simpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")                  .build();          converters.add(0, new MappingJackson2HttpMessageConverter(objectMapper));      }  }          5. ResponseEntity로 객체 리턴하고 응답 코드 지정하기지금까지는 상태 코드를 지정하기 위해 다음과 같이 HttpSevletResponse의 setStatus(), sendError() 매서드를 이용    @GetMapping(\"/api/members2/{id}\")    public Member member2(@PathVariable Long id, HttpServletResponse response) throws IOException {        Member member = memberDao.selectById(id);        if (member == null) {            response.sendError(HttpServletResponse.SC_NOT_FOUND);            return null;        }        return member;    }하지만 위와 같이 404 응답을 하면 JSON 형식이 아닌 서버가 기존으로 제공하는 HTML을 응답 결과로 제공5-1. ResponseEntity를 이용한 응답 데이터 처리  앞선 문제점은 ReponseEntity를 이용하여 정상/비정상인 두 경우 모두 처리 가능  에러 상황일 때 응답으로 사용할 ErrorResponse 클래스를 다음과 같이 생성      // ErrorReponse.java  public class ErrorResponse {      private String message;      public ErrorResponse(String message) {          this.message = message;      }      public String getMessage() {          return message;      }  }        앞선 클래스를 이용하여 다음과 같이 매서드를 새롭게 구성      // RestMemberController.java  @RestController  public class RestMemberController {      ...      @GetMapping(\"/api/members/{id}\")      public ResponseEntity&lt;Object&gt; member(@PathVariable Long id) {          Member member = memberDao.selectById(id);          if (member == null) {              return ResponseEntity                      .status(HttpStatus.NOT_FOUND)                      .body(new ErrorResponse(\"no member\"));          }          return ResponseEntity.ok(member);      }  \t    ...  }        스프링 MVC에서는 ReponseEntity()의 body로 지정한 객체를 이용해 변환을 처리  ResponseEntity의 status로 지정한 값을 응답 상태 코드로 사용          ResponseEntity.status(상태코드).body(객체)결국, 위의 코드에서 member를 찾지 못한 에러가 발생시 다음과 같은 JSON형식의 데이터를 생성              실행화면{      “member” : “no member”}            5-2. @ExceptionHandler 적용 매서드에서 ReponseEntity로 응답하기  앞선 코드처럼 member가 없는 에러가 여러 곳에서 발생 한다면 코드 중복이 발생  이를 @ExceptionHandler 어노테이션을 적용한 매서드에서 에러처리를 하도록 구현해 해결      // RestMemberController.java  @GetMapping(\"/api/members3/{id}\")  public Member member3(@PathVariable Long id) {      Member member = memberDao.selectById(id);      if (member == null) {          throw new MemberNotFoundException();      }      return member;  }  // 위 매서드에서 발생하는 에러는 다음 매서드가 JSON 형식으로 처리  @ExceptionHandler(MemberNotFoundException.class)  public ResponseEntity&lt;ErrorResponse&gt; handleNoData() {      return ResponseEntity              .status(HttpStatus.NOT_FOUND)              .body(new ErrorResponse(\"no member\"));  }        @RestControllerAdvice 어노테이션을 이용해 다음처럼 에러 처리 코드를 별도 클래스로 분리 가능      // ApiExceptionAdvice.java  @RestControllerAdvice(\"controller\")  public class ApiExceptionAdvice {      @ExceptionHandler(MemberNotFoundException.class)      public ResponseEntity&lt;ErrorResponse&gt; handleNoData() {          return ResponseEntity                  .status(HttpStatus.NOT_FOUND)                  .body(new ErrorResponse(\"no member\"));      }      ...  }          5-3. @Valid 에러 결과를 JSON으로 응답하기  @Valid 어노테이션을 붙인 커맨드 객체가 값 검증에 실패하면 400코드를 HTML 응답으로 전송  이를 해결하기 위해 다음과 같이 Errors 타입 파라미터를 추가해, 직접 에러 응답을 생성      @PostMapping(\"/api/members\")  public ResponseEntity&lt;Object&gt; newMember(          @RequestBody @Valid RegisterRequest regReq,          Errors errors) {      // hasErrors()를 호출하여 검증 에러 존재를 판별      if (errors.hasErrors()) {          String errorCodes = errors.getAllErrors()                  .stream()                  .map(error -&gt; error.getCodes()[0])                  .collect(Collectors.joining(\",\"));          return ResponseEntity                  .status(HttpStatus.BAD_REQUEST)                  .body(new ErrorResponse(\"errorCodes = \" + errorCodes));      }      ...        앞선 코드에서 Errors 타입의 파라미터가 존재하지 않으면, MethodArgumentNotValidException이 발생하므로다음과 같이 @ExceptionHandler 어노테이션을 이용해 분리가능      // ApiExceptionAdvice.java  @RestControllerAdvice(\"controller\")  public class ApiExceptionAdvice {      ...      @ExceptionHandler(MethodArgumentNotValidException.class)      public ResponseEntity&lt;ErrorResponse&gt; handleBindException(MethodArgumentNotValidException ex) {          String errorCodes = ex.getBindingResult().getAllErrors()                  .stream()                  .map(error -&gt; error.getCodes()[0])                  .collect(Collectors.joining(\",\"));          return ResponseEntity                  .status(HttpStatus.BAD_REQUEST)                  .body(new ErrorResponse(\"errorCodes = \" + errorCodes));      }  }      ",
        "url": "/devlog/2019/12/30/spring-16.html"
      }
      ,
    
      "devlog-2019-12-30-spring-15-html": {
        "title": "[Spring] 간단한 웹 어플리케이션의 구조",
        "subtitle":"첫걸음 - 15",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 간단한 웹 어플리케이션의 구성 요소간단한 웹 어플리케이션을 개발할 때 사용하는 전형적인 구조는 다음 요소를 포함  프론트 서블릿  컨트롤러 + 뷰  서비스  DAO          Dispatcher Servlet -&gt; 컨트롤러 -&gt; 서비스 -&gt; DAO        컨트롤러는 실제 웹 브라우저의 요청을 처리하며, 어플리케이션이 제공하는 기능과 사용자를 연결하는 매개체실제 기능을 위한 로직은 서비스가 담당  서비스는 기능의 로직을 구현DB 연동이 필요하다면 DAO를 사용해 데이터를 가져오거나 저장2. 서비스의 구현  구현되는 서비스의 로직은 몇 단계의 과정을 거쳐 수행되며, 모든 과정을 성공적으로 진행했을 때 완료이런 이유로 서비스의 매서드를 트랜잭션 범위에서 주로 수행3. 컨트롤러에서 DAO의 접근  서비스 매서드에서 어떤 로직도 수행하지 않고 단순히 DAO의 매서드만 호출하고 끝나는 코드등은컨트롤러에서 직접 DAO에 접근가능          단순히 ID를 가지고 DAO에 접근하는 경우      4. 패키지 구성  패키지를 구성함에는 정답이 없지만, 같은 구성원 모두가 동일한 규칙에 따라 구성해야 시간 낭비를 방지          웹 어플리케이션이 복잡해지면 기존의 컨트롤러-서비스-DAO 구조 외에UI-서비스-도메인-인프라로 영역을 구성하는 \"도메인 주도 설계\"를 적용      ",
        "url": "/devlog/2019/12/30/spring-15.html"
      }
      ,
    
      "devlog-2019-12-30-spring-14-html": {
        "title": "[Spring] MVC4: 날짜 값 변환, @PathVariable, 익셉션 처리",
        "subtitle":"첫걸음 - 14",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 날짜를 이용한 회원 검색 기능  회원 가입 일자를 기준으로 검색하는 기능을 구현    // MemberDao.javapublic class MemberDao {  ...  public List&lt;Member&gt; selectByRegdate(LocalDateTime from, LocalDateTime to) {      List&lt;Member&gt; results = jdbcTemplate.query(              \"select * from MEMBER where REGDATE between ? and ? \" +                      \"order by REGDATE desc\",              memRowMapper,              from, to);      return results;  }}        selectRegDate() 매서드는 REGDATE 값이 두 파라미터로 전달받은 from과 to 사이에 있는 Member 목록을 구함1-1. 커맨드 객체 Date 타입 프로퍼티 변환 처리: @DateTimeFormat  검색을 위한 입력 폼은 다음처럼 from과 to인 &lt;input&gt; 태그를 정의      &lt;input type=\"text\" name=\"from\" /&gt;  &lt;input type=\"text\" name=\"to\" /&gt;        &lt;input&gt;에 입력한 문자열을 LocalDateTime 타입으로 변환이 필요  @DateTimeFormat 어노테이션을 적용해 다음처럼 변환      // ListCommand.java  public class ListCommand {          // 어노테이션을 적용하여 지정된 형식으로 변환      @DateTimeFormat(pattern = \"yyyyMMddHH\")      private LocalDateTime from;      @DateTimeFormat(pattern = \"yyyyMMddHH\")      private LocalDateTime to;      ...  }        컨트롤러 클래스는 별도 설정 없이 ListCommand 클래스를 커맨드 객체로 사용      // MemberListController.java  @Controller  public class MemberListController {      ...      @RequestMapping(\"/members\")      public String list(              @ModelAttribute(\"cmd\") ListCommand listCommand,              Model model) {                  // from과 to를 이용하여 member 목록을 구한 뒤, 뷰에 \"members\" 속성으로 전달          if (listCommand.getFrom() != null &amp;&amp; listCommand.getTo() != null) {              List&lt;Member&gt; members = memberDao.selectByRegdate(                      listCommand.getFrom(), listCommand.getTo());              model.addAttribute(\"members\", members);          }          return \"member/memberList\";      }  }          1-2. 변환 에러 처리  만약 폼에서 from과 to에 입력형식인 “yyyyMMddHH”와 달리 “yyyyMMdd”가 입력되면 에러 발생  이를 처리해 알맞은 에러 메시지를 보여주기 위해 다음과 같이 Errors 타입 파라미터를 요청 어노테이션 적용 매서드에 추가      // MemberListController.java  @Controller  public class MemberListController {      ...      @RequestMapping(\"/members\")      public String list(              @ModelAttribute(\"cmd\") ListCommand listCommand,              Errors errors, Model model) {          if (errors.hasErrors()) {              return \"member/memberList\";          }          if (listCommand.getFrom() != null &amp;&amp; listCommand.getTo() != null) {              List&lt;Member&gt; members = memberDao.selectByRegdate(                      listCommand.getFrom(), listCommand.getTo());              model.addAttribute(\"members\", members);          }          return \"member/memberList\";      }  }        변환 에러가 발생하게 되면, 에러 코드로 \"typeMismatch\"를 추가하므로 다음처럼 메세지 프로퍼티 파일을 통해 에러 메세지를 변경 가능      // label.properties  ...  typeMismatch.java.time.LocalDateTime = 잘못된 형식          2. @PathVariavle을 이용한 경로 변수 처리다음은 ID가 10인 회원의 정보를 조회하기 위한 URL  http://localhost:8080/sp5-hap14/members/10          회원의 ID가 달라지면 경로의 마지막 부분이 달라짐        이렇듯 경로의 일부가 고정되어 있지 않고 달라질 때 다음처럼 @PathVariable 어노테이션을 통해 가변 경로 처리 가능      // MemberDetailController.java  @Controller  public class MemberDetailController {      ...          // {}중괄호에 둘러쌓인 부분이 경로 변수      @GetMapping(\"/members/{id}\")      public String detail(@PathVariable(\"id\") Long memId, Model model) {          Member member = memberDao.selectById(memId);          if (member == null) {              throw new MemberNotFoundException();          }          model.addAttribute(\"member\", member);          return \"member/memberDetail\";      }      ...  }          3. 컨트롤러 익셉션 처리  알맞은 익셉션 처리를 하여 사용자에게 더 적합한 안내를 다음과 같이 제공          익셉션 처리를 해주지 않으면 HTTP Status 400 같은 페이지가 사용자에게 보임              컨트롤러에서 발생한 익셉션을 직접 처리하기 위해 @ExceptionHandler 어노테이션을 사용        @ControllerAdvice 어노테이션을 이용해 공통 익셉션을 처리            3-1. @Exception 어노테이션을 이용한 컨트롤러 익셉션 직접 처리  같은 컨트롤러에 @ExceptionHandler 어노테이션을 적용한 매서드가 존재하면 그 메서드가 익셉션을 처리      // MemberDetailController.java  @Controller  public class MemberDetailController {      ...      @GetMapping(\"/members/{id}\")      public String detail(@PathVariable(\"id\") Long memId, Model model) {          Member member = memberDao.selectById(memId);          if (member == null) {              throw new MemberNotFoundException();          }          model.addAttribute(\"member\", member);          return \"member/memberDetail\";      }          // 아래의 두 매서드는 각각 해당하는 타입의 익셉션을 처리하며 뷰 이름을 리턴      @ExceptionHandler(TypeMismatchException.class)      public String handleTypeMismatchException() {          return \"member/invalidId\";      }      @ExceptionHandler(MemberNotFoundException.class)      public String handleNotFoundException() {          return \"member/noMember\";      }  }          3-2. @ControllerAdvice 어노테이션을 이용한 공통 익셉션 처리  다수의 컨트롤러에서 동일 타입의 익셉션이 발생하는 경우 사용  @ControllerAdvice 어노테이션이 적용된 클래스는 지정한 범위의 컨트롤러에 공통으로 사용될 설정을 지정 가능      @ControllerAdvice 어노테이션 적용 클래스가 동작하기 위해 해당 클래스를 스프링의 Bean으로 등록해야 함      // CommonExceptionHandler.java  // spring 패키지와 그 하위 패키지에 속한 컨트롤러 클래스를 위한 공통 기능을 정의    @ControllerAdvice(\"spring\")  public class CommonExceptionHandler {          // 처리하는 익셉션의 종류는 RuntimeException      @ExceptionHandler(RuntimeException.class)      public String handleRuntimeException() {          return \"error/commonException\";      }  }          3-3. @ExceptionHandler 적용 매서드의 우선 순위  @ControllerAdvice 클래스에 있는 @ExceptionHandler 매서드와 컨트롤러 클래스에 있는 @ExceptionHandler 매서드 중,컨트롤러 클래스의 @ExceptionHandler 매서드가 우선함  컨트롤러 매서드를 실행하는 도중 익셉션이 발생하면 다음의 순서로 처리          같은 컨트롤러에 위치한 @ExceptionHandler 매서드 중 해당 익셉션을 처리할 수 있는 매서드를 검색      @ControllerAdvice 클래스에 위치한 @ExceptionHandler 매서드를 검색      ",
        "url": "/devlog/2019/12/30/spring-14.html"
      }
      ,
    
      "devlog-2019-12-30-spring-13-html": {
        "title": "[Spring] MVC3: 세션, 인터셉션, 쿠키",
        "subtitle":"첫걸음 - 13",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "0. 들어가기 앞서본 문서에서 다루는 내용은 다음과 같다.  세션  인터셉터  쿠키  쿠키와 세션?동적인 웹페이지에서 입력 정보를 유지할 필요가 있을 때 정보를 저장하는 장소에 따라 두 가지로 분류      웹 서버에 저장하는 경우: 세션              일정 시간동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고 상태를 서버에 저장하며 유지 시킴              클라이언트에 저장하는 경우: 쿠키              서버에서 생성하고 클라이언트에서 관리하며 만료시간 여부에 따라 파괴됨              데이터가 작고 중요하지 않은 데이터는 클라이언트(쿠키) 쪽에서 관리하고 나머지는 웹서버(세션)에 저장하는 것이 일반적다음과 같은 로그인 기능을 담당하는 기본적인 파일들이 본 프로젝트에 이미 구성되어 있다(소스코드 다운).  AuthInfo.java  AuthService.java  LoginCommand.java  LoginCommandValidator.java  LoginController.java  loginFrom.jsp  loginSuccess.jsp1. 컨트롤러에서 HttpSession 사용로그인 기능을 구현 후 로그인 상태를 유지하는 방법은 크게 다음과 같이 두 가지가 존재  HttpSession  쿠키컨트롤러에서 HttpSession을 사용하려면 다음의 두 가지 방법중 한 가지를 사용  요청 매핑 어노테이션 적용 매서드에 HttpSession 파라미터를 사용      @PostMapping  public String form(LoginCommand loginCommand, Errors errors, HttpSession session){      ... // session을 사용하는 코드  }        요청 매핑 어노테이션 적용 매서드에 HttpServletRequest 파라미터를 추가하고 HttpServletRequest를 이용해 HttpSession을 구함      @PostMapping  public String submit(      LoginCommand loginCommand, Errors errors, HttpServletRequest req){    HttpSession session = req.getSession();      ... // session을 사용하는 코드  }              첫 번째 방법은 항상 HttpSession을 생성하지만, 두 번째 방법은 필요한 시점에만 HttpSession을 생성두 방법 모두 기존에 존재하는 세션이 있을시, 존재하는 세션을 전달        로그인을 위한 컨트롤러 클래스는 다음과 같이 인증 정보를 세션에 담음      // LoginController.java  @Controller  @RequestMapping(\"/login\")  public class LoginController {      ...      @PostMapping      public String submit(              LoginCommand loginCommand, Errors errors, HttpSession session,              HttpServletResponse response) {          new LoginCommandValidator().validate(loginCommand, errors);          if (errors.hasErrors()) {              return \"login/loginForm\";          }          try {              AuthInfo authInfo = authService.authenticate(                      loginCommand.getEmail(),                      loginCommand.getPassword());                              // 로그인에 성공 시 HttpSession의 authInfo 속성에 인증 정보 객체(authInfo)를 저장              session.setAttribute(\"authInfo\", authInfo);          ...          } catch (WrongIdPasswordException e) {              errors.reject(\"idPasswordNotMatching\");              return \"login/loginForm\";          }      }  }          로그아웃을 위한 컨트롤러 클래스는 HttpSession을 다음과 같이 제거함      // LogoutController.java  @Controller  public class LogoutController {      @RequestMapping(\"/logout\")      public String logout(HttpSession session) {          session.invalidate();          return \"redirect:/main\";      }  }          2. 인터셉터 사용  현재 로그인하지 않고 바로 비밀번호를 변경하는 주소를 웹 브라우저에 입력할 경우 비밀번호 변경 폼이 출력 되는데,로그인하지 않고도 변경 폼이 출력되는 것은 비정상적이며 이를 방지해야 함  이를 해결하기 위해 HttpSession에 authInfo 객체의 유무를 조사 후, 리다이렉트 시키는 방법으로 해결할 수 있으나,각 기능을 구현한 모든 컨트롤러에 이런 세션 확인 코드를 삽입하는 것은 비효율적          이렇게 다수의 컨트롤러에 대해 동일한 기능을 적용해야 할 때 사용할 수 있는 것이 HandlerInterceptor       2-1. HandlerInterceptor 구현  org.springframework.web.HandlerInterceptor 인터페이스를 이용해 구현하며 다음과 같은 시점에 공통 기능 삽입 가능          컨트롤러 실행 전      컨트롤러 실행 후, 아직 뷰를 실행 전      뷰를 실행한 이후        이러한 시점을 처리하기 위해 HandlerInterceptor 인터페이스는 다음 매서드를 정의          boolean prehandle(…)      void postHandle(…)      void afterCompletion(…)        preHandle(): 리턴 타입은 boolean으로써, 만약 false를 리턴하게 되면 컨트롤러 또는 다음 핸들러인터셉터를 실행하지 않음  postHandle(): 컨트롤러가 정상적으로 실행된 이후에 추가 기능을 구현할 때 사용하며, 컨트롤러가 익셉션을 발생하면 postHandle() 매서드는 실행하지 않음      afterCompletion(): 뷰가 클라이언트에 응답을 전송한 뒤에 실행하며, 컨트롤러 실행 이후에 예기치 않게 발생한 익셉션 로그나 실행 시간을 기록하기에 적합     // AuthCheckInterceptor.java public class AuthCheckInterceptor implements HandlerInterceptor {     @Override     public boolean preHandle(             HttpServletRequest request,             HttpServletResponse response,             Object handler) throws Exception {         HttpSession session = request.getSession(false);         if (session != null) {             Object authInfo = session.getAttribute(\"authInfo\");             if (authInfo != null) {                 return true;             }         }                 // 인증정보가 없어 실패 시, 다음과 같은 경로로 리다이렉트 시킴         response.sendRedirect(request.getContextPath() + \"/login\");         return false;     } }          2-2. HandlerInterceptor 설정  HandlerInterceptor를 구현한 다음, 어디에 적용할지 설정이 다음과 같이 필요      // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      ...          // 인터셉트를 정의하는 매서드      @Override      public void addInterceptors(InterceptorRegistry registry) {          registry.addInterceptor(authCheckInterceptor())              .addPathPatterns(\"/edit/**\")              .excludePathPatterns(\"/edit/help/**\");      }      ...  }        addInterceptor 매서드는 인터셉터를 적용할 경로 패턴을 Ant 경로 패턴을 이용하여 지정          Ant 경로 패턴?Ant 패턴은 *, **, ?의 세 가지 특수 문자를 사용해 경로를 다음과 같이 표현              *: 0개 또는 그 이상의 글자        ?: 1개 글자        **: 0개 또는 그 이상의 폴더 경로따라서 앞선 코드의 경우, http://localhost:8080/sp5-chap13/edit/changePassword 에 접근하면 로그인 폼으로 리다이렉트 됨            3. 컨트롤러에서 쿠키 사용  로그인할 때 이메일을 기억하여 쿠키에 저장하는 방식을 구현  스프링 MVC에서 쿠키를 사용하는 방법 중 하나는 @CookieValue 어노테이션을 사용하는 것      @CookieValue 어노테이션은 요청 매핑 어노테이션 적용 매서드의 Cookie 타입의 파라미터에 적용      // LoginController.java  @Controller  @RequestMapping(\"/login\")  public class LoginController {      ...      @GetMapping      public String form(LoginCommand loginCommand,              /*                  * 어노테이션을 통해 쿠키의 이름을 REMEMBER로 지정                    * 지정한 이름의 쿠키가 없다면, required 속성 값을 false로 지정                  * 만약 지정한 이름의 쿠키가 없는데, required가 ture면 익셉션 발생                  */              @CookieValue(value = \"REMEMBER\", required = false) Cookie rCookie) {          if (rCookie != null) {              loginCommand.setEmail(rCookie.getValue());              loginCommand.setRememberEmail(true);          }          return \"login/loginForm\";      }  /*      * 실제 쿠키를 생성하는 부분은 로그인을 처리하는 다음 매서드      * 쿠키를 사용하기 위해 HttpServletResponse 객체가 필요하므로 파라미터로 전달      */      @PostMapping      public String submit(              LoginCommand loginCommand, Errors errors, HttpSession session,              HttpServletResponse response) {          ...                  // 쿠키를 추가하는 코드          Cookie rememberCookie =                   new Cookie(\"REMEMBER\", loginCommand.getEmail());          rememberCookie.setPath(\"/\");                              /*                  * 로그인에 성공했을 때, 이메일 기억하기 체크박스 선택 여부에 따라                  * 30일동안 유지되는 쿠키를 생성하거나                  * 바로 삭제되는 쿠키를 생성                  */          if (loginCommand.isRememberEmail()) {              rememberCookie.setMaxAge(60 * 60 * 24 * 30);          } else {              rememberCookie.setMaxAge(0);          }          response.addCookie(rememberCookie);          ...      }  }      ",
        "url": "/devlog/2019/12/30/spring-13.html"
      }
      ,
    
      "devlog-2019-12-30-spring-12-html": {
        "title": "[Spring] MVC2: 메세지, 커맨드 객체 검증",
        "subtitle":"첫걸음 - 12",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. &lt;spring:message&gt; 태그로 메세지 출력  기존 JSP에 문자열을 하드 코딩하는 방법은 다음과 같은 두 가지 문제가 존재          동일한 문자열에 대해 변경시      다국어 지원        이러한 문제를 해결하는 방법은 다음과 같다.          뷰 코드에서 사용할 문자열을 언어별로 파일에 보관      필요시 파일에서 문자열을 읽어와 출력        스프링은 이러한 기능을 자체적으로 제공하며, 다음과 같은 작업을 거친다.          문자열을 담은 메세지 파일을 작성      메세지 파일에서 값을 읽어오는 MessageSource 빈을 설정      JSP 코드에서 &lt;spring:message&gt; 태그를 사용해 메세지를 출력          // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      ...      @Bean          // Bean 등록      public MessageSource messageSource() {          ResourceBundleMessageSource ms =                   new ResourceBundleMessageSource();                  // 읽어올 파일 등록          ms.setBasenames(\"message.label\");          ms.setDefaultEncoding(\"UTF-8\");          return ms;      }  }        설정파일에 MessageSource Bean 객체를 등록          이때 Bean의 아이디를 \"messageSource\"로 지정, 다른 이름은 동작하지 않음        기본 프로퍼티 값으로 message.label을 할당          src/main/resources/message 경로에 label.properties 파일을 생성 후 아래와 같이 작성          // label.properties  member.register=회원가입  term=약관  term.agree=약관동의  ...        위 설정을 이용하여 JSP 파일을 다음과 같이 변경 가능      &lt;!-- step1.jsp --&gt;  &lt;%@ page contentType=\"text/html; charset=utf-8\" %&gt;  &lt;%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\" %&gt;  &lt;!DOCTYPE html&gt;  &lt;html&gt;  &lt;!-- 변경전 코드  &lt;head&gt;      &lt;title&gt;회원가입&lt;/title&gt;  &lt;/head&gt;  --&gt;  &lt;head&gt;      &lt;title&gt;&lt;spring:message code=\"member.register\" /&gt;&lt;/title&gt;  &lt;/head&gt;  ...        &lt;spring:message&gt; 태그는 MessageSource로부터 코드에 해당하는 메세지를 읽어옴1-1. 메세지 처리를 위한 MessageSource와 &lt;spring:message&gt; 태그  스프링은 지역(로케일)에 상관없이 일괄된 방법으로 문자열(메세지)를 관리할 수 있는 MessageSource 인터페이스를 정의  특정 지역에 해당하는 메세지가 필요한 코드는 MessageSource의 getMessage() 메서드를 통해 필요한 메세지를 가져와 사용  이 기능을 사용하면 국내에서 접근하면 한글로, 해외에서 접근하면 영어로 보여주는 처리 가능      // MessageSource interface  public interface MessageSource{      /*      * code 파라미터: 메세지를 구분하기 위한 코드      * locale 파라미터: 지역을 구분하기 위한 Locale      * 이 기능을 사용하면 지역에 따른 메세지 출력 가능      */      String getMessage(String code, Object[] args,          Srting defaultMessage, Locale locale);      String getMessage(String code, Object[] args, Locale locale)          throws NoSuchMessageException;      ...              다국어 메세지를 지원하려면 각 프로퍼티 파일 이름에 언어에 해당하는 로케일 문자를 다음과 같이 추가하며해당하는 지역이 없을 경우, 기본값인 label.properties 파일의 메세지를 사용              label_ko.properties        label_en.properties                    브라우저는 서버에 요청을 전송할 때 Accept-Language 헤더에 언어 정보를 담아 전송              한글일 경우 헤더값으로 “ko“를 전송            Spring MVC는 웹 브라우저가 전송한 Accept-Language 헤더를 이용해서 Locale을 구하고 메세지를 출력함      1-2. &lt;spring:message&gt; 태그의 메세지 인자 처리  &lt;spring:message&gt; 태그를 사용할 때는 arguments 속성을 이용해 인덱스 기반 변수값을 다음과 같이 전달  properties 파일에는 다음과 같이 사용할 인덱스의 정보를 이용해 메세지를 저장      &lt;!-- step3.jsp --&gt;  &lt;spring:message code=\"register.done\" arguments=\"${registerRequest.name}, ${registerRequest.email}\" /&gt;  &lt;!-- label.properties --&gt;  register.done=&lt;strong&gt;{0}님 ({1})&lt;/strong&gt;, 회원 가입을 완료했습니다.           2. 커맨드 객체의 값 검증과 에러 메세지 처리  어플리케이션을 개발할 때 놓쳐서는 안되는 다음 두 가지 문제가 존재          폼 값 검증 - 웹 페이지에 입력한 값에 대한 검증 필요      에러 메세지 처리 - 만약 잘못된 값을 입력하여 다시 페이지가 로드 된다면, 이유를 알려줌        스프링은 이 두 가지 문제를 처리하기 위해 다음 방법을 제공          커맨드 객체를 검증하고 결과를 에러 코드로 저장      JSP에서 에러 코드로부터 메세지 출력      2-1. 커맨드 객체 검증과 에러 코드 지정  스프링 MVC에서 커맨드 객체 값이 올바른지 검사하려면 다음의 두 인터페이스를 사용          org.springframework.validation.Validator      org.springframework.validation.Errors        객체를 검증할 때 사용하는 Validator 인터페이스는 다음과 같다.      package org.springframework.validation;  public interface Validator{      boolean supports(Class&lt;?&gt; clazz);      void validate(Object target, Errors errors);  }        위 코드에서 각 매서드의 역할은 다음과 같다.          supports() 매서드는 Validator가 검증할 수 있는 타입인지 검사      validate() 매서드는 첫 번째 파라미터로 전달받은 객체를 검증하고 오류 결과를 Errors에 담는 기능          // RegisterRequesValidator.java  public class RegisterRequestValidator implements Validator {      ...      /*          * 파라미터로 전달받은 clazz 객체가 RegisterRequest 클래스로 타입 변환이 가능한지 확인            * 스프링 MVC가 자동으로 검증 기능을 수행하도록 하려면 올바르게 다음 매서드를 구현해야 함          */      @Override      public boolean supports(Class&lt;?&gt; clazz) {          return RegisterRequest.class.isAssignableFrom(clazz);      }      /*          * 두 개의 파라미터중 target은 검사 대상 객체, errors는 결과 에러 코드를 설정하기 위한 객체          * validate()는 다음과 같이 구현          * 1. 검사 대상 객체의 특정 프로퍼티나 상태가 올바른지 검사           * 2. 올바르지 않다면 Errors의 rejectValue() 매서드를 이용해 에러 코드 저장          */      @Override      public void validate(Object target, Errors errors) {          System.out.println(\"RegisterRequestValidator#validate(): \" + this);          // 실제 타입으로 변환          RegisterRequest regReq = (RegisterRequest) target;                      /*                  * \"email\" 프로퍼티 값이 유효한지 검사          * 유효하지 않다면(NULL이거나 빈 문자열) 에러 코드로 \"required\"를 추가          */          if (regReq.getEmail() == null || regReq.getEmail().trim().isEmpty()) {              errors.rejectValue(\"email\", \"required\");          }          /*                  * ValidationUtils 클래스는 객체의 값 검증 코드를 간결하게 작성할 수 있도록 도와줌          * 다음의 코드들은 앞선 email을 검증하는 코드와 동일          */          ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"required\");          ValidationUtils.rejectIfEmpty(errors, \"password\", \"required\");          ValidationUtils.rejectIfEmpty(errors, \"confirmPassword\", \"required\");          if (!regReq.getPassword().isEmpty()) {              if (!regReq.isPasswordEqualToConfirmPassword()) {                  errors.rejectValue(\"confirmPassword\", \"nomatch\");              }          }      }  }        실제 Validator()는 다음과 같이 필요한 부분에서 호출 됨      // RegisterController.java  @Controller  public class RegisterController {      ...      @PostMapping(\"/register/step3\")      public String handleStep3(RegisterRequest regReq, Errors errors) {          new RegisterRequestValidator().validate(regReq, errors);          if (errors.hasErrors())              return \"register/step2\";          try {              memberRegisterService.regist(regReq);              return \"register/step3\";          } catch (DuplicateMemberException ex) {              errors.rejectValue(\"email\", \"duplicate\");              return \"register/step2\";          }      }  }          2-2. 커맨드 객체의 에러 메세지 출력  에러 코드는 알맞은 에러 메세지를 출력하기 위해 지정  JSP는 스프링이 제공하는 &lt;form:errors&gt; 태그를 이용해 에러에 해당하는 메세지를 출력      &lt;!-- step2.jsp --&gt;  ...  &lt;body&gt;      &lt;h2&gt;&lt;spring:message code=\"member.info\" /&gt;&lt;/h2&gt;      &lt;form:form action=\"step3\" modelAttribute=\"registerRequest\"&gt;      &lt;p&gt;          &lt;label&gt;&lt;spring:message code=\"email\" /&gt;:&lt;br&gt;          &lt;form:input path=\"email\" /&gt;          &lt;form:errors path=\"email\"/&gt;          &lt;/label&gt;      &lt;/p&gt;  ...        &lt;form:errors&gt; 태그의 path 속성은 에러 메세지를 출력할 프로퍼티 이름을 지정  메세지를 찾을 때는 앞서 서술한 MessageSource를 사용하므로 에러 코드에 해당하는 메세지를 프로퍼티 파일에 추가해야 함          Controller에서 에러가 발생시, Errors 객체에 추가하는 메시지를 프로퍼티 파일에 다음과 같이 추가하면 됨…required = 필수항목입니다.bad.email = 이메일이 올바르지 않습니다.      3. 글로벌 범위 Validator와 컨트롤러 범위 Validator스프링 MVC는 다음 두 가지 Validator를 제공  모든 컨트롤러에 적용할 수 있는 글로벌 Validator  단일 컨트롤러에 적용할 수 있는 Validator 3-1. 글로벌 범위 Validator 설정과 @Valid 어노테이션  글로벌 범위 Validator를 적용하려면 다음 두 가지 설정 필요          설정 클래스에서 WebMvcConfigurer 인터페이스의 getValidator() 매서드가 Validator 구현 객체를 리턴하도록 구현      글로벌 범위 Validator가 검증할 커맨드 객체에 @Valid 어노테이션 적용          // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      /*          * WebMvcConfigurer 인터페이스의 getValidator 매서드를 다음과 같이 오버라이딩하여          * 우리가 원하는 검증을 하도록 설정          */      @Override      public Validator getValidator(          return new RegisterRequestValidator();      }  }  // RegisterController.java  @PostMapping(\"/register/step3\")  public String handleStep3(@Valid RegisterRequest regReq, Errors errors){      // 기존에 객체를 검증하는 코드를 작성할 필요가 없어짐        // new RegisterRequestValidator().validate(regReq, errors);      ...  }        @Valid 어노테이션이 붙은 파라미터는 글로벌 범위 Validator가 해당 타입을 검증할 수 있는지 확인  검증 가능하면 실제 검증을 수행하고 그 결과를 Errors에 저장  이 과정은 요청 처리 매서드(handleStep3()) 실행 전에 적용          결국 handleStep3() 매서드 안에서 RegisterRequest 객체를 검증하는 코드를 작성할 필요가 없어짐      3-2. @InitBinder 어노테이션을 이용한 컨트롤러 범위 Validator      @InitBinder 어노테이션을 이용해 컨트롤러 범위 Validator를 설정 가능      // RegisterController.java  @PostMapping(\"/register/step3\")  public String handleStep3(@Valid RegisterRequest regReq, Errors errors){      ...  }  ...  /*   * 어떤 Validator가 객체를 검증할지 다음 @InitBind 어노테이션이 붙은 매서드에서 정의  * 여기서는 RegisterRequest 타입을 지원하는 Validator를 컨트롤러 범위 Validator로 설정  */  @InitBinder  protected void initBinder(WebDataBinder binder){      binder.setValidator(new RegisterRequestValidator());  }        글로벌 범위 validator와 마찬가지로 validator() 매서드를 호출하는 부분이 없음  @InitBind 어노테이션을 적용한 매서드는 WebDataBinder 타입 파라미터를 가짐      setValidator() 매서드를 이용해 컨트롤러 범위에 적용할 Validator 설정 가능          글로벌 범위와 컨트롤러 범위 validator()가 모두 존재할 경우,    글로벌 -&gt; 컨트롤러 범위 순으로 validator()가 적용됨      4. Bean Validation을 이용한 값 검증 처리@Valid 어노테이션은 Bean Validation 스펙에 정의되어 있는데, @NotNull, @Digits, @Size 등의 어노테이션과 함께 정의되며,Bean Validaion이 제공하는 어노테이션을 이용해 커맨드 객체의 값을 검증하는 방법은 다음과 같다.  Bean Validation과 관련된 의존을 설정에 추가(Maven의 경우 pom.xml에 추가)      커맨드 객체에 @NotNull, @Digits 등의 어노테이션을 이용해 검증 규칙을 설정     // RegisterRequest.java public class RegisterRequest {     @NotNull     @Email     private String email;     @Size(min=6)     private String password;     @NotEmpty     private String confirmPassword;     @NotEmpty     private String name; ...        위와 같은 어노테이션을 사용했다면 Bean Validation 어노테이션을 적용한 커맨드 객체를 검증할 수 있는OptionalValidatorFactoryBean 클래스를 Bean으로 등록  설정 파일에 @EnableWebMvc 어노테이션을 사용해 OptionalValidatorFactoryBean을 글로벌 범위 Validator로 등록  다음과 같이 @Valid 어노테이션을 붙여 글로벌 범위 Validator로 검증 가능  각 어노테이션의 에러 메세지는 Bean validation 프로바이더가 제공하는 기본 에러 메세지를 출력          @NotNull: 반드시 값이 존재하고 공백 문자를 제외한 길이가 0보다 커야 합니다.@NotEmpty: 반드시 값이 존재하고 길이 혹은 크기가 0보다 커야 합니다.…          @PostMapping(\"/register/step3\")  public String handleStep3(@Valid RegisterRequest regReq, Errors errors) {      new RegisterRequestValidator().validate(regReq, errors);      if (errors.hasErrors())          return \"register/step2\";      try {          memberRegisterService.regist(regReq);          return \"register/step3\";      } catch (DuplicateMemberException ex) {          errors.rejectValue(\"email\", \"duplicate\");          return \"register/step2\";      }  }              만약 글로벌 validator가 따로 설정되어 있다면, Spring은 OptionalValidatorFactoryBean를 글로벌 범위 Validator로 사용하지 않음  따라서 따로 설정한 글로벌 범위 validator는 삭제해 주어야 함      4-1. Bean Validation 에러 메세지 커스터마이징      기본 에러 메세지 대신, 원하는 에러 메세지를 사용하기 위해 다음과 같이 properties 파일에 작성      NotBlank=필수 항목입니다. 공백 문자는 허용하지 않습니다.  NotEmpty=필수 항목입니다.  Size.password=암호 길이는 6자 이상이어야 합니다.  Email=올바른 이메일 주소를 입력해야 합니다.              @NotBlank: 필수 항목입니다. 공백 문자는 허용하지 않습니다.@NotEmpty: 필수 항목입니다.…      ",
        "url": "/devlog/2019/12/30/spring-12.html"
      }
      ,
    
      "devlog-2019-12-30-spring-11-html": {
        "title": "[Spring] MVC1: 요청 매핑, 커맨드 객체, 리다이렉트, 폼 태그, 모델",
        "subtitle":"첫걸음 - 11",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "0. 들어가기 앞서본 문서에서 다루는 뷰는 크게 다음과 같다.  step1: 약관 동의, 별다른 기능 없음  step2: 회원가입 정보입력, step1에 동의 해야만 접근 가능  step3: 회원가입 완료, 첫 화면으로 돌아가는 기능 제공  surveyFrom: 설문조사 항목을 표기  submitted: 설문조사 결과를 화면에 표기 1. 요청 매핑 어노테이션을 이용한 경로 매핑웹 어플리케이션을 개발하는 것은 다음 코드를 작성하는 것  특정 요청 URL을 처리할 코드  처리 결과를 HTML과 같은 형식으로 응답하는 코드이 중 첫 번째는 @Controller 어노테이션을 이용한 컨트롤러 클래스를 이용해 구현하며, 요청 매핑 어노테이션은 다음과 같다.          @RequestMapping      @GetMapping      @PostMapping      이를 이용하여 간단히 화면을 띄우는 방법은 다음 예시와 같다.    // RegisterController.java    @Controller    public class RegisterController {        ...        @RequestMapping(\"/register/step1\")        public String handleStep1() {            return \"register/step1\";        }            ...  요청 경로가 /register/step1인 경우 “register/step1”을 리턴하며 이는 곧 보여줄 뷰의 이름  step1.jsp 파일을 생성 후, 설정파일에 RegisterController를 Bean으로 등록1-1. GET, POST의 구분: @GetMapping, @PostMapping  스프링 MVC는 별도 설정이 없으면 GET과 POST 방식에 상관없이 @RequestMapping에 지정한 경로와 일치하는 요청을 처리  POST 방식의 요청만 처리하고 싶다면, @PostMapping 어노테이션을 사용해 제한  마찬가지로, GET 방식은 @GetMapping 어노테이션을 사용해 제한      // RegisterController.java  @Controller  public class RegisterController {      ...          // regist/step2 경로로 들어오는 요청중 POST 방식만 처리       @PostMapping(\"/register/step2\")      public String handleStep2(          ...          }          // regist/step2 경로로 들어오는 요청중 GET 방식만 처리      @GetMapping(\"/register/step2\")      public String handleStep2Get() {          return \"redirect:/register/step1\";      }          ...  }          2. 요청 파라미터 접근step1.jsp 코드에는 다음처럼 ‘agree’ 요청 파라미터의 값을 POST 방식으로 전송하며,폼에서는 지정한 agree 요청 파라미터의 값을 이용해 약관 동의 여부를 확인 가능    &lt;!-- step1.jsp --&gt;    &lt;!-- 약관 동의 화면을 생성하는 코드 --&gt;    ...    &lt;form action=\"step2\" method=\"post\"&gt;    &lt;label&gt;        &lt;input type=\"checkbox\" name=\"agree\" value=\"true\"&gt; 약관 동의    &lt;/label&gt;    &lt;input type=\"submit\" value=\"다음 단계\" /&gt;    &lt;/form&gt;    ...컨트롤 매서드에서 요청 파라미터를 사용하는 방법은 다음과 같이 2가지 방법이 존재  HttpServletRequest를 직접 이용  @RequestParam 어노테이션을 사용2-1. HttpServletRequest를 이용    // RegisterController.java     @Controller    public class RegisterController {        ...        @PostMapping(\"/register/step2\")        public String handleStep2(HttpServletRequest request) {                    String agreeParam = request.getParameter(\"agree\");            if (agreeParam == null || !agreeParam.equals(\"true\")) {                return \"register/step1\";            }            return \"register/step2\";        }            ...    }  컨트롤러의 처리 매서드 파라미터로 HttpServletRequest 타입을 사용  HttpServletRequest의 getPatameter() 매서드를 이용해 파라미터의 값을 구함2-2. @RequestParam 어노테이션을 이용    // RegustController.java    @Controller    public class RegisterController {        ...        @PostMapping(\"/register/step2\")        public String handleStep2(                            /*                            * agree 요청 파라미터의 값을 읽어, agreeVal에 할당                             * 요청 파라미터의 값이 없다면, \"false\" 문자열을 값으로 사용                             */                @RequestParam(value = \"agree\", defaultValue = \"false\") Boolean agreeVal){            if (!agree) {                return \"register/step1\";            }            return \"register/step2\";        }            ...    }  요청 파라미터의 개수가 몇 개 안 되면 @RequestParam 어노테이션을 사용해 간단히 값을 구하는 것이 가능  @RequestParam 어노테이션의 속성은 다음이 존재          value(String): HTTP 요청 파라미터의 이름을 지정      required(boolean): 필수 여부 지정      defaultValue(String): 값이 없을 때 사용할 문자열 지정      3. 리다이렉트 처리step2는 step1에서 약관을 동의해야만 접근 가능한 페이지이므로, URL을 직접 입력하여 접근하는 GET 방식은 허용하지 않음따라서 다음과 같이 URL을 직접 입력하는 경우, step1로 리다이렉트 시킴    // RegisterController.java    @Controller    public class RegisterController {        ...            // regist/step2 경로로 들어오는 요청중 POST 방식만 처리         @PostMapping(\"/register/step2\")        public String handleStep2(            ...            }            // regist/step2 경로로 들어오는 요청중 GET 방식만 처리, step1로 리다이렉트 시킴        @GetMapping(\"/register/step2\")        public String handleStep2Get() {            return \"redirect:/register/step1\";        }            ...    }리다이렉트할 경로를 설정하는 방법은 다음과 같이 3가지가 존재  웹 어플리케이션을 기준으로 이동 경로를 생성:          “redirect:” 뒤의 문자열이 “/”로 시작하는 경우      “redirect:/register/step1”은 웹 어플리케이션 경로와 합쳐져 “/sp5-chap11/register/step1”이 됨        현재 경로를 기준으로 상대 경로를 이용:          ”/”로 시작하지 않을 경우        절대 경로를 이용:          완전한 URL을 사용      4. 커맨드 객체4-1. 커맨드 객체를 이용해 요청 파라미터 사용step2.jsp가 생성하는 폼은 다음 파라미터를 이용해 정보를 서버에 전송  email / name / password / confirmPassword이를 처리하기 위해 다음과 같은 전송 코드를 사용가능      @PostMapping(\"/register/step3\")  public String handleStep3(HttpServletRequest request){      String email = request.getParameter(\"email\");      String name = request.getParameter(\"name\");      String password = request.getParameter(\"password\");      String confirmPassword = request.getParameter(\"confirmPassword\");          ...              하지만 파라미터의 개수가 훨씬 많아진다면 일일히 값을 읽어올 것인가?        이런 불편함을 줄이기 위해 스프링은 요청 파라미터의 값을 커맨드 객체에 담아주는 기능을 다음과 같이 제공      @PostMapping(\"/register/step3\")  public String handleStep3(RegisterRequest regReq){      ...  }        다음과 같이 요청 파라미터의 값을 전달 받을 수 있는 setter 매서드를 포함하는 객체를 커맨드 객체로 사용      // RegisterRequest.java  public class RegisterRequest {      ...      public void setEmail(String email) {          this.email = email;      }      public String getPassword() {          return password;      }      public void setPassword(String password) {          this.password = password;      }          ...  }          4-2. 뷰 JSP 코드에서 커맨드 객체 사용가입할 때 사용한 이메일 주소와 이름을 가입 완료 화면에서 커맨드 객체를 이용해 다음과 같이 표시 가능    ...    &lt;body&gt;        &lt;p&gt;&lt;strong&gt;${registerRequest.name}님&lt;/strong&gt;             회원 가입을 완료했습니다.&lt;/p&gt;        &lt;p&gt;&lt;a href=\"&lt;c:url value='/main'/&gt;\"&gt;[첫 화면 이동]&lt;/a&gt;&lt;/p&gt;    &lt;/body&gt;    &lt;/html&gt;  ${registerRequest.name}에서 registerRequest가 커맨드 객체에 접근시 사용한 속성 이름  스프링 MVC는 다음과 같이 커맨드 객체의 클래스 이름과 동일한 속성 이름을 사용해 커맨드 객체를 뷰에 전달          JSTL c tag는 여기를 참조        @PostMapping(\"/register/step3\")  public String handleStep3(RegisterRequest regReq){      ...  }  // 위와 같은 RegisterRequest 클래스 이름에서 첫 글자만 소문자로 변경해 아래와 같이 전달                &lt;p&gt;&lt;strong&gt;${registerRequest.name}님&lt;/strong&gt;       회원 가입을 완료했습니다.&lt;/p&gt;          4-3. @ModelAttribute 어노테이션으로 커맨드 객체 속성 이름 변경@PostMapping(\"/register/step3\")// 뷰 코드에서는 \"fromData\"라는 이름으로 커맨드 객체에 접근 가능public String handleStep3(@ModelAttribute(\"formData\") RegisterRequest regReq){      ...}  커맨드 객체에 접근할 때 사용할 속성 이름을 @ModelAttribute 어노테이션을 사용해 변경4-4. 커맨드 객체와 스프링 폼 연동  회원 정보를 입력할 때 중복된 이메일을 입력하면 텅 빈 폼을 보여주는데, 비어있으므로 입력한 값을 다시 입력해야 하는 불편함이 발생  다시 폼을 보여줄 때 커맨드 객체의 값을 폼에 채워주면 이런 불편함을 해소 가능  스프링 MVC가 제공하는 커스텀 태그를 사용해 간단한 커맨드 객체의 값 출력 가능  스프링은 &lt;form:form&gt; 태그와 &lt;form:input&gt; 태그를 제공      &lt;!-- step2.jsp --&gt;  &lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt;  ...  &lt;body&gt;      &lt;h2&gt;회원 정보 입력&lt;/h2&gt;      &lt;form:form action=\"step3\" modelAttribute=\"registerRequest\"&gt;      &lt;p&gt;          &lt;label&gt;이메일:&lt;br&gt;          &lt;form:input path=\"email\" /&gt;          &lt;/label&gt;      &lt;/p&gt;      &lt;p&gt;          &lt;label&gt;이름:&lt;br&gt;          &lt;form:input path=\"name\" /&gt;          &lt;/label&gt;      &lt;/p&gt;      &lt;p&gt;          &lt;label&gt;비밀번호:&lt;br&gt;          &lt;form:password path=\"password\" /&gt;          &lt;/label&gt;      &lt;/p&gt;  ...        &lt;form:form&gt; 태그를 사용하려면 커맨드 객체가 존재해야 함  따라서 다음과 같이 step2.jsp 뷰를 호출하는 컨트롤러 코드에 “registerRequest” 객체를 모델에 넣어야 함      // RegisterController.java  @Controller  public class RegisterController {      ...      @PostMapping(\"/register/step2\")      public String handleStep2(              @RequestParam(value = \"agree\", defaultValue = \"false\") Boolean agree,              Model model) {          if (!agree) {              return \"register/step1\";          }                  // 커스텀 태그 사용을 위해 커맨드 객체를 모델에 넣어줌          model.addAttribute(\"registerRequest\", new RegisterRequest());          return \"register/step2\";      }          ...  }          5. 컨트롤러 구현 없는 매핑step3.jsp에 존재하는 다음과 같은 코드는 가입 완료 후 첫 화면으로 복귀하는 역할    &lt;p&gt;&lt;a herf=\"c:url value='/main/'&gt;\"&gt;[첫 화면 이동]&lt;/a&gt;&lt;/p&gt;이 첫 화면이 단순히 환영 문구와 회원 가입으로 이동하는 링크를 제공한다면, 이를 위해 다음과 같은 컨트롤러를 구현해야 함    @Controller    public class MainController{        @RequestMapping(\"/main\")        public String main(){                return \"main\";        }    }  단순히 요청 경로와 뷰를 연결하기 위해 컨트롤러를 작성하는 낭비 발생  WebMvcConfigurer 인터페이스의 addViewControllers() 매서드를 이용해 다음과 같이 보완 가능      // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      ...      @Override      public void addViewControllers(ViewControllerRegistry registry) {          registry.addViewController(\"/main\").setViewName(\"main\");      }  }          6. 커맨드 객체: 중첩, 콜렉션 프로퍼티스프링 MVC는 다음과 같은 경우에 요청 파라미터의 값을 알맞게 커맨드 객체에 전달  커맨드 객체가 리스트 타입의 프로퍼티를 가졌거나  중첩 프로퍼티를 가진 경우각 경우의 규칙은 다음과 같다.  HTTP 요청 파라미터 이름이 \"프로퍼티이름[인덱스]\" 형식이면 리스트를 처리  HTTP 요청 파라미터 이름이 \"프로퍼티이름.프로퍼티이름\" 형식이면 중첩 프로퍼티를 처리    // AnsweredData.java    public class AnsweredData{        private List&lt;String&gt; responses;        private Respondent res;        ...    }    // Respondent.java    public class Respondent{        private int age;        private String location;        ...    }  AsnweredData 객체는 리스트 타입의 프로퍼티 responses를 가짐  AsnweredData 객체는 중첩 프로퍼티 res를 가짐    &lt;!-- surveyForm.jsp --&gt;    ...    1. 당신의 역할은?&lt;br/&gt;    &lt;label&gt;&lt;input type = \"radio\" name = \"response[0]\" value = \"서버\"&gt;        서버개발자&lt;/label&gt;    &lt;label&gt;&lt;input type = \"radio\" name = \"response[0]\" value = \"프론트\"&gt;        프론트개발자&lt;/label&gt;    &lt;label&gt;&lt;input type = \"radio\" name = \"response[0]\" value = \"풀스택\"&gt;        풀스택개발자&lt;/label&gt;    &lt;/p&gt;    &lt;p&gt;    2. 가장 많이 사용하는 도구는?&lt;br/&gt;    &lt;label&gt;&lt;input type = \"radio\" name = \"response[1]\" value = \"Eclipse\"&gt;        Eclipse&lt;/label&gt;    &lt;label&gt;&lt;input type = \"radio\" name = \"response[1]\" value = \"Intellij\"&gt;        Intellij&lt;/label&gt;    &lt;label&gt;&lt;input type = \"radio\" name = \"response[1]\" value = \"Sublime\"&gt;        Sublime&lt;/label&gt;    ...    &lt;label&gt;응답자 위치:&lt;br&gt;    &lt;input type=\"text\" name=\"res.location\"&gt;    &lt;/label&gt;    ...7. Model을 통해 컨트롤러에서 뷰에 데이터 전달컨트롤러는 뷰가 응답 화면을 구성하는데 필요한 데이터를 생성해서 Model을 이용하여 전달하며 다음과 같은 두 가지를 수행  요청 매핑 어노테이션이 적용된 매서드의 파라미터로 Model을 추가  Model 파라미터의 addAttribute() 매서드로 뷰에서 사용할 데이터 전달  앞선 예제에서 JSP 파일에 설문 항목을 하드 코딩한 부분을 컨트롤러에서 생성해 뷰에 전달하는 방법으로 변경    // SurveyController.java    @Controller    @RequestMapping(\"/survey\")    public class SurveyController {        @GetMapping            /*            * 1. 파라미터로 Model 타입을 추가            * 2. addAttribute() 매서드로 전달            */        public String form(Model model) {            List&lt;Question&gt; questions = createQuestions();            model.addAttribute(\"questions\", questions);            return \"survey/surveyForm\";        }            // 설문항목        private List&lt;Question&gt; createQuestions() {            Question q1 = new Question(\"당신의 역할은 무엇입니까?\",                    Arrays.asList(\"서버\", \"프론트\", \"풀스택\"));            Question q2 = new Question(\"많이 사용하는 개발도구는 무엇입니까?\",                    Arrays.asList(\"이클립스\", \"인텔리J\", \"서브라임\"));            Question q3 = new Question(\"하고 싶은 말을 적어주세요.\");            return Arrays.asList(q1, q2, q3);        }        @PostMapping        public String submit(@ModelAttribute(\"ansData\") AnsweredData data) {            return \"survey/submitted\";        }    }    &lt;!-- surveyForm.jsp --&gt;    ...    &lt;body&gt;        &lt;h2&gt;설문조사&lt;/h2&gt;        &lt;form method=\"post\"&gt;        &lt;c:forEach var=\"q\" items=\"${questions}\" varStatus=\"status\"&gt;        &lt;p&gt;            ${status.index + 1}. ${q.title}&lt;br/&gt;            &lt;c:if test=\"${q.choice}\"&gt;                &lt;c:forEach var=\"option\" items=\"${q.options}\"&gt;                &lt;label&gt;&lt;input type=\"radio\"                             name=\"responses[${status.index}]\" value=\"${option}\"&gt;                    ${option}&lt;/label&gt;                &lt;/c:forEach&gt;            &lt;/c:if&gt;            &lt;c:if test=\"${! q.choice }\"&gt;            &lt;input type=\"text\" name=\"responses[${status.index}]\"&gt;            &lt;/c:if&gt;        &lt;/p&gt;        &lt;/c:forEach&gt;    ...7-1. ModelAndView를 통한 뷰 선택과 모델 전달  지금까지 구현한 컨트롤러는 다음과 같은 특징을 지님          Model을 이용해 뷰에 전달할 데이터 설정      결과를 보여줄 뷰 이름을 리턴        ModelAndView를 사용하면 이 두 가지를 한번에 다음과 같이 처리 가능      // SurveyController.java    @Controller  @RequestMapping(\"/survey\")  public class SurveyController {      /*          * 기존 코드      @GetMapping      public String form(Model model) {          List&lt;Question&gt; questions = createQuestions();          model.addAttribute(\"questions\", questions);          return \"survey/surveyForm\";      }          */      @GetMapping      public ModelAndiew form() {          List&lt;Question&gt; questions = createQuestions();          mav.addObject(\"questions\", questions);          mav.setViewName(\"survey/surveyFrom\");          return mav;      }  }          8. 주요 폼 태그스프링 MVC는 &lt;form:form&gt;, &lt;form:input&gt; 등 HTML 폼과 커맨드 객체를 연동하기 위한 JSP 태그 라이브러리를 제공8-1. &lt;form&gt; 태그를 위한 커스텀 태그 : &lt;form:form&gt;  &lt;form&gt; 커스텀 태그는 &lt;form&gt; 태그를 생성할 때 사용      &lt;form:form&gt;  ...  &lt;input type=\"submit\" value=\"가입 완료\"&gt;  &lt;/form:form&gt;        &lt;form:form&gt; 태그의 method 속성과 action 속성의 기본값은 각각 post와 현재 요청 URL          만약 요청 URL이 “/sp5-chap11/register/step2” 라면 앞선 태그는 다음의 &lt;form&gt; 태그를 생성  ~~~jsp          ...  &lt;/from&gt;  ~~~      커맨드 객체의 이름이 기본값인 “command”가 아니라면 다음과 같이 modelAttribute 속성값으로 설정      &lt;form:form modelAttribute=\"loginCommand\"&gt;  ...  &lt;/form&gt;        다음과 같이 커멘드 객체를 이용해 이전에 입력한 값을 출력 가능      &lt;form:from modelAttribute=\"loginCommand\"&gt;  ...      &lt;input type=\"text\" name=\"id\" value=\"${loginCoomand.id}\" /&gt;  ...  &lt;/form:form&gt;              이때 input을 직접 사용하기 보다는 &lt;form:input&gt; 등의 태그를 사용하면 편리      8-2. &lt;input&gt; 관련 커스텀 태그: &lt;form:input&gt;, &lt;form:password&gt;, &lt;form:hidden&gt;  스프링은 다음과 같은 커스텀 태그를 제공          &lt;form:input&gt;: text 타입 &lt;input&gt; 태그      &lt;form:password&gt;: passowrd 타입 &lt;input&gt; 태그      &lt;form:hidden&gt;: hidden 타입 &lt;input&gt; 태그        &lt;form:input&gt; 커스텀 태그는 다음과 같이 path 속성을 사용해 연결할 커맨드 객체의 프로퍼티를 지정      &lt;form:form modelAttribute=\"registerRequest\" action=step3\"&gt;  &lt;p&gt;      &lt;label&gt;이메일:&lt;br/&gt;      &lt;form:input path=\"email\"/&gt;      &lt;/label&gt;  &lt;/p&gt;  &lt;!-- 위 코드는 아래와 같이 HTML &lt;input&gt; 태그를 생성 --&gt;  &lt;form id=\"registerRequest\" action=step3\" method=\"post\"&gt;  &lt;p&gt;      &lt;label&gt;이메일:&lt;br/&gt;      &lt;input id=\"email\" name=\"email\" type=\"text\" value=\"\"/&gt;      &lt;/label&gt;  &lt;/p&gt;          8-3. &lt;select&gt; 관련 커스텀 태그: &lt;form:select&gt;, &lt;form:options&gt;, &lt;form:option&gt;  스프링은 다음과 같은 커스텀 태그를 제공          &lt;form:select&gt;: &lt;select&gt; 태그를 생성, &lt;option&gt; 태그를 생성할 때 필요한 콜렉션을 전달 받을 수 있음      &lt;form:password&gt;: 지정한 콜렉션 객체를 이용하여 &lt;option&gt; 태그를 생성      &lt;form:hidden&gt;: &lt;option&gt; 태그를 한 개 생성        &lt;select&gt; 태그는 선택 옵션을 제공할 때 주로 사용  &lt;select&gt; 태그에서 사용할 옵션 목록을 Model을 통해 전달하면 뷰에서 다음과 같이 간단하게 태그 생성 가능      &lt;form:form modelAttriute=\"login\"&gt;  &lt;p&gt;      &lt;label for=\"loginType\"&gt;로그인 타입&lt;/label&gt;      &lt;!-- loginTypes에는 모델에서 넘어온 로그인 타입 관련 array등이 저장됨 --&gt;      &lt;form:select path=\"loginType\" items=\"${loginTypes}\" /&gt;  &lt;/p&gt;  ...  &lt;/form:form&gt;          8-4. 체크박스 관련 커스텀 태그: &lt;form:checkboxes&gt;, &lt;form:checkbox&gt;  배열이나 List 타입을 이용해 한 개 이상의 값을 커맨드 객체에 저장 후 HTML 폼에서는 checkbox 타입 태그 사용  스프링은 다음과 같은 커스텀 태그를 제공          &lt;form:checkboxes&gt;: 커맨드 객체의 특정 프로퍼티와 관련된 checkbox 타입의 &lt;input&gt; 태그 목록 생성      &lt;form:checkbox&gt;:  커맨드 객체의 특정 프로퍼티와 관련된 한 개의 checkbox 타입 &lt;input&gt; 태그 생성          &lt;p&gt;      &lt;!-- favoriteOsNames에 존재 하는 값들에 대한 체크박스를 생성 --&gt;      &lt;label&gt;선호 OS&lt;/label&gt;      &lt;form:checkboxes items=\"${favoriteOsNames}\" paht = \"favoriteOs\" /&gt;  &lt;/p&gt;                            8-4. 라디오버튼 관련 커스텀 태그: &lt;form:radiobuttons&gt;, &lt;form:radiobutton&gt;  여러 옵션중 한 가지를 선택해야 하는 경우 radio 타입의 &lt;input&gt; 태그를 사용  스프링은 다음과 같은 커스텀 태그를 제공          &lt;form:radiobuttons&gt;: 커맨드 객체의 특정 프로퍼티와 관련된 radio 타입의 &lt;input&gt; 태그 목록 생성      &lt;form:radiobutton&gt;:  커맨드 객체의 특정 프로퍼티와 관련된 한 개의 radio 타입 &lt;input&gt; 태그 생성        다음과 같이 items 속성에 값으로 사용할 콜렉션을 전달받고 path 속성에 커맨드 객체의 프로퍼티를 지정      &lt;p&gt;      &lt;label&gt;주로 사용하는 개발툴&lt;/label&gt;      &lt;form:radiobuttons items=\"${tools}\" path=\"tool\"/&gt;  &lt;/p&gt;          8-5. &lt;textarea&gt; 태그를 위한 커스텀 태그: &lt;form:textarea&gt;  게시글 내용과 같이 여러 줄을 입력받아야 하는 경우 사용  스프링은 커맨드 객체와 관련된 &lt;textarea&gt;태그를 생성하는 &lt;form:textarea&gt; 커스텀 태그를 제공      &lt;p&gt;      &lt;label for=\"etc\"&gt;기타&lt;/label&gt;      &lt;form:textarea path=\"etc\" cols=\"20\" rows=\"3\" /&gt;  &lt;/p&gt;      ",
        "url": "/devlog/2019/12/30/spring-11.html"
      }
      ,
    
      "devlog-2019-12-30-spring-10-html": {
        "title": "[Spring] 스프링 MVC 동작방식",
        "subtitle":"첫걸음 - 10",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 스프링 MVC 핵심 구성 요소MVC 프레임워크의 흐름은 다음과 같다.  DispatcherServlet이 모든 연결을 담당하며, 웹 브라우저로부터 요청을 받음            요청이 들어오면 DispathcerServlet는 HandlerMapping Bean 객체에게 컨트롤러 검색을 요청      HandlerMapping은 클라이언트의 요청 경로를 이용해 컨트롤러 Bean객체를 DispathcerServlet에게 전달        DispathcerServlet은 전달받은 객체를 처리할 수 있는 HandlerAdapter Bean에게 요청 처리를 위임  HandlerAdapter는 컨트롤러의 알맞은 매서드를 호출해 요청을 처리  그 후, 결과를 ModelAndView라는 객체로 DispathcerServlet에게 반환            DispathcerServlet는 전달받은 결과를 보여줄 뷰를 찾기 위해 ViewResolver Bean 객체를 사용      ViewResolver는 ModelAndView 내부에 있는 뷰 이름에 해당하는 View 객체를 찾거나 생성후 리턴        DispathcerServlet는 VeiwResolver가 리턴한 View 객체에게 응답 결과 생성을 요청1-1. 컨트롤러와 핸들러  클라이언트의 요청을 실제로 처리하는 것은 컨트롤러  DispathcerServlet는 클라이언트의 요청을 전달받는 창구 역할  HandlerMapping은 특정 요청 경로를 처리해주는 핸들러를 찾아주는 역할  HandlerAdapter는 핸들러의 처리결과를 ModelAndView 객체로 변환하여 DispathcerServlet에게 전달2. @Controller를 위한 HandlerMapping과 HandlerAdapter    // ControllerConfig.java    @Configuration    @EnableWebMvc    public class MvcConfig{        ...    }  @EnableWebMvc 어노테이션을 통해 HandlerMapping이나 HandleAdapter 설정을 자동으로 추가    // HelloController.java    @Controller    public class HelloController {        @GetMapping(\"/hello\")        public String hello(Model model,                @RequestParam(value = \"name\", required = false) String name)             {            model.addAttribute(\"greeting\", \"안녕하세요, \" + name);            return \"hello\";        }    }  @EnableWebMvc 어노테이션은 @Controller 타입의 핸들러 객체를 처리하기 위한 클래스를 포함  그 중 하나가 RequestMappingHandlerMapping이며, 이 어노테이션은 @GetMapping 어노테이션 값을 이용해서 웹 브라우저의 요청을 처리할 컨트롤러 Bean을 찾음          GET &amp; POST는 여기를 참조        앞선 코드에서 @GetMapping에서 “/hello”라는 요청 경로에 대해 hello() 매서드를 호출이때 Model 객체를 생성해 첫 번째 파라미터로, HTTP 요청 파라미터를 두 번째 파라미터로 전달  RequestMappingHandlerAdapter는 컨트롤러 매서드 결과 값이 String 타입이면,해당값을 뷰 이름으로 갖는 ModleAndView 객체를 생성해 DispatcherServlet에 리턴          위의 예제에서 결국 뷰의 이름은 hello가 된다.      3. JSP를 위한 ViewResolver  컨트롤러 처리 결과를 JSP를 이용해서 생성하기 위해 다음 설정을 사용      // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      ...      @Override      public void configureViewResolvers(ViewResolverRegistry registry) {          registry.jsp(\"/WEB-INF/view/\", \".jsp\"); // 접두사, 접미사 설정      }  }        WebMvcConfigurer 인터페이스에 정의된,          configureViewResolvers() 매서드의 파라미터 ViewResolverRegistry의 jsp() 매서드를 이용해 ViewResolver를 설정가능      내부 클래스를 이용하여 다음과 같이 뷰 이름에 해당하는 객체를 요청          @Bean  public ViewResolver viewResolver(){   InternalResourceViewResolver vr =        new InternalResourceViewResolver();   vr.setPrefix(\"/WEB-INF/view/\");   vr.setSurfix(\".jsp\");   return vr;  }                      앞선 코드의 구성처럼, \"prefix + 뷰이름 \" surfix\"에 해당하는 경로를 할당  DispatcherServlet이 View 생성을 요청하면 InternalResourceViewResolver는 이 JSP 코드를 실행하여 결과 생성4. 디폴트 핸들러와 HandlerMapping의 우선순위  web.xml 파일을 참조하면, DispatcherServlet에 대한 매핑 경로가 다음과 같이 '/'로 설정      &lt;!-- web.xml --&gt;  &lt;servlet-mapping&gt;      &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;      &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;        매핑 경로가 ‘/’인경우 .jsp로 끝나는 요청을 제외한 모든 요청을 DispatcherServlet이 처리  하지만 앞선 코드에서처럼 HandlerMapping으로 @GetMapping(“/hello”) 설정을 사용하였다면, /hello 경로만 처리가능하므로 “/index.html”등의 요청을 처리할 컨트롤러를 찾을 수 없음  이러한 경로를 처리하기 위한 컨트롤러 객체를 직접 구현할 수도 있지만 다음과 같이, WebMvcConfigurer의 configureDefaultServletHandling() 매서드를 사용하는 것이 편리      // MvcConfig.java  @Configuration  @EnableWebMvc  public class MvcConfig implements WebMvcConfigurer {      @Override      public void configureDefaultServletHandling          (DefaultServletHandlerConfigurer configurer)       {          configurer.enable();      }      ...        위 설정에서 enable() 매서드는 다음의 두 Bean 객체를 추가          DefaultServletRequestHandler      SimpleUrlHandlerMapping        DefaultServletRequestHandler는 클라이언트의 모든 요청을 WAS가 제공하는 디폴트 서블릿에 전달          “/index.html”에 대한 처리를 결국 디폴트 서블릿이 처리하도록 만듦            그리고 SimpleUrlHandlerMapping를 이용하여 모든 경로(“/**“)를 DefaultServletHttp RequestHandler를 이용해 처리하도록 함    @EnableWebMvc 어노테이션이 등록하는 HandlerMapping의 적용 우선순위가 enable() 매서드가 등록하는 디폴트 핸들러보다 높음  따라서 다음과 같은 방식으로 요청을 처리          RequestMappingHandlerMapping을 사용해 요청 처리할 핸들러 검색                  존재하면 해당 컨트롤러를 이용해 요청을 처리                    존재하지 않으면 SimpleUrlHandlerMapping을 사용해 요청을 처리할 핸들러 검색                  모든 경로에 대해 DefaultServletHttpRequestHandler를 리턴          DispatcherServlet은 DefaultServletHttpRequestHandler에 처리를 요청          DefaultServletHttpRequestHandler는 디폴트 서블릿에 처리를 위임                          예를 들어 “/index.html” 경로로 요청이 들어오면, 1과정에서 해당하는 경로를 찾지 못하므로,   2과정을 통해 디폴트 서블릿이 /index.html 요청을 처리하게 됨                                          ",
        "url": "/devlog/2019/12/30/spring-10.html"
      }
      ,
    
      "devlog-2019-12-30-spring-9-html": {
        "title": "[Spring] 스프링 MVC 시작하기",
        "subtitle":"첫걸음 - 9",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "0. Goal  스프링 MVC 설정  웹 브라우저의 요청을 처리할 컨트롤러 구현  컨트롤러의 처리 결과를 보여줄 뷰 코드 구현  이어지는 확장은 다음과 같다.      컨트롤러에서 서비스나 DAO를 사용해 클라이언트의 요청 처리    컨트롤러에서 요청 파라미터의 값을 하나의 객체로 받고 값 검증    스프링이 제공하는 JSP 커스텀 태그를 이용해서 폼 처리    컨트롤러에서 세션이나 쿠키를 사용    인터셉터로 컨트롤러에 대한 접근 처리    JSON 응답처리  0-1. MVC란?  MVC는 디자인 패턴중 하나로, Model, View, Controller의 약자      하나의 애플리케이션이나 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴        controller는 model을 통해서 데이터를 가져오고, 그 정보를 바탕으로 시각적인 표현을 담당하는 view를 제어해서 사용자에게 전달  각 구성요소가 지니는 특징은 다음과 같다.          Model                  사용자가 원하는 모든 데이터를 가지고 있어야 한다.          뷰나 컨트롤러에 관한 정보는 알 수 없다.          변경이 일어나면 변경 통지에 대한 처리방법을 구현해야만 한다.                    View                  모델이 가지고 있는 정보를 따로 저장해서는 안된다.          모델이나 컨트롤러와 같이 다른 구성요소들을 알 수 없다.          변경이 일어나면 변경통지에 대한 처리방법을 구현해야만 한다.                    Controller                  모델이나 뷰에 대해서 알고 있어야 한다.          모델이나 뷰의 변경을 모니터링 해야 한다.                      MVC패턴을 사용함으로써 유지보수성, 확장성, 유연성이 증가하고 중복코딩은 사라지게 됨0-2. 스프링 MVC 주요 구성 요소 및 처리 흐름  Dispatcher: 클라이언트의 요청을 전달받아 요청에 맞는 컨트롤러가 리턴한 결과값을 View에 전달하여 알맞은 응답을 생성  HandlerMapping: 클라이언트의 요청 URL을 어떤 컨트롤러가 처리할지 결정  Controller: 클라이언트의 요청을 처리한 뒤, 결과를 DispatcherServlet에게 리턴  ModelAndView: 컨트롤러가 처리한 결과 정보 및 뷰 선택에 필요한 정보를 담음  ViewResolver: 컨트롤러의 처리 결과를 생성할 뷰를 결정  View: 컨트롤러의 처리 결과 화면을 생성, JSP 또는 Velocity 템플릿 파일 등을 뷰로 사용1. 프로젝트 설정웹 어플리케이션 개발을 위한 메이븐 프로젝트의 디렉토리 구조는 다음과 같다.  src/main.java  src/main/webapp  src/main/webapp/WEB_INF  src/main/webapp/WEB_INF/view1-1. pom.xml      기존 pom.xml 파일에 다음과 같은 dependency를 추가      &lt;packaging&gt;war&lt;/packaging&gt;  &lt;!-- 아래부터 dependency --&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;  &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;  &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;jstl&lt;/artifactId&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;          1-2. Tomcat 설정  본 프로젝트에서는 Tomcat 8.5.43 버전을 기준으로 수행2. 스프링 MVC 기본 설정스프링 MVC 실행을 위해 필요한 최소한의 설정은 다음과 같다.      스프링 MVC의 주요 설정 - HandlerMapping, ViewResolver        스프링의 DispatcherServlet 설정  2-1. 스프링 MVC 설정    // MvcConfig.java      @Configuration    @EnableWebMvc  // 스프링 MVC 설정을 활성화하는 어노테이션    public class MvcConfig implements WebMvcConfigurer {            /*            * DispatcherServlet의 매핑경로를 '/'으로 주었을 때,              * JSP/HTML/CSS 등을 올바르게 처리하기 위한 설정을 추가            */        @Override        public void configureDefaultServletHandling(                DefaultServletHandlerConfigurer configurer) {            configurer.enable();        }            // JSP를 이용해 컨트롤러의 실행 결과를 보여주기 위한 설정 추가        @Override        public void configureViewResolvers(ViewResolverRegistry registry) {            registry.jsp(\"/WEB-INF/view/\", \".jsp\");        }    }  기존의 복잡한 설정을 대체하는 @EnableWebMvc 어노테이션을 이용시, 내부적으로 다양한 빈 설정을 추가해줌  WebMvcConfigurer 인터페이스는 스프링 MVC 개별 설정을 조절할 때 사용2-2. web.xml 파일에 DispatcherServlet 설정      스프링 MVC가 웹 요청을 처리하려면 DispatcherServlet을 통해 웹 요청을 받아야 함        이를 위해 web.xml 파일에 DispatcherServlet을 등록          web.xml 파일은 src/main/webapp/WEB_INF/ 에 위치      3. 코드 구현다음 두 가지 코드를 구현  클라이언트의 요청을 알맞게 처리할 컨트롤러  처리 결과를 보여줄 JSP3-1. 컨트롤러 구현    // HelloController.java    @Controller // 컨트롤러로 지정    public class HelloController {        @GetMapping(\"/hello\") // 메서드가 처리할 요청 경로를 지정, 이 경우 /hello 경로        public String hello(Model model,                // name 요청 파라미터 값을 name 파라미터에 전달                @RequestParam(value = \"name\", required = false) String name) {            model.addAttribute(\"greeting\", \"안녕하세요, \" + name);            return \"hello\"; // 컨트롤러의 처리 결과를 보여줄 뷰 이름으로 \"hello\"를 사용        }    }  스프링 MVC 프레임워크에서 컨트롤러란 웹 용청을 처리하고 그 결과를 뷰에 전당하는 스프링 Bean 객체  컨트롤러로 사용될 클래스는 @Controller 어노테이션을 붙임  @GetMapping 어노테이션이나 @PostMapping 어노테이션과 같은 요청 매핑 어노테이션을 이용해 경로 지정  @RequestParam 어노테이션은 HTTP 요청 파라미터를 매서드의 파라미터로 전달          http://localhost:8080/sp5-chap09/hello?name=bk여기서 name의 파라미터에 해당하는 값을 전달            addAttribute() 매서드는 뷰에 전달할 데이터를 지정하기 위해 사용      // ControllerConfig  @Configuration  public class ControllerConfig {      @Bean      public HelloController helloController() {          return new HelloController();      }  }        컨트롤러를 스프링의 Bean객체로 등록3-2. JSP 구현      컨트롤러가 생성한 결과를 보여줄 뷰 코드는JSP로 구현      &lt;%-- hello.jsp --%&gt;  &lt;%@ page contentType=\"text/html; charset=utf-8\" %&gt;  &lt;!DOCTYPE html&gt;  &lt;html&gt;  &lt;head&gt;      &lt;title&gt;Hello&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;      인사말: ${greeting}  &lt;/body&gt;  &lt;/html&gt;        HelloController()의 hello() 매서드가 리턴한 뷰 이름은 “hello”와 동일한 파일명      뷰 이름과 JSP 파일과의 연결은 MvcConfig 설정 클래스의 다음 설정을 통해 이루어짐      // MvcConfig.java  @Override  public void configureViewResolvers(ViewResolverRegistry registry) {      registry.jsp(\"/WEB-INF/view/\", \".jsp\");  }            다음과 같이 사용된 JSP EL(Expression Language)는 컨트롤러의 구현에서 Model에 추가한 속성의 이름과 동일      인사말: ${greeting}        실행결과주소창에 http://localhost:8080/sp5-chap09/hello?name=bk 를 입력하였을 경우 다음과 같은 화면이 출력인사말: 안녕하세요, bk",
        "url": "/devlog/2019/12/30/spring-9.html"
      }
      ,
    
      "devlog-2019-12-30-spring-8-html": {
        "title": "[Spring] DB 연동",
        "subtitle":"첫걸음 - 8",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1.스프링의 DB 연동 이점  스프링은 기존의 jdbc의 단점(구조적으로 반복되는 비핵심기능들)을 보완          jdbc는 여기를 참조        자바8의 람다를 사용하면 더 효율적인 개선 가능  트랙잭션의 관리가 쉬움          트랜잭션은 데이터베이스 뿐 아니라, 한번에 처리해야할 일의 묶음, 단위를 보장하는 의미로 사용      1-1. Maven 프로젝트 생성    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;        &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt;        &lt;version&gt;8.5.27&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.16&lt;/version&gt;    &lt;/dependency&gt;  spring-jdbc: JdbcTemplate 등 JDBC 연동에 필요한 기능을 제공  tomcat-jdbc: DB 커넥션풀 기능을 제공  mysql-connector-java: MySQL 연결에 필요한 JDBC 드라이버 제공          DB 커넥션풀은 여기를 참조      1-2. DB 테이블 생성  MySQL 5.7.27 버전 사용  ID(Primary Key), EMAIL(Unique Key), PASSWORD, NAME, REGDATE을 필드로 갖는 테이블 MEMBER 생성1-3. DataSource 설정JDBC API는 DriverManager 외에 DataSource를 이용해 DB 연결을 구하는 방법을 다음과 같이 정의    Connection conn = null;    try{        // datasource는 생성자나 설정 매서드를 이용해 주입        conn = dataSource.getConnection();        ...  스프링이 제공하는 DB연동 기능은 DataSource를 사용해 DB Connection을 구함  DB 연동에 사용할 DataSource를 스프링 Bean으로 등록하고,DB 연동 기능을 구현한 Bean객체는 DataSource를 주입받아 사용      // AppCtx.java  @Configuration  public class AppCtx {          /*           * datasource() 매서드를 통해 DataSource를 스프링 Bean으로 등록          * 아래의 destroyMethod = \"close\"를 지정함으로써,           * 커넥션 풀에 보관된 Connection들을 닫는 매서드 호출까지를 Bean의 생명주기로 지정          */      @Bean(destroyMethod = \"close\")      public DataSource dataSource() {          // DataSource 객체 생성          DataSource ds = new DataSource();          // JDBC 드라이버 클래스를 지정, 여기서는 MYSQL 드라이버 클래스 사용          ds.setDriverClassName(\"com.mysql.jdbc.Driver\");          // URL 지정          ds.setUrl(\"jdbc:mysql://localhost/spring5fs?characterEncoding=utf8\");          // 계정 &amp; 암호 지정          ds.setUsername(\"spring5\");          ds.setPassword(\"spring5\");          ...          return ds;      }          ...      @Bean      public MemberDao memberDao() {          return new MemberDao(dataSource());      }          ...  }          2. JdbcTemplate을 이용한 쿼리 실행스프링에서는 DataSource, Connection, Statement 및 ResultSet을 직접 사용하지 않고,JdbcTemplate을 이용해 편리하게 쿼리 실행 가능  DB의 데이터에 접근하는 자세한 방법은 여기를 참조2-1. JdbcTemplate 생성    // MemberDao.java    public class MemberDao {        private JdbcTemplate jdbcTemplate;            // 필요한 dataSorce 객체를 주입받음        public MemberDao(DataSource dataSource) {            this.jdbcTemplate = new JdbcTemplate(dataSource);        }        ...    }2-2. JdbcTemplate을 이용한 조회 쿼리 실행  JdbcTemplate 클래스는 SELECT 쿼리 실행을 위한 query() 매서드를 다음과 같이 제공          List quey(String sql, RowMapper rowMapper)      List quey(String sql, Object[] args, RowMapper rowMapper)      List quey(String sql, RowMapper rowMapper, Object... args)        sql의 파라미터가 아래와 같이 인덱스 기반 파라미터를 가진 쿼리라면,args 파라미터를 이용하여 각 인덱스의 파라미터의 값을 지정          select * from member where email=?        RowMapper의  mapRow() 매서드는 실행 결과로 구한 ResultSet의 한 행을 읽어와 자바 객체로 변환해주는 매퍼 기능 제공          ResultSet이란 SELECT문을 사용하여 얻어온 레코드 값들을 테이블의 형태로 갖게 되는 객체          // MemberDao.java  public class MemberDao {          ...      // 조회 쿼리 기능을 구현      public Member selectByEmail(String email) {          List&lt;Member&gt; results = jdbcTemplate.query(                  \"select * from MEMBER where EMAIL = ?\",                  new RowMapper&lt;Member&gt;() {                      @Override                      public Member mapRow(ResultSet rs, int rowNum) throws SQLException {                          Member member = new Member(                                  rs.getString(\"EMAIL\"),                                  rs.getString(\"PASSWORD\"),                                  rs.getString(\"NAME\"),                                  rs.getTimestamp(\"REGDATE\").toLocalDateTime());                          member.setId(rs.getLong(\"ID\"));                          return member;                      }                  }, email);                  /*                   * query() 매서드는 쿼리를 실행한 결과가 존재하지 않으면 0인 list를 반환하므로                  * list가 비어있는지 여부로 결과가 존재하지 않는지 확인할 수 있음                  */          return results.isEmpty() ? null : results.get(0);      }        selectByEamil 매서드의 JdbcTemplate query() 매서드는 다음과 같이 인덱스 파라미터(물음표)를 포함  인덱스 파라미터에 들어갈 값은 query() 매서드 맨 마지막 부분의 email 에서 전달      List&lt;Member&gt; results = jdbcTemplate.query(      \"select * from MEMBER where EMAIL = ?\",      new RowMapper&lt;Member&gt;() {...코드생략},          email); // 물음표에 해당하는 값 전달          2-3. 결과가 1행인 경우 사용할 수 있는 queryForObject() 매서드  count(*)과 같이 결과가 한 행으로 실행되는 경우 사용      // MemberDao.java  public class MemberDao {      ...      public int count() {          Integer count = jdbcTemplate.queryForObject(                  \"select count(*) from MEMBER\", Integer.class);          return count;      }  }        queryForObject() 매서드의 두 번째 파라미터는 칼럼을 읽어올 때 사용할 타입을 지정      실행 결과 칼럼이 두 개 이상이면 RowMapper를 파라미터로 전달해 결과 생성          queryForObject() 매서드를 사용하려면 쿼리 실행 결과는 반드시 한 행이어야 함만약 행이 없거나, 두 개 이상이면 익셉션이 발생      2-4. JdbcTemplate을 이용한 변경 쿼리 실행  JdbcTemplate 클래스는 INSERT, UPDATE, DELETE 쿼리 실행을 위한 update() 매서드를 다음과 같이 제공          int update(String sql)      int update(String sql, Object… args)            update() 매서드는 쿼리 실행 결과로 변경된 행의 개수를 반환      // MemberDao.java  public class MemberDao {      ...      public void update(Member member) {          jdbcTemplate.update(                  \"update MEMBER set NAME = ?, PASSWORD = ? where EMAIL = ?\",                  member.getName(), member.getPassword(), member.getEmail());      }          2-5. PreparedStatementCreator를 이용한 쿼리 실행  앞선 예제 코드의 경우, 첫 번째, 두 번째 세 번째 파라미터의 값으로 각각 접근자를 이용해 인덱스 파라미터의 값을 전달하지만 직접 인덱스 파라미터의 값을 설정해야 할 경우, 설정자를 이용해 설정 가능      PreparedStatementCreator를 인자로 받는 매서드를 이용해 아래와 같이 사용        jdbcTemplate.update(new PreparedSatementCreator(){          @Override          public PreparedStatement createPreparedStatement(Connection con)          throws SQLException{                  // 파라미터로 전달받은 Connection을 이용해 PreparedStatement 생성                  PreparedStatement pstmt = con.prepareStatement(                      \"insert into MEMBER (EMAIL, PASSWORD, NAME, REGDATE) values (?,?,?,?)\");                  // 인덱스 파라미터 값 설정                  pstm.setString(1, member.getEmail());                  pstm.setString(2, member.getPassword());                  pstm.setString(1, member.getName());                  pstm.setString(1, Timestamp.valueOf(member.getRegisterDateTime()));                  // 생성한 PreparedStatement 객체 리턴                  return pstm;          }  });                  2-6. INSERT 쿼리 실행 시 KeyHolder를 이용해 자동 생성 키 값 구하기  MySQL의 AUTO_INCREMENT 칼럼을 가진 테이블에 값을 삽입하면 해당 칼럼의 값이 자동으로 생성되므로,다음과 같이 INSERT 쿼리에 자동 증가 칼럼에 해당하는 값이 지정되지 않음      jdbcTemplate.update(          \"insert into MEMBER (EMAIL, PASSWORD, NAME, REGDATE) values (?,?,?,?)\",          member.getEmail(), member.getPassword(), member.getName(),           new Timestamp(member.getRegisterDateTime()));        이러한 키 값을 KeyHolder를 사용해 다음과 같이 구할 수 있다.      // MemberDao.java  public class MemberDao {      ...      public void insert(Member member) {          KeyHolder keyHolder = new GeneratedKeyHolder();          jdbcTemplate.update(new PreparedStatementCreator() {              @Override              public PreparedStatement createPreparedStatement(Connection con)                      throws SQLException {                  // 파라미터로 전달받은 Connection을 이용해서 PreparedStatement 생성                  PreparedStatement pstmt = con.prepareStatement(                          \"insert into MEMBER (EMAIL, PASSWORD, NAME, REGDATE) \" +                          \"values (?, ?, ?, ?)\",                          new String[] { \"ID\" });                                                   // 여기서 자동 증가하는 key값을 두 번째 파라미터로 전달                   // 인덱스 파라미터 값 설정                  pstmt.setString(1, member.getEmail());                  pstmt.setString(2, member.getPassword());                  pstmt.setString(3, member.getName());                  pstmt.setTimestamp(4,                          Timestamp.valueOf(member.getRegisterDateTime()));                  // 생성한 PreparedStatement 객체 리턴                  return pstmt;              }          }, keyHolder);          Number keyValue = keyHolder.getKey();          member.setId(keyValue.longValue());      }          ...        keyHolder 구현 클래스인 GeneratedKeyHolder 객체를 생성  preparedStatement의 두 번째 파라미터로 new String[] {“ID”}(자동 증가 칼럼)을 전달  update() 매서드에 두 번째 파라미터로 keyHolder를 전달          KeyHolder keyHolder = new GeneratedKeyHolder();jdbcTemplate.update(new PreparedStatementCreator(){…생략}, keyHolder);        여기까지 진행 후, Main 실행시, The server time zone value ‘KST’ ~~~ 라는 익셉션이 발생 MySQL 5.1.X 이후 KST 타임존을 인식하지 못하는 에러가 발생 /etc/mysql/mysql.condf.d 설정 변경(경로는 상이할 수 있음)3. 트래잭션 처리  트랜잭션(Transaction)이란?: 두 개 이상의 쿼리를 한 작업으로 실행할 때 사용  Commit, Rollback을 통해 전부 반영하거나 기존 상태로 되돌림  JDBC는 Connection의 setAutoCommit(false)을 이용해 다음과 같이 트랜잭션을 시작하고 반영하거나 취소함      Connection conn = null;  try{      ...      conn.setAutoCommit(false); // 트랜잭션 범위 시작      ... 쿼리실행      conn.commit(); // 트랜잭션 범위 종료: 커밋  }  catch(SQLException ex){      if(conn != null)          // 트랜잭션 범위 종료: 롤백          try{ conn.rollback(); } catch (SQLException e){}  }  finally{      if(conn!= null)          try{ conn.close(); } catch(SQLException e){}  }        위와 같은 방식은 코드로 직접 트랜잭션의 범위를 설정하기 때문에, 개발자가 커밋이나 롤백을 누락하기 쉬움이에 다음에 나오는 스프링이 제공하는 방식을 사용3-1. @Tracsactional을 이용한 트랜잭션 처리  트랜잭션 범위에서 실행하고 싶은 매서드에 다음과 같이 @Transactional 어노테이션을 붙임      // ChangePasswordService.java  public class ChangePasswordService {      private MemberDao memberDao;              /* 어노테이션을 사용해 트랜잭션 범위 설정      * 따라서 memberDao.selectByEmail()에서 실행하는 쿼리와      * member.changePassword()에서 실행하는 쿼리는 한 트랜잭션에 묶임      */      @Transactional      public void changePassword(String email, String oldPwd, String newPwd) {          Member member = memberDao.selectByEmail(email);          if (member == null)              throw new MemberNotFoundException();          member.changePassword(oldPwd, newPwd);          memberDao.update(member);      }      ...  }        @Transactional 어노테이션의 올바른 작동을 위해 다음과 같은 설정이 필요          플랫폼 트랜잭션 매니저(PlatformTransactionManager) Bean 설정      @Transactional 어노테이션 활성화 설정          // AppCtx.java  @Configuration  // 다음 어노테이션을 통해 @Transactional 어노테이션 활성화  @EnableTransactionManagement  public class AppCtx {  ....  @Bean      // 플랫폼 트랜잭션 매니저 Bean 설정  public PlatformTransactionManager transactionManager() {      DataSourceTransactionManager tm = new DataSourceTransactionManager();      tm.setDataSource(dataSource());      return tm;  }                            3-2. @Transactional과 프록시  스프링은 @Transactional 어노테이션을 이용해 트랜잭션을 처리시, 내부적으로 AOP를 사용      트랜잭션 처리는 프록시를 통해 이루어짐      // MainForCPS.java  public class MainForCPS {      public static void main(String[] args) {          AnnotationConfigApplicationContext ctx =                   new AnnotationConfigApplicationContext(AppCtx.class);          /*          * 아래 코드를 실행시, ChangePasswordService 객체 대신          * 트랜잭션 처리를 위해 생성한 프록시를 리턴함          */          ChangePasswordService cps =                   ctx.getBean(\"changePwdSvc\", ChangePasswordService.class);          ...  }              위의 코드가 실행되기까지 과정은 다음과 같다.              MainForCPS -&gt; 프록시 (changePasswordService) -&gt; 플랫폼 트랜잭션 매니저 -&gt; 실제 기능(ChansgePasswordService)프록시 객체는 @Transactional 어노테이션이 붙은 매서드를 호출하면 플랫폼 트랜잭션 매니저를 사용해 트랜잭션을 시작        결과에 따라 커밋하거나 롤백            3-3. 트랜잭션 전파  트랜잭션 전파: 트랜잭션이 이미 실행되고 있는데, 내부에서 또 다른 트랜잭션이 수행되는 경우  스프링에서 @Transactional의 propagation 속성은 기본값이 Propagation.REQUIRED로서 이미 수행된 트랜잭션이 있다면, 트랜잭션을 새로 생성하지 않음(기존 트랜잭션 그대로 사용)  @Transactional의 주요 속성      value / propagation / isolation / timeout    Propagation의 주요 속성      REQUIRED / MANDATORY / REQUIRES_NEW / SUPPORTS / NOT_SUPPORTED / NEVER / NESTED    Isolation의 주요 속성      DEFAULT / READ_UNCOMMITED / READ_COMMITED / REPEATABLE_READ / SERIALIZABLE  ",
        "url": "/devlog/2019/12/30/spring-8.html"
      }
      ,
    
      "devlog-2019-12-30-spring-7-html": {
        "title": "[Spring] AOP 프로그래밍",
        "subtitle":"첫걸음 - 7",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. Proxy, AOP, Advice1-1. About proxy프록시는 기존 코드를 수정하지 않고 코드 중복을 피할 수 있는 방법으로써 다음과 같은 특징을 지님  핵심 기능의 실행은 다른 객체에 위임하고 부가적인 기능을 제공하는 객체 = 프록시(proxy)  실제 핵심 기능을 실행하는 객체 = 대상 객체  프록시는 핵심 기능을 구현하지 않음  대신 여러 객체에 공통으로 적용할 수 있는 기능을 구현1-2. About AOPAOP는 Aspect Oriented Programming의 약자로, 여러 객체에 공통으로 적용할 수 있는 기능을 분리해 재사용성을 높여주는 기법으로써 다음과 같은 특징을 지님  공통 기능 구현과 핵심 기능 구현의 분리  핵심 기능에 공통 기능을 삽입하며 다음과 같은 방법이 존재          컴파일 시점에 코드에 공통 기능을 삽입      클래스 로딩 시점에 바이트 코드에 공통 기능을 삽입      런타임에 프록시 객체를 생성해서 공통 기능을 삽입                  이 중, 스프링이 제공하는 AOP 방식은 프록시를 이용한 세 번째 방식                      스프링 AOP는 프록시 객체를 자동으로 생성해줌  AOP의 공통 기능을 Aspect라 칭하며, 아래와 같은 주요 용어가 존재          Advice: 언제 공통 관심 기능을 핵심 로직에 적용할 지를 정의      Joinpoint: Advice를 적용 가능한 지점을 의미(매서드 호출, 필드 값 변경 등, 스프링은 프록시를 이용해 AOP를 구현하기 때문에 매서드 호출에 대한 Joinpoint만 지원)      Pointcut: Joinpoint의 부분 집합, 실제 Advice가 적용되는 Joinpoint를 나타냄(스프링에서는 정규 표현식 및 AspectJ의 문법을 통해 Pointcut 정의)      Weaving: Advice를 핵심 로직 코드에 적용하는 것      Aspect: 여러 객체에 공통으로 적용되는 기능      1-3. About Advice  Before Advice: 대상 객체의 매서드 호출 전에 공통 기능을 실행  After Returning Advice: 대상 객체의 매서드가 익셉션 없이 실행된 이후에 공통 기능을 실행  After Throwing Advice: 대상 객체의 매서드를 실행하는 도중 익셉션이 발생한 경우에 공통 기능을 실행  After Advice: 익셉션 발생 여부에 상관없이 대상 객체의 매서드 실핼 후 공통 기능을 실행      Around Advice: 대상 객체의 매서드 실행 전, 후 또는 익셉션 발생 시점에 공통 기능을 실행          이 중 널리 사용되는 것은 Around Advice이며,  그 이유는 대상 객체의 매서드를 실행하기 전/후, 익셉션 발생등 다양한 시점에 원하는 기능을 삽입할 수 있기 때문      2. 스프링 AOP 구현스프링 AOP를 통해 공통 기능을 구현 및 적용하는 순서  Aspect로 사용할 클래스에 @Aspect 어노테이션을 붙임  @Pointcut 어노테이션으로 공통 기능을 적용할 Pointcut을 정의  공통 기능을 구현한 매서드에 @Around 어노테이션을 적용          후술할 예제는 크게              핵심기능: Calculator(인터페이스) &lt;- RecCalculator(상속)        공통기능: ExeTimeAspect(시간 측정) / CachceAspect(캐싱 기능)로 구현                      // Caculator.java public interface Calculator {\tpublic long factorial(long num);}                        // RecCalculator.javapublic class RecCalculator implements Calculator {\t@Override\tpublic long factorial(long num) {      if (num == 0)          return 1;      else          return num * factorial(num - 1);\t}}                                                      2-1. @Aspect, @Pointcut, @Around를 통한 AOP 구현    //ExeTimeAspect    // 공통 기능을 제공하는 클래스 설정    @Aspect    public class ExeTimeAspect {            // 공통 기능을 적용할 Pointcut 설정        @Pointcut(\"execution(public * chap07..*(..))\")        private void publicTarget() {        }            // 공통 기능을 구현할 매서드 설정        @Around(\"publicTarget()\")        public Object measure(ProceedingJoinPoint joinPoint) throws Throwable {            long start = System.nanoTime();            try {                            // proceed() 매서드를 사용해서 실제 대상 객체의 매서드를 호출                Object result = joinPoint.proceed();                return result;            } finally {                System.out.printf(\"%s.%s(%s) 실행 시간 : %d ns\\n\",                ...            }        }    }  @Aspect 어노테이션을 적용한 클래스는 Advice와 Pointcut을 함께 제공  @Pointcut 어노테이션은 cahp07 패키지나 그 하위 패키지에 속한 Bean 객체의 public 매서드를 설정          @Pointcut이 붙은 매서드는 다음의 조건을 일반적(반드시?)으로 만족해야 함              void 리턴 타입        비어있는 매서드        어떤 throws 문도 포함하지 않음              @Around 어노테이션은 publicTarget() 매서드에 정의한 Pointuct에 공통 기능을 적용  joinPoint.proceed() 매서드를 실행시, 대상 객체의 매서드가 실행되므로 이 코드 전후로 공통 기능을 위한 코드를 위치시킴          결과적으로 위 코드를 실행하게 되면,        Calculator 타입이 spring 패키지에 속하므로,         calculator Bean에 ExeTimeAspect 클래스에 정의한 공통 기능 measure()를 적용          // AppCtx.java  @Configuration  @EnableAspectJAutoProxy  public class AppCtx {          // exeTimeAspect 매서드가 공통 기능으로 사용될 프록시를 위한 Bean 객체를 생성하는 매서드          // 앞선 코드 ExeTimeAspect 클래스의 @Pointcut과 @Around 설정을 사용      @Bean      public ExeTimeAspect exeTimeAspect() {          return new ExeTimeAspect();      }      @Bean      public Calculator calculator() {          return new RecCalculator();      }  }        @Aspect 어노테이션을 붙인 클래스를 공통 기능으로 적용하려면,@EnableAspectJAutoProxy 어노테이션을 설정 클래스에 붙여야 함      @Aspect 어노테이션이 붙은 Bean 객체를 찾아 Bean 객체의 @Pointcut 설정과 @Around 설정을 사용          위의 코드를 수행하면 결과적으로 아래와 같은 흐름으로 진행              Main -&gt; Proxy -&gt; ExeTimeAspect(공통기능) -&gt; ProceedingJoinPoint -&gt; RecCalculator(핵심기능)                  @Before 어노테이션의 사용 예는 다음과 같다.              @Aspectpublic class ExeTimeAspect {\t@Pointcut(\"execution(public * chap07..*(..))\")\tprivate void publicTarget() {\t}\t\t@Before(\"publicTarget()\")\tpublic void beforeMethod() {\t\tSystem.out.println(\"실행전 시작!\");\t}       @Around(\"publicTarget()\")       public Object measure(ProceedingJoinPoint joinPoint) throws Throwable {\t       ...                            실행결과는 다음과 같다.              실행전 시작!———————————————————————// 여기까지 매서드 실행전 공통기능 수행 (@Before)RecCalculator.factorial([7]) 실행 시간 : 126851 nsCacheAspect: Cache에 추가[7]CacheAspect: Cache에서 구함[7]———————————————————————// 여기까지 원하는 위치에서 공통기능 수행 (@Around)            2-2. ProceedingJoinPoint의 매서드      Around Advice에서 사용할 공통 기능 매서드는 대부분 파라미터로 전달받은 ProceedingJoinPoint의 proceed() 매서드만 호출하면 됨(앞선 코드 ExeTimeAspect.java의 joinPoint.proceed() 부분)        이때 세부적인 정보가 필요하다면 아래와 같은 매서드를 통해 정보를 획득 가능          Signature getSignature(): 호출되는 매서드의 대한 정보를 구함      Object getTaget(): 대상 객체를 구함      Object[] getArgs(): 파라미터 목록을 구함                  예시: joinPoint.getTarget() 등                    3. 프록시 생성 방식    // 수정 전 MainAspect.java    Calculator cal = ctx.getBean(\"calculator\", Calculator.class);    // 수정 후 MainAspect.java    RecCalculator cal = ctx.getBean(\"calculator\", RecCalculator.class);  만약, 위와 같이 타입을 변경하여 Bean 객체를 가져온다고 하면,아래와 같이 설정 파일에 RecCalculator 객체를 반환하므로 문제가 없어 보임      // AppCtx.java  @Bean  public Calculator calculator() {      return new RecCalculator();  }              하지만 getBean() 매서드에 사용한 타입이 RecCalculator 인데 반해 실제 타입은 $Proxy17 이라는 메세지와 함께, 다음과 같은 이유로 에러 발생        현재 구조는 Calculator(인터페이스)를 RecCalculator와 $Proxy17가 상속받는 관계  스프링은 AOP를 위한 프록시 객체를 생성할 때 실제 생성할 Bean 객체가 인터페이스를 상속하면 인터페이스를 이용해 프록시를 구현      따라서 아래 코드처럼 Bean의 실제 타입이 RecCalculator 라고 해도,“calculator”에 해당하는 Bean 객체 타입은 Caculator 를 상속받은 프록시 타입이됨      // AppCtx.java  // AOP 적용시 RecCalculator가 상속받은 Calculator 인터페이스를 이용해 프록시 생성  @Bean  public Calculator calculator(){      return new RecCalculator();  }  // MainAspect.java  // calculator Bean의 실제 타입은 Calculator를 상속한 프록시 타입이므로  // RecCalculator로 타입변환을 할 수 없기 때문에 익셉션 발생  RecCalculator cal = ctx.getBean(\"calculator\", RecCalculator.class);          3-1. execution 명시자 표현 방식execution 명시자는 Advice를 적용할 매서드를 지정할 때 아래와 같이 사용    @Pointcut(\"execution(public * cahp07..*(..))\")    private void public Target(){    }  Aspect를 적용할 위치를 지정하기 위한 Pointcut 설정      스프링 AOP는 public 매서드에만 적용할 수 있기 때문에, 사실상 public만 가능          execution(수식어패턴? 리턴타입패턴 클래스이름패턴?매서드이름패턴(파라미터패턴)) 방식으로 사용              수식어패턴은 생략 가능하며 public, protected등이 올 수 있음        리턴타입패턴은 리턴 타입을 명시        클래스이름패턴, 매서드이름패턴은 클래스 이름 및 매서드 이름을 패턴으로 명시        파라미터패턴은 매칭될 파라미터에서 대해 명시        각 패턴에서 '..'은 0개 이상이라는 의미            3-2. Advice 적용 순서기존의 코드에는 ExeTimeAspect 클래스만 공통기능으로 구현했지만,이에 추가로 CacheAspect 클래스를 공통기능으로 구현해, 한 Pointcut에 여러 Advice를 적용    //CacheAspect.java    @Aspect    public class CacheAspect {        private Map&lt;Long, Object&gt; cache = new HashMap&lt;&gt;();        @Pointcut(\"execution(public * chap07..*(long))\")        public void cacheTarget() {        }                @Around(\"cacheTarget()\")        public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {            Long num = (Long) joinPoint.getArgs()[0];            if (cache.containsKey(num)) {                System.out.printf(\"CacheAspect: Cache에서 구함[%d]\\n\", num);                return cache.get(num);            }            Object result = joinPoint.proceed();            cache.put(num, result);            System.out.printf(\"CacheAspect: Cache에 추가[%d]\\n\", num);            return result;        }    }  위 클래스는 캐싱의 기능을 제공하며, 키 값이 hashmap에 존재하면 그 값을 리턴하고,없다면 프록시 대상 객체를 실행하여 그 결과를 캐시에 추가해 준 후, 그 값을 리턴  ExeTimeAspect 클래스와 동일하게, 공통기능으로 사용할 클래스에 @Aspect 공통기능을 적용할 부분에 @Pointcut 공통기능을 구현한 매서드에 @Around 어노테이션을 차례로 적용하여 구현  @Around 값으로 cacheTarget() 매서드를 지정  @Pointcut 설정은 첫 번째 인자가 long인 매서드를 대상으로 함  따라서 execute() 매서드는 앞서 작성한 Calculator의 fatoring(long) 매서드에 적용      새로운 Aspect를 구현했으므로 아래와 같이 두개의 Aspect를 추가하는 작업이 필요      // AppCtxWithCahce.java  @Configuration  @EnableAspectJAutoProxy  public class AppCtxWithCache {      @Bean      public CacheAspect cacheAspect() {          return new CacheAspect();      }      @Bean      public ExeTimeAspect exeTimeAspect() {          return new ExeTimeAspect();      }      @Bean      public Calculator calculator() {          return new RecCalculator();      }  }            위의 설정 클래스를 적용해 실행하는 코드는 아래와 같다.      // MainAspectWithCache.java  public class MainAspectWithCache {              public static void main(String[] args) {          AnnotationConfigApplicationContext ctx =                   new AnnotationConfigApplicationContext(AppCtxWithCache.class);          Calculator cal = ctx.getBean(\"calculator\", Calculator.class);          cal.factorial(7);          cal.factorial(7);          cal.factorial(5);          cal.factorial(5);          ctx.close();      }  }        위의 코드를 실행하면 아래와 같은 결과를 출력 함          RecCalculator.factorial([7]) 실행 시간 : 16584 nsCacheAspect: Cache에 추가[7] —————————————————-  // 여기까지 처음 cal.factorial(7) 결과CacheAspect: Cache에서 구함[7] // 두 번째 cal.factorial(7) 결과…        처음 factorial(7)을 실행할 때와 두 번째 실행할 때의 결과가 다른 것을 확인할 수 있으며,첫 번째는 ExeTimeAspect와 CacheAspect가 모두 적용되었고두 번째는 CacheAspect만 적용됨          이렇게 실행결과가 다른 이유는 Advice를 다음 순서로 적용했기 때문CacheAspect 프록시 -&gt; ExeTimeAspect 프록시 -&gt; 실제 대상 객체        앞선 코드의 caculator Bean 객체는 실제로 CacheAspect 프록시 객체CacheAspect 프록시 대상 객체는 ExeTimeAspect의 프록시 객체ExeTimAsepct 프록시 대상 객체는 실제 대상 객체      실제 코드상의 흐름은 다음과 같다.      // CacheAsepct.java  ...   if (cache.containsKey(num)) {      System.out.printf(\"CacheAspect: Cache에서 구함[%d]\\n\", num);      return cache.get(num);  }  /* 이 부분에서 해당 객체의 대상 객체를 호출  * 현재 CacheAspect -&gt; ExeTimeAspect -&gt; RecCalculator의 순서이므로  * jointPoint.proceed()를 호출하게 되면  * 대상 객체인 ExeTimeAspect 프록시를 호출  */  Object result = joinPoint.proceed(); // 실행순서 1)  cache.put(num, result);  System.out.printf(\"CacheAspect: Cache에 추가[%d]\\n\", num); // 실행순서 5)  return result;          // ExeTimeAspect.java  ...  try {          // 위와 마찬가지로 joinPoint.proceed()에서 해당 객체의 대상 객체를 호출          // 여기서는 실제 대상 객체 (RecCalculator)를 호출      Object result = joinPoint.proceed(); // 실행순서 2)      return result;  } finally {          ...      System.out.printf(\"%s.%s(%s) 실행 시간 : %d ns\\n\", // 실행순서 4)      ...  }  ...          // RecCalculator.java  ...  @Override  public long factorial(long num){ // 실행순서 3)  ...          3-3. @Order 어노테이션과 Aspect 적용 순서앞선 예제 코드의 흐름은 아래와 같다.  CacheAspect 프록시 -&gt; ExeTimeAspect 프록시 -&gt; RecCalculator (실제 대상 객체)          하지만 우리는 순서를 지정해준 적이 없는데, 어떤 정책에 의해 위와 같은 순서로 진행 되는가?            그 이유는 설정 파일에 아래와 같은 순서로 작성했기 때문      // AppCtxWithCahce.java  @Configuration  @EnableAspectJAutoProxy  public class AppCtxWithCache {          // 1번째로 적용될 Aspect      @Bean      public CacheAspect cacheAspect() {          return new CacheAspect();      }          // 2번째로 적용될 Aspect      @Bean      public ExeTimeAspect exeTimeAspect() {          return new ExeTimeAspect();      }      @Bean      public Calculator calculator() {          return new RecCalculator();      }  }              실제 두 Apsect의 위치를 맞바꾸면, 실행결과가 달라짐        어떤 Aspect가 적용되는지 순서가 중요하다면, 직접 순서를 지정해야 함      @Order 어노테이션을 해당 클래스에 적용함으로써 그 순서를 아래와 같이 지정 가능      import org.springframework.core.annotation.Order;  // ExeTimeAspect.java  @Aspect  @Order(1)  public class ExeTimeAspect{  ...  }  // CacheAspect.java  @Aspect  @Order(2)  public class CacheAspect{  ...  }              위의 설정대로 수행 시, 아래와 같은 순서로 실행ExeTimeAspect 프록시 -&gt; CacheAspect 프록시 -&gt; RecCalculator 실제 대상 객체      3-4. @Around의 Pointcut 설정과 @Pointcut의 재사용      @Pointcut 어노테이션이 아닌 @Around 어노테이션에 execution 명시자를 지접 아래와 같이 지정 가능      // CacheAspect.java  @Aspect  public class CacheAspect {          ...      @Around(\"execution(public * chap07..*(long))\")      public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {          ...      }  }            만약 같은 Pointcut을 여러 Advice가 함께 사용한다면, 아래와 같이 공통 Pointcut을 재사용 가능      // ExeTimeAspect.java  @Aspect  public class ExeTimeAspect {          // 다른 Advice가 참조하기 위해 prviate -&gt; public으로 변경      @Pointcut(\"execution(public * chap07..*(..))\")      public void publicTarget() {      }      ...  }          @Aspect  public class CacheAspect {      ...          // 앞선 코드의 Pointcut 재사용      @Around(\"aspect.ExeTimeAspect.publicTarget()\")      public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {          ...      }  }              만약 여러 Aspect에서 공통으로 사용하는 Pointcut이 있다면,별도 클래스에 Pointcut을 정의하고,각 Aspect 클래스에서 해당 Pointcut을 사용하도록 구성      이렇게 구성된 별도의 클래스는 따로 Bean에 등록할 필요 없고,@Around 어노테이션에서 해당 클래스에 접근 가능하면 사용 가능      ",
        "url": "/devlog/2019/12/30/spring-7.html"
      }
      ,
    
      "devlog-2019-12-30-spring-6-html": {
        "title": "[Spring] Bean의 라이프사이클과 범위",
        "subtitle":"첫걸음 - 6",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 스프링 Bean 객체의 라이프 사이클1-1. 컨테이너의 초기화와 종료  스프링 컨테이너는 초기화와 종료라는 라이프 사이클을 가짐  컨텍스트 객체가 생성되는 시점에 컨테이너를 초기화함  스프링 컨테이너는 설정 클래스에서 정보를 읽어와 알맞은 Bean 객체를 생성하고,각 Bean을 연결(의존 주입)하는 작업 수행  초기화가 끝난 후 컨테이너를 사용 가능(getBean()등의 작업으로 Bean 객체를 구하는 행위 등)  컨테이너 사용이 끝나면 컨테이너를 close() 매서드를 사용해 종료, Bean 객체의 소멸                  기본적으로 Spring의 ApplicationContext 구현은 초기화 프로세스에서 모든 싱글톤 빈을 생성 및 설정        따라서 Bean에 문제가 있을 경우 초기화 단계에서 알 수 있다는 장점이 존재        만약 어떤 이유로, 특정 Bean이 늦은 초기화를 원한다면 다음과 같이 두 가지 방법이 존재                      xml에서 Bean을 등록시 lazy-init 속성을 이용하여 초기화            Java Config에서 Bean을 등록시 @Lazy 어노테이션을 이용                                              설정파일 전체를 Lazy-init                    @Lazy@Configuration@ComponentScan(basePackages = \"com.baeldung.lazy\")public class AppConfig {     @Bean    public Region getRegion(){        return new Region();    }    ...                            특정 Bean을 Lazy-init        @Bean@Lazy(true)public Region getRegion(){    return new Region();}                            Lazy init을 하더라도 해당 Bean을 다른 Bean이 참조한다면 그 시점에 초기화 됨      1-2. Bean 객체의 라이프 사이클Bean 객체는 아래와 같은 라이프 사이클을 가지며 스프링 컨테이너에 의해 관리됨  객체생성 -&gt; 의존설정 -&gt; 초기화 -&gt; 소멸2. Bean 객체의 초기화와 소멸2-1. 스프링 인터페이스를 통한 구현스프링 컨테이너는 Bean 객체를 초기화하고 소멸하기 위해 빈 객체의 지정한 매서드를 호출  매서드 정의 인터페이스:          org.springframework.beans.factory.InitializingBean      org.springframework.beans.factory.DisposableBean        인터페이스:     // 초기화 인터페이스 public interface InitializingBean {     void afterPropertiesSet() throws Exception; } // 소멸 인터페이스 public interface DisposableBean {     void destroy() throws Exception; }              Bean 객체가 각 인터페이스를 구현하면 스프링 컨테이너는 해당하는 매서드를 실행      우리는 위의 코드에서 afterPropertiesSet()와 destroy() 매서드를 구현하면 됨        예시     // Client.java // 초기화와 소멸에 해당하는 인터페이스를 상속 후, 각 매서드 재정의 public class Client implements InitializingBean, DisposableBean {         ...         // 초기화 매서드 오버라이딩     @Override     public void afterPropertiesSet() throws Exception {         System.out.println(\"Client.afterPropertiesSet() 실행\");     }         ...         // 소멸 매서드 오버라이딩     @Override     public void destroy() throws Exception {         System.out.println(\"Client.destroy() 실행\");     } }           * 해당 코드를 수행하면 콘솔 화면에 매서드에서 정의한  `\"Client.afterPropertiesSet() 실행\"` 및 `\"Client.destroy() 실행\"`이 출력 됨        2-2. 커스텀 매서드를 통한 구현위의 두 인터페이스를 구현할 수 없거나, 두 인터페이스를 사용하지 않고 싶을 때 스프링 설정에서 직접 매서드를 지정 가능  Bean 태그에서 initMethod 속성과 destoryMethod 속성을 사용해 사용할 매서드 이름을 지정// AppCtxWithprototype.java@Configurationpublic class AppCtxWithPrototype {\t...\t// 매서드의 이름을 지정해 초기화와 소멸 로직을 처리\t@Bean(initMethod = \"connect\", destroyMethod = \"close\")\tpublic Client2 client2() {\t\tClient2 client = new Client2();\t\tclient.setHost(\"host\");\t\treturn client;\t}}2-3. Bean 설정 코드에서 직접 초기화/소멸을 수행// AppCtxWithprototype.java@Configurationpublic class AppCtxWithPrototype {\t...\t@Bean(destroyMethod = \"close\")\tpublic Client2 client2() {\t\tClient2 client = new Client2();\t\tclient.setHost(\"host\");                // 초기화는 직접 수행, 소멸은 커스텀 매서드를 통해 수행                client.connect();\t\treturn client;\t}}  위와 같이 직접 매서드를 호출하여 초기화도 가능  이때 해당 클래스 내부적으로 인터페이스를 상속받아 초기화를 실행해 두 번 초기화 과정이 수행되지 않도록 주의  initMethod 속성과 destroyMethod 속성에 지정한 매서드는 파라미터가 없어야 함만약 파라미터가 존재할 경우, 스프링 컨테이너는 Exception을 발생3. Bean 객체의 생성과 관리 범위  Bean 객체는 기본적으로 싱글톤(singleton)의 범위를 가짐  Bean 객체의 범위를 프로토타입(prototype)으로 지정시 Bean 객체를 매번 새롭게 생성  특정 Bean을 프로토타입으로 지정하려면, 다음과 같이 @Scope 어노테이션을 @Bean 어노테이션과 함께 사용                  프로토타입은 새로운 요청이 들어오면, 기존의 Bean을 바탕으로 복사해 새로운 객체를 생성        이렇게 만들어진 새로운 Bean은 스케줄링, 멀티스레딩등에 사용이 됨          // AppCtxWithprototype.java@Configurationpublic class AppCtxWithPrototype {        // 해당 Bean 객체를 프로토 타입으로 지정    @Bean    @Scope(\"prototype\")    public Client client() {        Client client = new Client();        client.setHost(\"host\");        return client;    }    // 해당 Bean을 명시저으로 싱글톤으로 지정    @Bean(initMethod = \"connect\", destroyMethod = \"close\")    @Scope(\"singleton\")    public Client2 client2() {        Client2 client = new Client2();        client.setHost(\"host\");        return client;    }}                                각 경우 해당 Bean 객체의 동일성은 아래와 같음      // 프로토 타입의 경우  Client client1 = ctx.getBean(\"client\", Client.class);  Client client2 = ctx.getBean(\"client\", Client.class);  // client1 != client -&gt; true  // 싱글톤의 경우  Client client1 = ctx.getBean(\"client\", Client2.class);  Client client2 = ctx.getBean(\"client\", Client2.class);  // client1 != client -&gt; false        프로토 타입을 갖는 Bean은 완전한 라이프 사이클을 따르지 않음  생성 및 초기화는 컨테이너가 해주지만, 소멸 처리는 코드에서 직접 해줘야 함",
        "url": "/devlog/2019/12/30/spring-6.html"
      }
      ,
    
      "devlog-2019-12-30-spring-5-html": {
        "title": "[Spring] 컴포넌트 스캔",
        "subtitle":"첫걸음 - 5",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. About Component 스캔1-1. 컴포넌트 스캔이란?  자동 주입과 함께 사용되는 기능  스프링이 직접 클래스를 검색해서 빈으로 등록해주는 기능  설정 코드가 크게 줄어듦1-2. @Component 어노테이션으로 스캔 대상 지정      기본 속성 값으로 해당 클래스를 스캔 대상으로 지정     //MemberDao.java import org.springframework.stereotype.Component; @Component public class MemberDao {     ... }            속성 값을 주어 스캔 대상으로 지정    //MemberInfoPrinter.java// 빈의 이름을 지정@Component(\"infoPrinter\")public class MemberInfoPrinter { ...}      컴포넌트 스캔시 Bean의 이름이 지정되는 방법은 위의 두 가지 방법에 따라 아래와 같이 결정됨  @Component 어노테이션에 값을 주지 않을 경우, Bean으로 등록할 때 사용될 이름은 클래스 이름의 첫 글자를 소문자로 바꾼 이름    즉, 클래스 이름이  MemberDao 라면 Bean 이름으로는 memberDao를 사용  @Component 어노테이션에 값을 주었다면, 그 값을 Bean의 이름으로 사용1-3. @ComponentScan 어노테이션으로 스캔 설정// AppCtx.javaimport org.springframework.context.annotation.ComponentScan;@Configuration// ComponentScan 어노테이션@ComponentScan(basePackages = {\"spring\"})public class AppCtx {       /*        * 다음과 같은 코드가 줄어들게 됨        * public MemberDao memberDao(){\t*     ...        * }        * public MemberInfoPrinter memberInfoPrinter(){\t*     ...        * }        */\t@Bean\t@Qualifier(\"printer\")\tpublic MemberPrinter memberPrinter1() {\t\treturn new MemberPrinter();\t}\t\t@Bean\t@Qualifier(\"summaryPrinter\")\tpublic MemberSummaryPrinter memberPrinter2() {\t\treturn new MemberSummaryPrinter();\t}\t\t@Bean\tpublic VersionPrinter versionPrinter() {\t\tVersionPrinter versionPrinter = new VersionPrinter();\t\tversionPrinter.setMajorVersion(5);\t\tversionPrinter.setMinorVersion(0);\t\treturn versionPrinter;\t}}  @ComponentScan 어노테이션으로 인해, 4장의 AppCtx 코드와 비교하여 설정 코드가 줄어듦  @ComponentScan의 basePackage 속성값은 {“spring”} 인데,이는 spring 한 개만 존재하고 그 패키지와 하위 패키지에 속한 클래스를 스캔 대상으로 설정1-4. 스캔 대상에서 제외하거나 포함시키기excludeFilters 속성을 사용하면 스캔할 때 특정 대상을 자동 등록 대상에서 제외 가능하고, 아래와 같이 3가지 사용법이 존재  제외 대상을 직접 지정  특정 어노티에션을 붙인 타입을 컴포넌트 대상에서 제외  특정 타입이나 그 하위 타입을 컴포넌트 스캔 대상에서 제외각 방법별 사용 예시는 아래와 같음  정규 표현식 / AspectJ 패턴을 사용한 대상 지정     // AppCtxWithExclude.java import org.springframework.context.annotation.FilterType; import org.springframework.context.annotation.ComponentScan.Filter; // 동일 코드에 대하여 정규표현식 / AspectJ 패턴 사용 방식 // 정규표현식을 이용한 1번째 방법 @Configuration @ComponentScan(basePackages = {\"spring\"},      excludeFilters =              (@Filter(type = FilterType.REGEX, pattern = \"spring\\\\..*Dao\" )\t\t ) // AspectJ를 이용한 2번째 방법 @Configuration @ComponentScan(basePackages = {\"spring\"},      excludeFilters =              (@Filter(type = FilterType.ASPECTJ, pattern = \"spring.*Dao\" )\t\t ) public class AppCtxWithExclude {     ... }              정규 표현식은 “spring”으로 시작하고 Dao로 끝나는 타입을 지정      AspectJ 패턴은 spring 패키지의 Dao로 끝나는 타입을 지정         특정 어노테이션을 제외     // NoProduct.java @Retention(RUNTIME) @Target(TYPE) public @interface NoProduct { } // ManualBean.java @Retention(RUNTIME) @Target(TYPE) public @interface ManualBean { }        위와 같은 특정 어노테이션을 붙인 타입을 텀포넌트 대상에서 제외하는 방법은 아래와 같이 존재     // AppCtxWithExclude.java @Configuration @ComponentScan(basePackages = {\"spring\"},      excludeFilters = {              @Filter(type = FilterType.ANNOTATION, classes = ManualBean.class )\t\t\t })              type 속성값으로 FilterType.ANNOTATION을 사용하면 class 속성에 필터로 사용할 어노테이션 타입을 값으로 줌      이 코드는 @ManualBean 어노테이션을 제외 대상에 추가했으므로, 결국 다음 클래스를 컴포넌트 스캔 대상에서 제외         // MemberDao.java @ManualBean @Component public class Member Dao{     ... }              @Retention, @Target 어노테이션?              어노테이션을 Customizing 하는 방법        @Retention: 어느 시점까지 어노테이션을 남길 것인가? (파라미터는 아래와 같음)                      SOURCE: 컴파일시 사라짐            CLASS: 컴파일러가 클래스를 참조할 때까지 유효            RUNTIME: 컴파일 이후에도 VM을 통해 참조 가능                          @Target: 어디에 우리가 만든 어노테이션을 적용할 것인가? (파라미터는 아래와 같음)                      TYPE: 클래스, 인터페이스            FIELD: 필드            METHOD: 매서드            PARAMETER: 파라미터            CONSTRUCTOR: 생성자            LOCAL_VARIABLE: 지역변수            ANNOTATION_TYPE: 어노테이션 타입            PACKAGE: 패키지                                특정 타입이나 그 하위 타입을 제외    // AppCtxWithExclude.java@Configuration@ComponentScan(basePackages = {\"spring\"},  excludeFilters = {          @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = MemberDao.class )\t\t\t})              classes 속성에는 제외할 타입의 목록을 지정        설정할 필터가 두 개 이상이면 @ComponentScan의 exludeFilters 속성에 배열을 사용해 @Filter 목록을 전달     // AppCtxWithExclude.java @Configuration @ComponentScan(basePackages = {\"spring\"},      excludeFilters = {              @Filter(type = FilterType.ANNOTATION, classes = ManualBean.class ),             (@Filter(type = FilterType.REGEX, pattern = \"spring\\\\..*Dao\" ) })          2. 컴포넌트 스캔에 따른 충돌 처리컴포넌트 스캔 기능을 사용해서 Bean을 등록할 경우, 아래와 같은 두 가지 충돌이 발생 가능  Bean 이름의 충돌  수동 등록에 따른 충돌2-1. Bean 이름 충돌  서로 다른 패키지에 같은 클래스의 이름이 존재하고, 두 클래스 모두 @Component 어노테이션이 붙게 된다면, Exception이 발생하게 됨  이럴 경우, 둘 중 하나에 명시적으로 Bean 이름을 지정해서 이름 충돌을 피해야 함2-2. 수동 등록에 따른 충돌  같은 클래스를 같은 이름으로 설정할 때:          @Component 어노테이션을 통해 이미 지정한 Bean의 클래스 이름이 존재하지만,  클래스 설정에 직접 해당 클래스를 동일한 이름으로 정해 등록하는 경우 발생      즉, 스캔할 때 사용하는 Bean 이름과 수동 등록한 이름이 같을 경우, 수동 등록한 Bean이 우선시 됨        같은 클래스를 다른 이름으로 설정할 때:          만약, 스캔할 때 사용하는 Bean 이름과 동일한 클래스를 다른 이름으로 수동 등록하는 경우에는   다른 이름의 두 개의 Bean이 만들어지게 됨      이런 경우에는 @Qualifier 어노테이션을 통해 알맞은 Bean을 선택해야 함      ",
        "url": "/devlog/2019/12/30/spring-5.html"
      }
      ,
    
      "devlog-2019-12-30-spring-4-html": {
        "title": "[Spring] 의존 자동 주입",
        "subtitle":"첫걸음 - 4",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 자동 의존 주입1-1. 자동 의존 주입?  의존 주입에 필요한 객체들을 찾아 스프링이 자동으로 필드에 할당해 주는 기능  스프링에서는 @Autowired와 @Resource 어노테이션 두 가지 방법이 존재      MVC 관점에서Component는 @Resource를Service는 @Autowired를 주로 사용하는 추세라고 함  1-2. 자동 의존 주입 예제: Bean 객체// ChangePasswordService.javapublic class ChangePasswordService {\t@Autowired\tprivate MemberDao memberDao;\t...\tpublic void setMemberDao(MemberDao memberDao) {\t\tthis.memberDao = memberDao;\t}}//AppCtx.java@Configurationpublic class AppCtx {\t@Bean\tpublic MemberDao memberDao() {\t\treturn new MemberDao();\t}\t\t@Bean\tpublic MemberRegisterService memberRegSvc() {\t\treturn new MemberRegisterService();\t}        // 아래 함수에서 의존을 주입하지 않아도 스프링이 @Autowired가 붙인 필드에        // 해당 타입의 Bean 객체를 찾아서 주입\t\t@Bean\tpublic ChangePasswordService changePwdSvc() {\t\treturn new ChangePasswordService();\t}        /* 기존 코드\t @Bean\t public ChangePasswordService changePwdSvc() {\t \tChangePasswordService pwdSvc = new ChangePasswordService();\t\tpwdSvc.setMemberDao(memberDao());\t\treturn pwdSvc;\t }        */        ...}  기존의 코드와는 다르게 memberDao()를 통해 생성된 Bean 객체를 setter 매서드에 넘겨주지 않음1-3. 자동 의존 주입 예제: method// MemberInfoPrinter.javapublic class MemberInfoPrinter {\tprivate MemberDao memDao;\tprivate MemberPrinter printer;        ...\t@Autowired\tpublic void setMemberDao(MemberDao memberDao) {\t\tthis.memDao = memberDao;\t}\t@Autowired\tpublic void setPrinter(MemberPrinter printer) {\t\tthis.printer = printer;\t}}//AppCtx.java@Configurationpublic class AppCtx {\t@Bean\tpublic MemberDao memberDao() {\t\treturn new MemberDao();\t}\t...        // 원래 호출하던 두 매서드 setPrinter(), setMemberDao()를 호출하지 않음\t@Bean\tpublic MemberInfoPrinter infoPrinter() {\t\tMemberInfoPrinter infoPrinter = new MemberInfoPrinter();\t\treturn infoPrinter;\t}        /* 기존코드        @Bean\tpublic MemberInfoPrinter infoPrinter() {\t\tMemberInfoPrinter infoPrinter = new MemberInfoPrinter();\t\tinfoPrinter.setMemberDao(memberDao());\t\tinfoPrinter.setPrinter(memberPrinter());\t\treturn infoPrinter;\t}        */\t...}  @Autowired 어노테이션을 필드나 매서드에 붙이게 되면, 스프링은 타입이 일치하는 Bean 객체를 찾아서 주입  만약 일치하는 Bean이나 매서드가 없는 경우, Exception이 발생하고 제대로 실행되지 않음      최근에는 위와 같은 방법이 권장  1-4. 자동 주입 가능 Bean이 두 개 이상이라면?// AppCtx.java@Configurationpublic class AppCtx {\t@Bean\tpublic MemberDao memberDao() {\t\treturn new MemberDao();\t}\t...        // memberPrinter1() 매서드의 Bean의 한정 값으로 \"printer\"를 지정\t@Bean\t@Qualifier(\"printer\")\tpublic MemberPrinter memberPrinter1() {\t\treturn new MemberPrinter();\t}\t\t@Bean\tpublic MemberPrinter memberPrinter2() {\t\treturn new MemberPrinter();\t}\t...}// MemberListPrinter.javapublic class MemberListPrinter {\tprivate MemberDao memberDao;\tprivate MemberPrinter printer;\t...\t@Autowired        // 앞서 스프링 설정 클래스에서 @Qualifier 어노테이션의 값으로 \"printer\"를 준        // MembeerPrinter 타입의 Bean(memberPrinter1)을 자동 주입 대상으로 사용\t@Qualifier(\"printer\")\tpublic void setMemberPrinter(MemberPrinter printer) {\t\tthis.printer = printer;\t}}  @Qualifier 어노테이션을 통해 자동 주입 Bean을 지정할 수 있음  Bean 설정에 @Qualifier 어노테이션이 없다면, Bean의 이름을 한정자로 지정2. @Autowired 어노테이션의 필수 여부자동 주입할 대상이 필수가 아닌 경우(NULL값 등) 아래와 같이 세가지 방법이 존재  @Autowired(required = false) 어노테이션 사용  자동 주입 대상 타입의 Optional 지정  @Nullable 어노테이션 사용  아래와 같이 dateTimeFormatter 필드값이 Null이어도 되는 경우 3가지 방법 예시    // MemberPrinter.javapublic class MemberPrinter {  private DateTimeFormatter dateTimeFormatter;  ...      // 차례대로 1~3번 방법의 동일 매서드 코드      // 1번 방법  @Autowired(required = false)  public void setDateFormatter(DateTimeFormatter dateTimeFormatter) {      this.dateTimeFormatter = dateTimeFormatter;  }      // 2번 방법  @Autowired  public void setDateFormatter(Optional&lt;DateTimeFormatter&gt; dateTimeFormatter) {      this.dateTimeFormatter = dateTimeFormatter;  }      // 3번 방법  @Autowired  public void setDateFormatter(@Nullable DateTimeFormatter dateTimeFormatter) {      this.dateTimeFormatter = dateTimeFormatter;  }        각 방법의 특징은 아래와 같음      1. 매칭되는 Bean이 없어도 Exception이 발생하지 않으며 자동 주입을 수행하지 않음      2. 일치하는 Bean이 존재하지 않으면 값이 없는 Optional을 인자로 전달(Exception 발생하지 않음), 일치하는 Bean이 존재하면 해당 Bean을 값으로 갖는 Optional을 인자로 전달      3. 스프링 컨테이너는 setter 매서드를 호출할 때 자동 주입할 Bean이 존재하면 해당 빈을 인자로 전달, 존재하지 않으면 인자로 NULL을 전달    1번 방법은 매칭되는 Bean이 없으면 매서드를 실행하지 않지만,2,3번 방법은 매칭되는 Bean이 없어도 해당 매서드를 실행함",
        "url": "/devlog/2019/12/30/spring-4.html"
      }
      ,
    
      "devlog-2019-12-30-spring-3-html": {
        "title": "[Spring] 스프링 DI",
        "subtitle":"첫걸음 - 3",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "1. 의존이란?  DI는 Dependency Injection의 약자로 우리말로는 의존주입이라 번역  의존이란 객체간의 의존을 의미  한 클래스가 다른 클래스의 매서드를 실행할 경우 이를 의존한다고 표현(변경에 의해 영향을 받는 관계)2. About DI  OOP의 DIP와는 비슷한 개념  디자인 패턴의 IoC(Inversion of Control) 제어 반전의 한 종류          용어가 정확하게 구분되어 있지는 않지만, 대략 IoC &gt; DIP &gt; DI 정도로 정리가능자세한 사항은 링크 참조: https://bit.ly/2Zt9cnf        객체지향 5대 원칙: SOLID                  단일 책임 원칙(Single responsibility principle) - SRP        개방 폐쇄 원칙(Open/closed principle) - OCP        리스코프 치환 원칙(Liskov substitution principle) - LSP        인터페이스 분리 원칙(Interface segregation principle) - ISP        의존관계 역전 원칙(Dependency inversion principle) - DIP            2-1. DI를 통한 의존 처리  DI는 의존하는 객체를 직접 생성하는 대신, 의존 객체를 전달받는 방식을 이용    // MemberRegisterService.javapublic class MemberRegisterService {  private MemberDao memberDao;      // MemberDao 객체를 전달 받아 DI를 구현  public MemberRegisterService(MemberDao memberDao) {      this.memberDao = memberDao;  }      ...}          2-2. Why DI?  DI를 사용하는 가장 큰 이유는 변경의 유연함  객체를 전달받아 사용하게 되면, 코드의 수정을 최소한으로 줄이고 유연함을 가져갈 수 있음(주입 대상이 되는 객체를 생성하는 코드만 변경하면 됨)2-3. DI 방식 1: 생성자 방식// MemberRegisterService.javapublic class MemberRegisterService {\tprivate MemberDao memberDao;        // 생성자를 통해 의존 객체를 주입 받음\tpublic MemberRegisterService(MemberDao memberDao) {\t\tthis.memberDao = memberDao;\t}\tpublic Long regist(RegisterRequest req) {                // 주입 받은 의존 객체의 매서드를 사용\t\tMember member = memberDao.selectByEmail(req.getEmail());                ...\t\tmemberDao.insert(newMember);\t\treturn newMember.getId();\t}}  생성자를 통해 의존 객체를 주입받아 필드에 할당  전달할 의존 객체가 두 개 이상이어도 동일한 방식으로 주입2-4. DI 방식 2: setter 매서드 방식// MemberInfoPrinter.javapublic class MemberInfoPrinter {\tprivate MemberDao memDao;\tprivate MemberPrinter printer;        ...        // setter를 통해 의존 객체를 주입 받는다.\tpublic void setMemberDao(MemberDao memberDao) {\t\tthis.memDao = memberDao;\t}\tpublic void setPrinter(MemberPrinter printer) {\t\tthis.printer = printer;\t}}  setter 매서드를 이용하여 객체를 주입2-5. 생성자 VS setter?  각 방식의 장점은 곧 다른 방식의 단점  생성자 방식 장점: Bean 객체를 생성하는 시점에 모든 의존 객체가 주입, 그러나 생성자의 파라미터가 많을 경우 일일히 확인해 주어야 함  setter 매서드 방식: sstter 매서드 이름을 통해 어떤 의존 객체가 주입 되는지 알 수 있음, 그러나 정확한 전달이 안될 시  NullPointerException 발생가능3. 싱글톤의 이해와 어노테이션3-1. @Configuration 설정 클래스의 @Bean 설정과 싱글톤// AppCtx.java@Configurationpublic class AppCtx {\t@Bean\tpublic MemberDao memberDao() {\t\treturn new MemberDao();\t}\t\t@Bean\tpublic MemberRegisterService memberRegSvc() {                // memberDao() 매서드 호출\t\treturn new MemberRegisterService(memberDao());\t}\t\t@Bean\tpublic ChangePasswordService changePwdSvc() {\t\tChangePasswordService pwdSvc = new ChangePasswordService();                // memberDao() 매서드 호출\t\tpwdSvc.setMemberDao(memberDao());\t\treturn pwdSvc;\t}        ...}  memberRegSvc() 매서드와 changePwdSvc() 매서드는 둘 다 memberDao() 매서드를 실행그리고 memberDao() 매서드는 매번 새로운 MemberDao 객체를 생성해서 리턴두 매서드는 과연 같은 MemberDao 객체를 사용하는가?  스프링 컨테이너는 @Bean이 붙은 매서드에 대해 한 개의 객체만 생성  이는 다른 설정에서 memberDao()를 몇 번을 호출하더라도 항상 같은 객체를 리턴  이것이 가능한 이유는 스프링이 설정 클래스를 그대로 사용하지 않고,설정한 클래스를 상속한 새로운 설정 클래스를 만들어서 사용하기 때문  따라서 런타임에 매번 생성하지 않고, 한 번 생성한 객체를 보관했다가 이후에는 동일한 객체를 리턴// 이해를 돕기 위한 가상의 코드. 실제 코드는 이보다 훨씬 복잡하다.public class AppCtxExt extends AppCtx {        private Map&lt;String, Object&gt; beans = ...;\t@Override\tpublic MemberDao memberDao() {\t\tif(!beans.containersKey(\"memberDao\"))                    beans.put(\"memberDao\", super.memberDao());                return (MemberDao) beans.get(\"memberDao\");\t}        ...}  매번 새로운 객체를 리턴하는 것이 아니라, 한 번 생성한 객체를 보관했다가 동일 객체를 리턴3-2. 두 개 이상의 설정 파일을 사용하기  @AutoWired 어노테이션을 통해 필요한 Bean 객체를 자동 주입  @Import 어노테이션을 통해 함께 사용할 클래스를 지정",
        "url": "/devlog/2019/12/30/spring-3.html"
      }
      ,
    
      "devlog-2019-12-26-spring-2-html": {
        "title": "[Spring] 스프링 시작하기",
        "subtitle":"첫걸음 - 2",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "0. 들어가기 앞서스프링을 이용한 자바 프로젝트 진행 과정은 아래와 같다.  메이븐 프로젝트 생성  이클립스에서 메이븐 프로젝트 Import  스프링에 맞는 자바 코드와 설정 파일 작성  실행1. Maven1-1. 메이븐 기본 디렉토리 구조  Maven 기본 설정 파일인 pom.xml 파일이 프로젝트 root에 위치  기본 소스코드 디렉토리          src/main/java        테스트코드 디렉토리          src/test/java        compile 결과 디렉토리          target      1-2. 메이븐 기초  메이븐의 핵심 pom.xml  pom.xml은 메이븐 프로젝트에 대한 설정 정보를 관리하는 파일  의존 모듈이나 플러그인 등에 대한 설정을 담음1-3. 메이븐 의존 설정&lt;!-- pom.xml --&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;  메이븐은 한 개의 모듈을 아티팩트 단위로 관리  위 설정은 spring-context 식별자를 가진 5.0.2.RELEASE 버전의 아티팩트에 대한 의존을 추가한 예제1-4. 메이븐 레포지토리  메이븐의 아티팩트 파일은 기본적으로 원격 레포지토리와 로컬 레포지토리를 이용  메이븐은 로컬 레포지토리에서 [그룹ID][아티팩트ID][버전] 폴더에 아티팩트ID-버전.jar 형식의 이름을 갖는 파일이 있는지 검사  로컬 레포지토리에 파일이 없으면 메이븐은 원격 중앙 레포지토리로부터 해당 파일을 다운로드하여 로컬 레포지토리에 복사한 뒤 그 파일을 사용  설정한 아티팩트가 다시 의존하는 파일도 포함하여 다운로드  배포 및 테스트할 때는 로컬 레포지토리(.m2등)에 있는 파일을 지우고 원격 레포지토리에서 다운로드하는 것을 권장1-5. 메이븐 프로젝트 임포트  이클립스에서 [File]-&gt;[Import] 메뉴 이용2. About Spring2-1. 스프링이 생성하고 관리하는 객체 = Bean//AppContext.java@Configurationpublic class AppContext {    @Bean    public Greeter greeter() {        ...    }    }  @configuration 어노테이션은 해당 클래스를 스프링 설정 클래스로 지정  @Bean 어노테이션을 매서드에 붙이면 해당 매서드가 생성한 객체를 스프링이 관리하는 Bean 객체로 등록  @Bean 어노테이션을 붙인 매서드의 이름은 Bean 객체를 구분할 때 사용 (위의 예시에서는 greeter를 사용하게 됨)  @Configuration 어노테이션 말고, XML 파일로도 설정파일을 생성 가능@Configuration 어노테이션은 변경사항이 생길 시, 매번 컴파일 해야하지만 XML로 설정한 파일은 몇 글자를 고치기만 하면 됨자세한 사항은 링크 참조: https://bit.ly/2MGXG1J2-2. 스프링은 객체 컨테이너//Main.javapublic class Main {\tpublic static void main(String[] args) {                // 1. 설정 정보를 이용해 Bean 객체를 생성\t\tAnnotationConfigApplicationContext ctx = \t\t\t\tnew AnnotationConfigApplicationContext(AppContext.class);                // 2. Bean 객체를 제공\t\tGreeter g = ctx.getBean(\"greeter\", Greeter.class);\t\t...\t\tctx.close();\t}}  AnnotationConfigApplicationContext 클래스는 스프링의 핵심인 객체 생성 및 초기화를 담당, 자바 클래스의 정보를 읽어옴  AnnotationConfigApplicationContext의 상위 클래스 ApplicationContext 또는 BeanFactory는 Bean 객체의 생성, 초기화, 보관, 관리 등을 담당하고 있어 컨테이너(Container)라고도 부름  getBean() 매서드를 통해 해당 Bean 객체를 제공          컨테이너는 보통 인스턴스의 생명주기를 관리하며, 생성된 인스턴스들에게 추가적인 기능을 제공하도록하는 것스프링 컨테이너의 두 종류: 빈팩토리(BeanFactory), 어플리케이션 컨텍스트(ApplicationContext)              BeanFactory: DI의 기본사항을 제공하는 가장 단순한 컨테이너, Bean을 생성하고 분배하는 책임을 지는 클래스ApplicationContext: 빈팩토리와 유사한 기능을 제공하지만 좀 더 많은 기능을 제공하는 어플리케이션 컨텍스트추가기능:                  국제화가 지원되는 텍스트 메시지를 관리          이미지같은 파일 자원을 로드 할 수 있는 포괄적인 방법을 제공          리너스로 등록된 빈에게 이벤트 발생을 알려 줌                    2-3. Singleton 객체  별도의 설정을 하지 않을 경우 스프링은 한 개의 Bean 객체만을 생성  이때 Bean 객체는 싱글톤(singleton) 범위를 갖는다고 표현  싱글톤은 단일 객체(single object)를 의미  스프링은 기본적으로 한 개의 @Bean 어노테이션에 한 개의 Bean 객체를 생성      이때 singleton은 디자인 패턴의 singleton과는 약간의 차이가 존재    스프링의 싱글톤은 직접 오브젝트를 만들고 관리    자바의 싱글톤 = private static으로 인스턴스 생성 / 스프링의 싱글톤 = 싱글톤 레지스트리    자세한 사항은 링크 참조: https://bit.ly/2MG41KR  ",
        "url": "/devlog/2019/12/26/spring-2.html"
      }
      ,
    
      "devlog-2019-12-26-spring-1-html": {
        "title": "[Spring] 스프링이란?",
        "subtitle":"첫걸음 - 1",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "스프링이란?  흔히 말하는 스프링 = 스프링 프레임워크스프링 프레임워크의 특징은 다음와 같다.  의존 주입(Dependency Injection: DI) 지원  AOP(Aspect-Oriented Programming) 지원  MVC 웹 프레임워크 제공  JDBC, JPA 연동, 선언적 트랜잭션 처리 등 DB 연동지원  spring과 spring MVC는 다르다스프링 프레임워크의 주요 용어는 다음과 같다.  의존 주입: 객체를 직접 생성하는 것이 아닌 외부에서 객체를 주입시켜 사용하는 방식  AOP: 핵심 기능과 공통 기능을 분리 시켜놓고, 공통 기능을 필요로 하는 핵심 기능들에서 사용하는 방식  JDBC:  자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API  JPA: JPA란 자바 ORM 기술에 대한 API 표준 명세  ORM: 객체와 DB 테이블이 매핑을 이루는 것  선언적 트랜잭션: 설정 파일이나 어노테이션을 통해 트랜잭션의 범위, 롤백 규칙 등을 정의스프링 프레임워크외 다른 스프링 프로젝트는 아래와 같다.  스프링 데이터: 적은 양의 코드로 데이터 연동을 처리할 수 있도록 도와주는 프레임워크. JPA, 몽고DB, 레디스등 다양한 저장소 지원  스프링 시큐리티: 인증/인가와 관련된 프레임워크로서 웹 접근 제어, 객체 접근 제어, DB, 오픈 ID, LDAP 등 다양한 인증 방식, 암호화 기능 제공  스프링 배치: 로깅/추적, 작업 통계, 실패 처리 등 배치 처리에 필요한 기본 기능을 제공개발환경  Spring: 5.0.2.RELEASE  Java openjdk 1.8.0_22  Apache maven 3.7  Tomcat 8.5.43",
        "url": "/devlog/2019/12/26/spring-1.html"
      }
      ,
    
      "devlog-2019-12-26-spring-0-html": {
        "title": "[Spring] 스프링5 스터디를 위한 프로젝트",
        "subtitle":"첫걸음 - 0",
        "author": "owin2828", 
        "categories": "devlog",
        "tags": "spring",
        "content": "스프링5 스터디를 위한 프로젝트      본 시리즈는 다음 2가지의 교재를 바탕으로 학습에 목적을 둔 글임을 밝힙니다.    목차 1~17:          교재: 초보자를 위한 스프링5 프로그래밍 입문      저자: 최범균      소스코드: https://github.com/madvirus/spring5fs        목차 18~:          교재: 스프링5 레시피      저자: 마틴 데니엄, 다니엘 루비오, 조시 롱 지음, 이일웅 옮김      소스코드: https://github.com/nililee/spring-5-recipes      목차  Intro  스프링 시작하기  스프링 DI  의존 자동 주입  컴포넌트 스캔  Bean 라이프사이클과 범위  AOP 프로그래밍  DB연동  스프링 MVC 시작하기  스프링 MVC 동작방식  MVC1: 요청 매핑, 커맨드 객체, 리다이렉트, 폼 태그, 모델  MVC2: 메시지, 커맨드 객체 검증  MVC3: 세션, 인터셉션, 쿠키  MVC4: 날짜 값 변환, @PathVariable, 익셉션 처리  간단한 웹 어플리케이션의 구조  JSON 응답과 요청 처리  프로필과 프로퍼티 파일  Spring Security부록0-1. try ~ catch ~ finally문 return위치에 따른 결과 in Java0-2. Abstract Class VS Interface0-3. JDBC란0-4. 커넥션 풀0-5. JDBC, JPA/Hibernate, Mybatis 차이",
        "url": "/devlog/2019/12/26/spring-0.html"
      }
      
    
  };
</script>
<script src="/js/lunr.min.js" charset="utf-8"></script>
<script src="/js/search.js" charset="utf-8"></script>

<!-- just under line for input box -->
<style>
  input.underline {
    border-style:none;
    border-bottom:1px solid #000;
    box-shadow: 0 1px 0 0 #000;
  }
</style>
</body>

  <!-- Footer -->

<hr>

<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        <ul class="list-inline text-center">
          
          <li class="list-inline-item">
            <a href="mailto:owin2828@gmail.com">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="far fa-envelope fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
          
          
          
          
          <li class="list-inline-item">
            <a href="https://github.com/owin2828">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="copyright text-muted">Copyright &copy; owin2828 2020</p>
      </div>
    </div>
  </div>
</footer>


  <script src="/assets/vendor/jquery/jquery.min.js"></script>
<script src="/assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
<script src="/assets/vendor/startbootstrap-clean-blog/js/clean-blog.min.js"></script>

<!-- 이미지 및 캡션 -->
<script src="/assets/lib/jquery-1.12.0.min.js"></script>
<script src="/assets/lib/jquery.magnific-popup.min.js"></script>
<script src="/assets/js/index.js"></script>

<!-- 사이드바 메뉴 플로팅 -->
<script src="/assets/sidebar.js"></script>

<script src="/assets/scripts.js"></script>




</body>

</html>
