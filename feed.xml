<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="https://owin2828.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://owin2828.github.io/" rel="alternate" type="text/html" /><updated>2020-10-26T16:07:48+09:00</updated><id>https://owin2828.github.io/feed.xml</id><title type="html">낮코밤코</title><subtitle>Already done, cause will do</subtitle><author><name>owin2828</name></author><entry><title type="html">[Vue] 인스턴스</title><link href="https://owin2828.github.io/devlog/2020/10/21/web-6.html" rel="alternate" type="text/html" title="[Vue] 인스턴스" /><published>2020-10-21T11:15:00+09:00</published><updated>2020-10-21T11:15:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/10/21/web-6</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/10/21/web-6.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;뷰로 웹 개발을 하기 위해 필수적인 &lt;code class=&quot;highlighter-rouge&quot;&gt;인스턴스&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;컴포넌트&lt;/code&gt;에 대해 알아보고, 각 요소들의 필요성에 대해 알아보자.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;본 글에 앞서, 크롬 익스텐션 &lt;code class=&quot;highlighter-rouge&quot;&gt;Vue.js devtools&lt;/code&gt;를 설치 후, 실행하는 것을 권장합니다.&lt;br /&gt;
  설치법은 &lt;a href=&quot;https://hubring.tistory.com/17&quot;&gt;이곳&lt;/a&gt;을 참조&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-hello-vuejs&quot;&gt;1. Hello Vue.js&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;index.html 파일을 하나 생성 한 후, 다음과 같이 작성한다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Vue Sample&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;app&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      { { message }}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Vue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;#app&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Hello Vue.js!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;해당 파일을 크롬 브라우저를 통해 열게되면, 화면에 Hello Vue.js! 라는 문구가 뜨게 된다.&lt;br /&gt;
이제 각 속성들에 대하여 알아보도록 하자.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-뷰-인스턴스의-정의와-속성&quot;&gt;2. 뷰 인스턴스의 정의와 속성&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;뷰에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;인스턴스(Instance)&lt;/code&gt;는 뷰로 화면 개발을 위해 필수적으로 생성해야 하는 기본 단위이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;뷰 인스턴스 생성&lt;br /&gt;
  뷰 인스턴스는 다음과 같은 형식으로 생성한다.
    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// 인스턴스&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Vue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
     &lt;span class=&quot;na&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;#app&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// el 속성&lt;/span&gt;
     &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// data 속성&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Hello Vue.js!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;‘Hello Vue.js!’ 텍스트를 화면에 표시하기 위해, &lt;code class=&quot;highlighter-rouge&quot;&gt;new Vue()&lt;/code&gt;를 통해 인스턴스를 생성한다.&lt;br /&gt;
  그 후, 인스턴스 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;el 속성&lt;/code&gt;으로 뷰 인스턴스가 그려질 위치를 지정하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;data 속성&lt;/code&gt;에 message 값을 정의하여 화면의 &lt;code class=&quot;highlighter-rouge&quot;&gt;{ {message}}&lt;/code&gt;와 연결한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;뷰 인스턴스 생성자&lt;br /&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;new Vue()&lt;/code&gt;로 인스턴스를 생성할 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;Vue&lt;/code&gt;를 생성자라고 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-뷰-인스턴스-옵션-속성&quot;&gt;3. 뷰 인스턴스 옵션 속성&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;뷰 인스턴스 속성은 인스턴스를 생성할 때, 재정의할 &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;el&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;template&lt;/code&gt;등의 속성을 포함한다.&lt;br /&gt;
그 중, &lt;code class=&quot;highlighter-rouge&quot;&gt;el&lt;/code&gt;속성은 뷰로 만든 화면이 그려지는 시작점을 의미하며, 렌더링 시 화면이 그러질 위치의 돔 요소를 지정해 주어야한다.&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;app&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    { { message }}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Vue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;#app&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#app&lt;/code&gt;값은 화면의 돔 요소 중, &lt;code class=&quot;highlighter-rouge&quot;&gt;app&lt;/code&gt;이라는 아이디를 가진 요소를 의미&lt;br /&gt;
위 서술한 속성 외에도, &lt;code class=&quot;highlighter-rouge&quot;&gt;template&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;methods&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;created&lt;/code&gt; 등이 존재&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;4-뷰-인스턴스의-유효범위&quot;&gt;4. 뷰 인스턴스의 유효범위&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;뷰 인스턴스를 생성하면 HTML의 &lt;code class=&quot;highlighter-rouge&quot;&gt;특정&lt;/code&gt; 범위 안에서만 옵션들이 적용되어 나타나며, 이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;el&lt;/code&gt; 속성과 밀접한 관련이 있다.&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Vue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;el&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;#app&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 아래의 message 값이 message에 치환되어 출력&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Hello Vue.js!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 치환전 --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;app&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    { { message }}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 치환 후 --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;app&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- el 태그가 부착된 이 div 태그 아래 값들만 치환되는 유효범위 --&amp;gt;&lt;/span&gt;
    Hello Vue.js!
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;el&lt;/code&gt; 속성에 인스턴스가 부착되고 나면, 인스턴스에 정의한 &lt;code class=&quot;highlighter-rouge&quot;&gt;옵션 객체&lt;/code&gt;의 내용이 el 속성에 지정한 화면 요소와 그 이하 레벨의 화면요소에 값이 적용되어 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;치환&lt;/code&gt; 된다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-뷰-인스턴스-라이프-사이클&quot;&gt;5. 뷰 인스턴스 라이프 사이클&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;인스턴스의 상태에 따라 호출할 수 있는 속성들을 &lt;code class=&quot;highlighter-rouge&quot;&gt;라이프 사이클(life cycle) 속성&lt;/code&gt;이라고 한다.&lt;br /&gt;
그리고 각 라이프 사이클 속성에서 실행되는 커스텀 로직을 &lt;code class=&quot;highlighter-rouge&quot;&gt;라이프 사이클 훅(hook)&lt;/code&gt;이라고 한다.&lt;/p&gt;

&lt;figure&gt;
&lt;p&gt;&lt;img src=&quot;/img/web/web_5_2.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;
  &lt;figcaption&gt;뷰 라이프 사이클 다이어그램&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;라이프 사이클은 크게 인스턴스 &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt;, 생성된 인스턴스를 화면에 &lt;code class=&quot;highlighter-rouge&quot;&gt;부착&lt;/code&gt;, 인스턴스 내용의 &lt;code class=&quot;highlighter-rouge&quot;&gt;갱신&lt;/code&gt;, 인스턴스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;소멸&lt;/code&gt; 4가지로 이루어진다.&lt;br /&gt;
각 라이프 사이클에는 다시 2단계로 나뉘어 다음과 같은 총 8 단계로 구성된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;beforeCreate&lt;/code&gt;&lt;br /&gt;
  인스턴스가 생성되고 가장 처음으로 실행되는 단계, 속성 및 DOM에 접근이 &lt;code class=&quot;highlighter-rouge&quot;&gt;불가&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;created&lt;/code&gt;&lt;br /&gt;
  인스턴스가 화면에 부착되기 전 단계, data와 method에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;접근 가능&lt;/code&gt;하나 template 속성에 정의된 돔 요소에 접근 &lt;code class=&quot;highlighter-rouge&quot;&gt;불가&lt;/code&gt;&lt;br /&gt;
  data, methods 등의 속성이 정의되어 &lt;code class=&quot;highlighter-rouge&quot;&gt;서버에 데이터를 요청&lt;/code&gt;하여 받아오는 로직을 수행하기 알맞음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;beforeMount&lt;/code&gt;&lt;br /&gt;
  DOM에 인스턴스를 부착하기 전 단계, &lt;code class=&quot;highlighter-rouge&quot;&gt;render()&lt;/code&gt; 함수가 호출되기 직전의 로직을 추가&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mounted&lt;/code&gt;&lt;br /&gt;
  el 속성에서 지정한 요소에 인스턴스가 부착되고 나면 호출되는 단계&lt;br /&gt;
  template에 접근 가능하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;화면 요소를 제어&lt;/code&gt;하는 로직을 수행하기 알맞음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;beforeUpdate&lt;/code&gt;  &lt;br /&gt;
  관찰하고 있는 데이터가 변경 시, 가상DOM으로 화면을 다시 그리기 전 호출하는 단계&lt;br /&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;변경 예정 데이터의 값&lt;/code&gt;과 관련된 로직을 미리 넣기 알맞음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;updated&lt;/code&gt;&lt;br /&gt;
  데이터가 변경되고나서 가상DOM으로 화면을 다시 그리고 나면 실행되는 단계&lt;br /&gt;
  데이터 변경 후, &lt;code class=&quot;highlighter-rouge&quot;&gt;화면 요소 제어&lt;/code&gt;와 관련된 로직을 추가하기 알맞음
    &lt;blockquote&gt;
      &lt;p&gt;이 단계에서 데이터를 변경하면 무한 루프에 빠질 수 있기 때문에 값 변경을 위해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;computed&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;watch&lt;/code&gt; 속성을 사용해야 함&lt;br /&gt;
  따라서 데이터 값을 갱신하는 로직은 가급적 &lt;code class=&quot;highlighter-rouge&quot;&gt;beforeUpdate&lt;/code&gt;에 추가하고, updated에서는 변경 데이터의 &lt;code class=&quot;highlighter-rouge&quot;&gt;화면요소(DOM)&lt;/code&gt; 로직을 추가해야 함&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;beforeDestory&lt;/code&gt;&lt;br /&gt;
  인스턴스가 파괴되기 직전 단계, 인스턴스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;데이터를 삭제&lt;/code&gt;하기 알맞음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;destroyed&lt;/code&gt;
  뷰 인스턴스가 파괴되고 호출되는 단계
  모든 속성이 제거되고 하위 인스턴스가 모두 파괴&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;p&gt;뷰의 인스턴스와 라이프 사이클에 대하여 알아보았다.&lt;br /&gt;
다음 포스팅에서는 뷰 &lt;code class=&quot;highlighter-rouge&quot;&gt;컴포넌트&lt;/code&gt;에 대하여 알아보도록 하자.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="devlog" /><category term="web" /><summary type="html">들어가기 앞서 뷰로 웹 개발을 하기 위해 필수적인 인스턴스와 컴포넌트에 대해 알아보고, 각 요소들의 필요성에 대해 알아보자. 본 글에 앞서, 크롬 익스텐션 Vue.js devtools를 설치 후, 실행하는 것을 권장합니다. 설치법은 이곳을 참조</summary></entry><entry><title type="html">[Vue] Vue.js 시작</title><link href="https://owin2828.github.io/devlog/2020/10/21/web-5.html" rel="alternate" type="text/html" title="[Vue] Vue.js 시작" /><published>2020-10-21T09:56:00+09:00</published><updated>2020-10-21T09:56:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/10/21/web-5</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/10/21/web-5.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Front-End&lt;/code&gt;를 담당하는 프레임워크 중 3대장은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Vue&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;React&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Angular&lt;/code&gt;이 있다. 
그 중, 가장 최근에 나온 &lt;code class=&quot;highlighter-rouge&quot;&gt;Vue&lt;/code&gt;에 대하여 알아보기 위해 포스팅을 시작한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;본 시리즈는 다음의 교재를 바탕으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;학습&lt;/code&gt;에 목적을 둔 글임을 밝힙니다.
    &lt;ul&gt;
      &lt;li&gt;교재: Vue.js 입문&lt;/li&gt;
      &lt;li&gt;저자: 장기효&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-vuejs란-무엇인가&quot;&gt;1. Vue.js란 무엇인가&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vue.js&lt;/code&gt;는 웹 페이지 개발을 위한 프론트엔드 프레임워크이다.
창시자인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Evan You&lt;/code&gt;는 앵귤러와 리액트의 장점을 살려 Vue를 만들었다고 한다. &lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-vuejs-장점&quot;&gt;2. Vue.js 장점&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;다음은 Vue.js 장점이라고 알려진 특징이다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;배우기가 쉽다.&lt;/li&gt;
  &lt;li&gt;리액트와 앵귤러에 비해 성능이 뛰어나다.&lt;/li&gt;
  &lt;li&gt;리액트와 앵귤러의 장점을 갖고 있다.
    &lt;blockquote&gt;
      &lt;p&gt;앵귤러의 &lt;code class=&quot;highlighter-rouge&quot;&gt;데이터 바인딩&lt;/code&gt; 특성과 리액트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;가상 돔&lt;/code&gt; 기반 렌더링 특징을 가지고 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-vuejs의-특징&quot;&gt;3. Vue.js의 특징&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Vue.js는 다음과 같이 크게 4가지 특징을 지닌다.&lt;/p&gt;

&lt;h4 id=&quot;3-1-ui-화면단-라이브러리&quot;&gt;3-1. UI 화면단 라이브러리&lt;/h4&gt;
&lt;p&gt;Vue.js는 &lt;code class=&quot;highlighter-rouge&quot;&gt;MVVM&lt;/code&gt; 패턴에 해당하는 화면단 라이브러리이다.  이러한 방식을 채택함으로써, 화면의 요소들을 제어하는 코드와 데이터 제어 로직을 &lt;code class=&quot;highlighter-rouge&quot;&gt;분리&lt;/code&gt;하여 코드를 더 &lt;code class=&quot;highlighter-rouge&quot;&gt;직관적&lt;/code&gt;으로 이해가 가능하며, 추후 &lt;code class=&quot;highlighter-rouge&quot;&gt;유지보수&lt;/code&gt;가 용이하다.&lt;/p&gt;

&lt;figure&gt;
&lt;p&gt;&lt;img src=&quot;/img/web/web_5_1.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
  &lt;figcaption&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MVVM&lt;/code&gt; 패턴이란 화면을 모델(Model) - 뷰(View) - 뷰 모델(ViewModel) 방식으로 구조화하여 개발하는 방식을 의미&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-2-컴포넌트-기반-프레임워크&quot;&gt;3-2. 컴포넌트 기반 프레임워크&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;컴포넌트(component)&lt;/code&gt;란 레고 블럭과 같다. 뷰의 컴포넌트들을 잘 쌓아서 화면이 구성 가능한데, 이러한 방식의 장점은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;높은 재사용성&lt;/li&gt;
  &lt;li&gt;HTML 코드에서 화면의 구조를 직관적으로 파악 가능&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;3-3-리액트와-앵귤러의-장점을-가진-프레임워크&quot;&gt;3-3. 리액트와 앵귤러의 장점을 가진 프레임워크&lt;/h4&gt;
&lt;p&gt;뷰는 앵귤러의 &lt;code class=&quot;highlighter-rouge&quot;&gt;양방향 데이터 바인딩&lt;/code&gt;과 리액트의 &lt;code class=&quot;highlighter-rouge&quot;&gt;단방향 데이터 흐름&lt;/code&gt;의 장점을 모두 결합한 프레임워크이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;양방향데이터 바인딩이란, 화면에 표시되는 값과 프레임워크 모델 데이터 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;동기화&lt;/code&gt;되어, 한쪽의 변경이 다른쪽에 &lt;code class=&quot;highlighter-rouge&quot;&gt;자동 반영&lt;/code&gt;되는 것이며,&lt;br /&gt;
단뱡향 데이터 흐름은 항상 상위 컴포넌트에서 하위 컴포넌트로 &lt;code class=&quot;highlighter-rouge&quot;&gt;단방향 전달&lt;/code&gt;하도록 되어있는 구조를 의미&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;3-4-가상-돔-사용&quot;&gt;3-4. 가상 돔 사용&lt;/h4&gt;
&lt;p&gt;뷰는 빠른 화면 렌더링을 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;가상 돔(Virtual DOM)&lt;/code&gt; 방식을 적용하여, 사용자 인터렉션이 많은 요즘 웹 화면에 적합한 동작 구조를 지닌다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;가상 돔&lt;/code&gt;을 사용하면, 특정 돔 요소를 추가하거나 삭제하는 변경이 일어날 때 화면 전체를 다시 그리지 않고,&lt;br /&gt;
프레임 워크에서 정의한 방식대로 화면을 &lt;code class=&quot;highlighter-rouge&quot;&gt;갱신&lt;/code&gt;하여 성능을 높임&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;p&gt;간단하게 뷰의 특징과 장점에 대해서 알아보았지만, 백앤드 개발을 주로 하는 나에게는 잘 다가오지 않는다..&lt;br /&gt;
역시 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hello world&lt;/code&gt;를 한 번 해봐야 알 것 같다. 그런 의미에서 다음 글에서는 간단한 프로젝트를 만들어 보도록 하겠다.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="devlog" /><category term="web" /><summary type="html">들어가기 앞서 Front-End를 담당하는 프레임워크 중 3대장은 Vue, React, Angular이 있다. 그 중, 가장 최근에 나온 Vue에 대하여 알아보기 위해 포스팅을 시작한다.</summary></entry><entry><title type="html">[PSQL]PostgreSQL 설치 및 data 저장 위치 변경</title><link href="https://owin2828.github.io/devlog/2020/10/19/etc-8.html" rel="alternate" type="text/html" title="[PSQL]PostgreSQL 설치 및 data 저장 위치 변경" /><published>2020-10-19T13:29:00+09:00</published><updated>2020-10-19T13:29:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/10/19/etc-8</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/10/19/etc-8.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;본 문서에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;PSQL&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS 7 설치&lt;/code&gt; 및 &lt;code class=&quot;highlighter-rouge&quot;&gt;Data directory 변경&lt;/code&gt; 방법에 대하여 기술한다.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;psql-설치&quot;&gt;PSQL 설치&lt;/h2&gt;
&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;설치
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;postgresql94-server postgresql94-contrib
 &lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt; /usr/pgsql-9.4/bin/postgresql94-setup initdb
 &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;postgresql-9.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;기동
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start postgresql-9.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;psql-기본-설정&quot;&gt;PSQL 기본 설정&lt;/h2&gt;
&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;listen 변경
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 설정파일 - /var/lib/pgsql/9.4/data/postgresql.conf
 org
 #listen_address = 'localhost'
 change
 listen_address = '*'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;권한 변경
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 설정파일 - /var/lib/pgsql/9.4/data/pg_hba.conf
 org
 local   all             all                        peer
 host    all             all    127.0.0.1/32        trust
 change
 local   all             all                        trust
 host    all             all             0.0.0.0/0            trust
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;psql-data-directory-변경&quot;&gt;PSQL DATA DIRECTORY 변경&lt;/h2&gt;
&lt;hr /&gt;
&lt;ol&gt;
  &lt;li&gt;현재 data directory 확인
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sudo -iu postgres
 postgres=# show data_directory;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;db 중지
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sudo systemctl stop postgresql-9.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;db 설정 파일 수정
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 설정파일 - /var/lib/pgsql/9.4/data/postmaster.opts
 /user/pgsql-9.4/bin/postgres &quot;-D&quot; &quot;&amp;lt;&amp;lt;to directory&amp;gt;&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스 설정 파일 수정
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 설정파일 - /etc/lib/systemd/system/postgresql-9.4.service
 Environment=PGDATA=&amp;lt;&amp;lt;to directory&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;기존 데이터 복사
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nb&quot;&gt;mv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt; directory&amp;gt;&amp;gt; &amp;lt;&amp;lt;to directory&amp;gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스 재시작
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; systemctl daemon-reload
 systemctl start postgresql-9.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;현재 data directory 확인 (1번방법)&lt;/li&gt;
&lt;/ol&gt;</content><author><name>owin2828</name></author><category term="devlog" /><category term="etc" /><summary type="html">들어가기 앞서 본 문서에서는 PSQL CentOS 7 설치 및 Data directory 변경 방법에 대하여 기술한다.</summary></entry><entry><title type="html">[Thanos]프로메테우스의 스케일링 tool</title><link href="https://owin2828.github.io/devlog/2020/03/13/etc-7.html" rel="alternate" type="text/html" title="[Thanos]프로메테우스의 스케일링 tool" /><published>2020-03-13T18:19:00+09:00</published><updated>2020-03-13T18:19:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/03/13/etc-7</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/03/13/etc-7.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;프로메테우스&lt;/code&gt;는 좋은 모니터링 툴이지만, 앞선 글에서 언급했듯이 클러스터링 구조를 지원하지 않기 때문에 다음과 같은 결정적인 두 가지 &lt;code class=&quot;highlighter-rouge&quot;&gt;문제점&lt;/code&gt;을 지닌다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;확장성의 어려움&lt;/li&gt;
  &lt;li&gt;가용성의 어려움&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;확장성&lt;/code&gt;의 문제는 디스크를 사서 붙이는 것으로 어느 정도 해결이된다. 
하지만 데이터의 양이 방대해지고 많아질 경우, 이러한 방식으로 매 번 증축할 수 없고 결국 하나의 프로메테우스 인스턴스로는 감당이 되지 않는 &lt;code class=&quot;highlighter-rouge&quot;&gt;문제&lt;/code&gt;가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_7_1.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;
이러한 문제를 해결하기 위해 프로메테우스에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Federation&lt;/code&gt;이라는 방법을 권장한다. 
프로메테우스 인스턴스를 여러개 만들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master-Slave&lt;/code&gt; 구로조 관리를 하여 계층적으로 관리를 하는 방법이다. 
약간은 지저분하고 또 복잡해 보이지만, 위의 구조를 사용함으로써 어느정도 보완이 되었다. 
하지만 여전히 이러한 구조는 단점을 지닌다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;가용성&lt;/code&gt;의 문제가 바로 그것인데, 프로메테우스는 기본적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;하나&lt;/code&gt;의 서버로 기동된다. 
따라서 실행중인 서버가 다운되거나 장애 및 재시작 등의 업무로 인해 생기는 공백의 기간동안은 메트릭을 수집할 수 &lt;code class=&quot;highlighter-rouge&quot;&gt;없다&lt;/code&gt;. 
클러스터링 기능이 존재하지 않기 때문에 이러한 문제점을 해결하기 위해서는 다음의 그림과 같이 프로메테우스 인스턴스를 &lt;code class=&quot;highlighter-rouge&quot;&gt;두 개&lt;/code&gt; 띄우고 같은 대상으로부터 메트릭을 수집해야 한다.&lt;br /&gt;
&lt;img src=&quot;/img/etc/etc_7_2.png&quot; alt=&quot;&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;여전히 마음에 들지 않는다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-thanos란&quot;&gt;1. Thanos란&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;위와 같은 문제를 해결하기 위해 등장한 것이 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Thanos&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_7_3.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;
타노스의 기본 구조는 위와 같다. 여러개의 프로메테우스에서 메트릭 정보를 받아 &lt;code class=&quot;highlighter-rouge&quot;&gt;전체적인&lt;/code&gt; 정보를 제공해준다. 
또한 수집된 메트릭을 &lt;code class=&quot;highlighter-rouge&quot;&gt;스케일&lt;/code&gt;이 가능한 스토리지에 저장해서 특정 프로메테우스 인스턴스가 다운이 되더라도, 그 인스턴스가 담당하는 메트릭을 &lt;code class=&quot;highlighter-rouge&quot;&gt;조회&lt;/code&gt;할 수 있도록 해준다. 
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-thanos-아키텍처&quot;&gt;2. Thanos 아키텍처&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;타노스의 전반적인 이해를 돕기 위해 타노스의 아키텍처를 살펴본다.&lt;/p&gt;

&lt;h4 id=&quot;2-1-thanos-side-car--querier&quot;&gt;2-1. Thanos Side car &amp;amp; Querier&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/etc/etc_7_4.png&quot; alt=&quot;&quot; width=&quot;30%&quot; /&gt;
타노스는 프로메테우스 서버에 &lt;code class=&quot;highlighter-rouge&quot;&gt;타노스 에이전트(Thanos Sidecar)&lt;/code&gt;를 설치하여 데이터를 조회할 수 있도록 한다. 
프로메테우스는 수집된 메트릭 데이터를 로컬 디스크에 저장하기 때문에 타노스 에이전트는 디스크에 저장된 내용을 읽어 필요시 쿼리 엔진에게 전달한다. 
이러한 구조로 이루어져 있기 때문에 사용자가 관리하고 바라보는 것은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Thanos Query&lt;/code&gt; 하나로 줄어들게 된다.&lt;/p&gt;

&lt;h4 id=&quot;2-2-ha-지원&quot;&gt;2-2. HA 지원&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/etc/etc_7_5.png&quot; alt=&quot;&quot; width=&quot;30%&quot; /&gt;
타노스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;HA&lt;/code&gt;(High Availability, 서버 이중화)는 기존과 동일하다. 프로메테우스 인스턴스를 두 개 띄워서 같은 대상을 모니터링 하는 것이다. 
기존 방식에서는 프로메테우스 인스턴스를 각각 모니터링 해야하지만, 타노스는 특정 그룹의 프로메테우스 인스턴스들을 &lt;code class=&quot;highlighter-rouge&quot;&gt;하나로&lt;/code&gt; 처리해서 메트릭을 보여준다. 
즉, 두 인스턴스에서 수집된 메트릭을 &lt;code class=&quot;highlighter-rouge&quot;&gt;합쳐서&lt;/code&gt; 보여줄 수도 있고, &lt;code class=&quot;highlighter-rouge&quot;&gt;중복값을 제거&lt;/code&gt;해주는 De-duplication 기능을 지원한다.&lt;/p&gt;

&lt;h4 id=&quot;2-3-오래된-값-저장&quot;&gt;2-3. 오래된 값 저장&lt;/h4&gt;
&lt;p&gt;프로메테우스는 로컬에 데이터를 저장하기 때문에 일정 기간이 지난 데이터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;삭제&lt;/code&gt;된다. 따라서 기간이 오래된 데이터는 조회가 &lt;code class=&quot;highlighter-rouge&quot;&gt;불가능&lt;/code&gt;하다. 
이 문제는 여러 대의 프로메테우스를 모니터링하게 되므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;타노스에서도 발생&lt;/code&gt;하는데, 메모리와 로컬디스크의 용량 문제로 여러 프로메테우스 모니터링이 &lt;code class=&quot;highlighter-rouge&quot;&gt;불가능&lt;/code&gt;하게 된다. 
이를 해결하기 위해 타노스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;외부 스토리지&lt;/code&gt;를 사용한다.&lt;/p&gt;

&lt;p&gt;프로메테우스에서 수집된 데이터는 2시간 정도 메모리에 저장된 후, 로컬 디스크로 덤프되어 저장된다. 이 데이터를 &lt;code class=&quot;highlighter-rouge&quot;&gt;타노스 에이전트&lt;/code&gt;가 수집하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;외부 스토리지에 저장&lt;/code&gt;한다. 
외부 스토리지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ceph&lt;/code&gt;와 같은 분산형 파일 시스템 혹은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Google Cloud Storage&lt;/code&gt;, AWS &lt;code class=&quot;highlighter-rouge&quot;&gt;S3&lt;/code&gt;와 같은 클라우드 스토리지를 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_7_6.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;
즉 쿼리 엔진에서 최근의 데이터를 조회할 때는 타노스 에이전트를 통해서 가져오고, 오래된 데이터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Thanos Sotrage Gateway&lt;/code&gt;를 통해 조회한다. 
이 게이트웨이는 외부 스토리지에 저장된 데이터를 &lt;code class=&quot;highlighter-rouge&quot;&gt;Storage API&lt;/code&gt;를 통해 쿼리 엔진과 통신하는 역할 및 &lt;code class=&quot;highlighter-rouge&quot;&gt;캐싱 기능&lt;/code&gt;을 제공한다.&lt;/p&gt;

&lt;p&gt;데이터가 많이 축적되게 되면, 오래된 데이터를 조회하는 경우 많은 양을 조회하기 때문에 성능에 문제가 발생한다. 
이러한 문제를 피하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;Compactor&lt;/code&gt;가 존재하는데, 데이터 파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;압축&lt;/code&gt;하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;다운 샘플링&lt;/code&gt;을 한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;다운 샘플링&lt;/code&gt;: 1분단위로 저장된 데이터를 10분이나 1시간 단위로 샘플링 기준을 낮춰서(해상도 낮춤) 전체 데이터 저장용량을 낮추는 방법&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;p&gt;본 포스팅은 &lt;a href=&quot;https://bcho.tistory.com/1372?category=731548&quot;&gt;조대협님의 블로그 글&lt;/a&gt;을 참조하여 학습용으로 작성된 글임을 밝힙니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://katacoda.com/bwplotka/courses/thanos&quot;&gt;katacoda 타노스 튜토리얼&lt;/a&gt;&lt;/p&gt;</content><author><name>owin2828</name></author><category term="devlog" /><category term="etc" /><summary type="html">들어가기 앞서 프로메테우스는 좋은 모니터링 툴이지만, 앞선 글에서 언급했듯이 클러스터링 구조를 지원하지 않기 때문에 다음과 같은 결정적인 두 가지 문제점을 지닌다. 확장성의 어려움 가용성의 어려움</summary></entry><entry><title type="html">[Grafana]프로메테우스 &amp;amp; 그라파나 연동</title><link href="https://owin2828.github.io/devlog/2020/03/13/etc-6.html" rel="alternate" type="text/html" title="[Grafana]프로메테우스 &amp;amp; 그라파나 연동" /><published>2020-03-13T17:29:00+09:00</published><updated>2020-03-13T17:29:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/03/13/etc-6</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/03/13/etc-6.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;프로메테우스&lt;/code&gt;가 메트릭의 정보를 가져오는 모니터링 툴이었다면, &lt;code class=&quot;highlighter-rouge&quot;&gt;그라파나&lt;/code&gt;는 가져온 메트릭 정보를 시각화 해주는 오픈소스 도구이다. 
그라파나는 다음과 같은 장점들로 인해 널리 사용되고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Graphite, Prometheus, InfluxDB등 &lt;code class=&quot;highlighter-rouge&quot;&gt;다양한&lt;/code&gt; 데이타베이스와 메트릭수집 시스템을 지원&lt;/li&gt;
  &lt;li&gt;하나의 대시보드에 동시에 &lt;code class=&quot;highlighter-rouge&quot;&gt;여러&lt;/code&gt; 메트릭 시스템들의 지표를 표시&lt;/li&gt;
  &lt;li&gt;설치 및 사용이 &lt;code class=&quot;highlighter-rouge&quot;&gt;쉬움&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;프로메테우스를 잘 &lt;code class=&quot;highlighter-rouge&quot;&gt;지원&lt;/code&gt;함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그라파나의 설치는 &lt;a href=&quot;https://grafana.com/docs/grafana/latest/installation/debian/&quot;&gt;공식문서&lt;/a&gt;를 따라 진행하면 된다. 
본 문서에서 이용한 환경은 이전 포스팅과 동일하게 katacoda에서 그라파나 듀토리얼을 사용한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.katacoda.com/courses/prometheus/creating-dashboards-with-grafana&quot;&gt;그라파나 듀토리얼&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-그라파나-설치-및-접속&quot;&gt;1. 그라파나 설치 및 접속&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;로그인 화면의 기본 ID/PW는 &lt;code class=&quot;highlighter-rouge&quot;&gt;amdin&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;admin&lt;/code&gt; 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;연동되었다면, &lt;code class=&quot;highlighter-rouge&quot;&gt;Add data source&lt;/code&gt;를 눌러 프로메테우스를 연결한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;본 문서에서는 프로메테우스를 localhost:9090에 실행중이므로, 사진과 같이 정보를 입력 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;savt &amp;amp; test&lt;/code&gt; 를 누른다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Create your first dashboard&lt;/code&gt;를 눌러 &lt;code class=&quot;highlighter-rouge&quot;&gt;Graph&lt;/code&gt;를 누르면 위와 같이 빈 그래프가 생성된다.&lt;/li&gt;
  &lt;li&gt;이때 &lt;code class=&quot;highlighter-rouge&quot;&gt;panel title&lt;/code&gt; 버튼을 눌러 메트릭을 추가한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사진과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Metrics&lt;/code&gt; 란에 &lt;code class=&quot;highlighter-rouge&quot;&gt;node_cpu&lt;/code&gt;를 입력하여 원하는 메트릭 정보를 입력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;그래프에 해당 메트릭이 표시되는 것을 알 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-그라파나-템플릿-사용&quot;&gt;2. 그라파나 템플릿 사용&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;그라파나의 장점은 이미 만들어진 다양한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Template&lt;/code&gt;이 존재한다는 것이다. 
사용자들이 다양한 템플릿을 만들어 공유하는데, 템플릿은 &lt;a href=&quot;https://grafana.com/dashboards/22&quot;&gt;https://grafana.com/dashboards/22&lt;/a&gt;에 가서 볼 수 있다. 
본 예제에서는 프로메테우스의 node_exporter에 의해 제공되는 템플릿을 import할 예정이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;상단의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node exporter single server&lt;/code&gt;를 클릭하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;Import Dashboard&lt;/code&gt;를 누른다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Json&lt;/code&gt; 파일로 템플릿을 저장할 수도 있지만, 제공하는 공식 탬플릿 중 ID:22 대시보드의 URL을 입력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;성공적으로 인식되었다면, 위의 사진과 같이 창이 변경되고 &lt;code class=&quot;highlighter-rouge&quot;&gt;prometheus&lt;/code&gt;란을 사진처럼 설정 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;Import&lt;/code&gt; 버튼을 누른다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 과정이 완료되면 사진처럼 준비된 대시보드가 로딩되게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;p&gt;본 포스팅은 &lt;a href=&quot;https://bcho.tistory.com/1372?category=731548&quot;&gt;조대협님의 블로그 글&lt;/a&gt;을 참조하여 학습용으로 작성된 글임을 밝힙니다.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="devlog" /><category term="etc" /><summary type="html">들어가기 앞서 프로메테우스가 메트릭의 정보를 가져오는 모니터링 툴이었다면, 그라파나는 가져온 메트릭 정보를 시각화 해주는 오픈소스 도구이다. 그라파나는 다음과 같은 장점들로 인해 널리 사용되고 있다.</summary></entry><entry><title type="html">[Prometheus]프로메테우스 개념 구조 및 quick start</title><link href="https://owin2828.github.io/devlog/2020/03/13/etc-5.html" rel="alternate" type="text/html" title="[Prometheus]프로메테우스 개념 구조 및 quick start" /><published>2020-03-13T16:09:00+09:00</published><updated>2020-03-13T16:09:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/03/13/etc-5</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/03/13/etc-5.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;프로메테우스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;오픈 소스&lt;/code&gt; 기반의 &lt;code class=&quot;highlighter-rouge&quot;&gt;모니터링&lt;/code&gt; 시스템이다. ELK 와 같은 로깅이 아니라, 대상 시스템으로 부터 각종 모니터링 지표를 수집하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;저장&lt;/code&gt;하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;검색&lt;/code&gt;할 수 있는 시스템이다. 구조가 간단해서 운영이 쉽고, 강력한 쿼리 기능을 가지고 있으며, 그라파나(Grafana) 를 통한 &lt;code class=&quot;highlighter-rouge&quot;&gt;시각화&lt;/code&gt;를 지원한다. 무엇보다 넓은 오픈 소스 생태계를 기반으로 해서, 많은 시스템을 모니터링할 수 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;다양한 플러그인&lt;/code&gt;을 가지고 있는 것이 가장 큰 장점이다. 특히 이런 간편함 때문에 특히나 &lt;code class=&quot;highlighter-rouge&quot;&gt;쿠버네티스&lt;/code&gt;의 메인 모니터링 시스템으로 많이 사용되면서 요즘 특히 더 주목을 받고 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-기본-구조&quot;&gt;1. 기본 구조&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/etc/etc_5_1.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;
&lt;img src=&quot;/img/etc/etc_5_2.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-1-metric-수집&quot;&gt;1-1. Metric 수집&lt;/h4&gt;
&lt;p&gt;수집을 하려는 대상 시스템이 Target system이다. MySQL이나, Tomcat 또는 VM 과 같이 여러가지 자원이 모니터링 대상이 될 수 있다. 이 대상 시스템에서 메트릭을 프로메테우스로 전송하기 위해서는 Exporter 라는 것을 사용한다.&lt;/p&gt;

&lt;h4 id=&quot;1-2-pulling-방식&quot;&gt;1-2. pulling 방식&lt;/h4&gt;
&lt;p&gt;프로메테우스가 Target System에서 메트릭을 수집하는 방식은 &lt;code class=&quot;highlighter-rouge&quot;&gt;풀링&lt;/code&gt; 방식을 사용한다. 프로메테우스가 주기적으로 Exporter로 부터 메트릭 읽어와서 수집하는 방식이다. 보통 모니터링 시스템의 에이전트 들은 에이전트가 모니터링 시스템으로 메트릭을 보내는 푸쉬 방식을 사용한다. 특히 푸쉬 방식은 서비스가 오토 스켈링등으로 가변적일 경우에 유리하다. 풀링 방식의 경우 모니터링 대상이 가변적으로 변경될 경우, 모니터링 대상의 IP 주소들을 알 수 가 없기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;어려운&lt;/code&gt; 점이 있다.&lt;/p&gt;

&lt;p&gt;이러한 문제를 해결하기 위한 방안이 &lt;code class=&quot;highlighter-rouge&quot;&gt;서비스 디스커버리&lt;/code&gt;라는 방식인데, 특정 시스템이 현재 기동중인 서비스들의 목록과 IP 주소를 가지고 있으면 된다. 예를 들어 앞에서 VM들을 내부 DNS에 등록해놓고 새로운 VM이 생성될때에도 DNS에 등록을 하도록 하면, DNS에서 현재 기동중인 VM 목록을 얻어와서 그 목록의 IP들로 풀링을 하면 되는 구조이다.&lt;/p&gt;

&lt;h4 id=&quot;1-3-service-discovery&quot;&gt;1-3. Service Discovery&lt;/h4&gt;
&lt;p&gt;프로메테우스도 서비스 디스커버리 시스템과 통합을 하도록 되어 있다. 앞에서 언급한 &lt;code class=&quot;highlighter-rouge&quot;&gt;DNS&lt;/code&gt;나, 서비스 디스커버리 전용 솔루션인 Hashicorp사의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Consul&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;쿠버네티스&lt;/code&gt;를 통해서, 모니터링해야할 타겟 서비스의 목록을 가지고 올 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;1-4-exporter&quot;&gt;1-4. Exporter&lt;/h4&gt;
&lt;p&gt;Exporter는 &lt;code class=&quot;highlighter-rouge&quot;&gt;모니터링 에이전트&lt;/code&gt;로 타겟 시스템에서 메트릭을 읽어서, 프로메테우스가 풀링을 할 수 있도록 한다. 또한, 단순히 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP GET&lt;/code&gt;으로 메트릭을 &lt;code class=&quot;highlighter-rouge&quot;&gt;텍스트&lt;/code&gt; 형태로 프로메테우스에 리턴한다. 요청 당시의 데이타를 리턴하는 것일뿐, Exporter 자체는 기존값(히스토리)를 저장하는 등의 기능은 없다.&lt;/p&gt;

&lt;h4 id=&quot;1-5-retrieval&quot;&gt;1-5. Retrieval&lt;/h4&gt;
&lt;p&gt;서비스 디스커버리 시스템으로 부터 모니터링 대상 목록을 받아오고, Exporter로 부터 주기적으로 그 대상으로 부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;메트릭을 수집&lt;/code&gt;하는 모듈이 프로메테우스내의 Retrieval 이라는 컴포넌트이다.&lt;/p&gt;

&lt;h4 id=&quot;1-6-저장&quot;&gt;1-6. 저장&lt;/h4&gt;
&lt;p&gt;이렇게 수집된 정보는 프로메테우스 내의 &lt;code class=&quot;highlighter-rouge&quot;&gt;메모리&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;로컬 디스크&lt;/code&gt;에 저장된다. 뒷단에 별도의 데이타 베이스등을 사용하지 않고, 그냥 로컬 디스크에 저장하는데, 그로 인해서 설치가 매우 쉽다는 장점이 있지만 반대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;스케일링이 불가능&lt;/code&gt;하다는 단점을 가지고 있다.  대상 시스템이 늘어날 수록 메트릭 저장 공간이 많이 필요한데, &lt;code class=&quot;highlighter-rouge&quot;&gt;단순히 디스크를 늘리는 방법&lt;/code&gt; 밖에 없다.&lt;/p&gt;

&lt;p&gt;프로메테우스는 구조상 HA를 위한 이중화나 클러스터링등이 &lt;code class=&quot;highlighter-rouge&quot;&gt;불가능&lt;/code&gt;하다. (클러스터링 대신 샤딩을 사용한다. HA는 복제가 아니라 프로메테우스를 두개를 띄워서 같은 타겟을 동시에 같이 저장 하는 방법을 사용한다. 이 문제에 대한 해결 방법은 Thanos 라는 오픈 소스를 사용하면 된다고 한다.)&lt;/p&gt;

&lt;h4 id=&quot;1-7-서빙&quot;&gt;1-7. 서빙&lt;/h4&gt;
&lt;p&gt;이렇게 저장된 메트릭은 &lt;code class=&quot;highlighter-rouge&quot;&gt;PromQL 쿼리&lt;/code&gt; 언어를 이용해서 조회가 가능하고, 이를 외부 API나 프로메테우스 웹콘솔을 이용해서 서빙이 가능하다. 또한 그라파나등과 통합하여 대쉬보드등을 구성하는 것이 가능하다.&lt;/p&gt;

&lt;p&gt;이 외에도 메트릭을 수집하기 위한 gateway, 알람을 위한 Alert manager 등의 컴포넌트등이 존재한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-장단점&quot;&gt;2. 장/단점&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;위의 내용을 기반으로 확장한 프로메테우스의 장/단점은 다음과 같다.&lt;/p&gt;

&lt;h4 id=&quot;2-1-장점&quot;&gt;2-1. 장점&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pull 방식&lt;/code&gt;의 구조를 채택함으로써, 모든 메트릭의 정보를 중앙 서버로 보내지 않아도 됨&lt;br /&gt;
대부분의 모니터링 구조는 push인데, 각 타겟 서버에서 부하가 걸릴 경우 push 방식은 fail point가 될 가능성이 있음&lt;/li&gt;
  &lt;li&gt;Kubernetes 환경에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;설치가 간단&lt;/code&gt;하고, grafana와의 연동을 통한 &lt;code class=&quot;highlighter-rouge&quot;&gt;운영이 쉽다&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;다양한 metric exporter 제공&lt;br /&gt;
Linux, Window등의 OS metric 뿐 아니라 각종 &lt;code class=&quot;highlighter-rouge&quot;&gt;Third-party&lt;/code&gt;의 exporter를 제공&lt;/li&gt;
  &lt;li&gt;장기간 데이터 유지와 확인&lt;br /&gt;
데이터 저장소가 &lt;code class=&quot;highlighter-rouge&quot;&gt;시계열 데이터&lt;/code&gt; 저장소로 구성되어있어, &lt;code class=&quot;highlighter-rouge&quot;&gt;많은&lt;/code&gt; 양의 정보를 &lt;code class=&quot;highlighter-rouge&quot;&gt;빠르게&lt;/code&gt; 검색 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-2-단점&quot;&gt;2-2. 단점&lt;/h4&gt;
&lt;p&gt;프로메테우스는 장점이 확실한 만큼 다음과 같이 단점도 확실하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_5_3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위의 그림처럼, 각 Region에 프로메테우스를 배치 한 뒤, 이를 Master에 Aggregate하는 방식이 프로메테우스가 공식적으로 권장하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;다중화&lt;/code&gt; 방식&lt;br /&gt;
즉 Clustering과는 거리가 &lt;code class=&quot;highlighter-rouge&quot;&gt;멈&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;싱글 호스트 아키텍처이기 때문에 저장용량이 부족하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;디스크 용량을 늘리는 것&lt;/code&gt; 밖에 방법이 없음&lt;/li&gt;
  &lt;li&gt;프로메테우스 서버가 다운되거나, 설정 변경 등을 위해서 재시작을 할 경우 그간의 metric은 &lt;code class=&quot;highlighter-rouge&quot;&gt;유실&lt;/code&gt;됨&lt;/li&gt;
  &lt;li&gt;일정 풀링 주기를 기반으로 metric을 가져오기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;풀링하는 순간&lt;/code&gt;의 스냅샷 정보만 알 수 있음&lt;br /&gt;
스냅샷의 연속된 모음이기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;근사값&lt;/code&gt;의 형태&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-hello-prometheus&quot;&gt;3. Hello Prometheus&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;프로메테우스를 이해하기 위해 간단한 테스트를 https://www.katacoda.com/ 에서 진행하였다.&lt;/p&gt;

&lt;h4 id=&quot;3-1-설정-파일-정의&quot;&gt;3-1. 설정 파일 정의&lt;/h4&gt;
&lt;p&gt;프로메테우스의 설정은 prometheus.yml 파일에 다음과 같이 정의한다.&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;global&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;scrape_interval&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;s&quot;&gt;15s&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;evaluation_interval&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;15s&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;scrape_configs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;job_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;prometheus'&lt;/span&gt;

    &lt;span class=&quot;na&quot;&gt;static_configs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;targets&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;127.0.0.1:9090'&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;127.0.0.1:9100'&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;prometheus'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;scrape_interval&lt;/code&gt;: 타겟시스템으로부터 메트릭을 읽어오는 주기&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;evaluation_interval&lt;/code&gt;: 읽어온 메트릭을 기반으로 alert를 보낼지 말지 판단하는 주기&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;scrap_configs&lt;/code&gt;: 데이터 수집 대상과 방법을 정의&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;job&lt;/code&gt;: 대상 그룹에서 메트릭을 수집해오는 내용을 정의&lt;br /&gt;
위의 경우, 127.0.0.1:9090과 127.0.0.1:9100으로 부터 메트릭을 수집하도록 job이 정의&lt;br /&gt;
앞 부분은 프로메테우스 시스템 자체의 케트릭, 두 번째는 프로메테우스가 기동괴고 있는 VM의 메트릭을 수집하도록 정의&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3-2-프로메테우스-서버와-node-exporter-기동&quot;&gt;3-2. 프로메테우스 서버와 node exporter 기동&lt;/h4&gt;
&lt;p&gt;설정이 끝난 후, 다음의 명령을 통해 간단하게 docker로 기동한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;host &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /root/prometheus.yml:/etc/prometheus/prometheus.yml &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; prometheus-server &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
     prom/prometheus
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로메테우스가 기동되면 다음의 명령으로 docker를 통해 node exporter를 설치해서 기동한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/proc:/host/proc&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/sys:/host/sys&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/:/rootfs&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;--net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;host&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;prometheus &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   quay.io/prometheus/node-exporter:v0.13.0 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;-collector&lt;/span&gt;.procfs /host/proc &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;-collector&lt;/span&gt;.sysfs /host/sys &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;-collector&lt;/span&gt;.filesystem.ignored-mount-points &lt;span class=&quot;s2&quot;&gt;&quot;^/(sys|proc|dev|host|etc)(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$|&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/)&quot;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;node exporter가 제대로 동작하는지 확인하기 위해, 다음의 명령을 통해 메트릭 정보를 얻는다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl https://&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;프로메테우스 서버 IP&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;:9100/metrics
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3-3-프로메테우스-dashboard-접속&quot;&gt;3-3. 프로메테우스 Dashboard 접속&lt;/h4&gt;
&lt;p&gt;프로메테우스와 exporter가 기동이 되었으면, 제대로 메트릭이 수집되는지 확인하기 위해 다음의 주소에 접속하여 대쉬보드를 확인한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;http://{프로메테우스 서버 ip}:9090 &lt;br /&gt;
검색 쿼리 부분에 메트릭 쿼리를 입력하면 그래프등의 형태로 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_5_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;p&gt;본 포스팅은 &lt;a href=&quot;https://bcho.tistory.com/1372?category=731548&quot;&gt;조대협님의 블로그 글&lt;/a&gt;을 참조하여 학습용으로 작성된 글임을 밝힙니다.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="devlog" /><category term="etc" /><summary type="html">들어가기 앞서 프로메테우스는 오픈 소스 기반의 모니터링 시스템이다. ELK 와 같은 로깅이 아니라, 대상 시스템으로 부터 각종 모니터링 지표를 수집하여 저장하고 검색할 수 있는 시스템이다. 구조가 간단해서 운영이 쉽고, 강력한 쿼리 기능을 가지고 있으며, 그라파나(Grafana) 를 통한 시각화를 지원한다. 무엇보다 넓은 오픈 소스 생태계를 기반으로 해서, 많은 시스템을 모니터링할 수 있는 다양한 플러그인을 가지고 있는 것이 가장 큰 장점이다. 특히 이런 간편함 때문에 특히나 쿠버네티스의 메인 모니터링 시스템으로 많이 사용되면서 요즘 특히 더 주목을 받고 있다.</summary></entry><entry><title type="html">[Oauth] Oauth2.0의 4가지 인증 방식</title><link href="https://owin2828.github.io/devlog/2020/03/11/web-4.html" rel="alternate" type="text/html" title="[Oauth] Oauth2.0의 4가지 인증 방식" /><published>2020-03-11T16:30:00+09:00</published><updated>2020-03-11T16:30:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/03/11/web-4</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/03/11/web-4.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;지난 글에서 oauth2.0의 기초 및 구성에 대하여 알아보았다. 
이번 글에서는 실제로 다음과 같은 oauth2.0의 &lt;code class=&quot;highlighter-rouge&quot;&gt;인증 방식&lt;/code&gt;에 대하여 알아볼 예정이다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Authorization Code Grant Type&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Implicit Grant Type&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Resource Owner Password Credentials Grant Type&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Client Credentials Grant Type&lt;/code&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-authorization-code-grant-type&quot;&gt;1. Authorization Code Grant Type&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/web/web_2_1.png&quot; alt=&quot;Authorization Code Grant Type 방식&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;클라이언트는 리소스 주인이 권한 서버에게 Client ID, Redirect URI, Response_type을 code로 지정하여 전달하도록 유도&lt;br /&gt;
  인증이 된다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;code&lt;/code&gt;값을 돌려 받음&lt;/li&gt;
  &lt;li&gt;클라이언트는 전달 받은 &lt;code class=&quot;highlighter-rouge&quot;&gt;code&lt;/code&gt;를 사용해 필요한 정보들과 함께 access token 획득 요청을 권한서버에게 보냄&lt;/li&gt;
  &lt;li&gt;획득한 &lt;code class=&quot;highlighter-rouge&quot;&gt;access token&lt;/code&gt;을 사용해 리소스 서버에 사용자의 데이터를 요청&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-implicit-grant&quot;&gt;2. Implicit Grant&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/web/web_2_2.png&quot; alt=&quot;Implicit Grant 방식&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;클라이언트는 리소스 주인이 권한 서버에게 Client ID, Redirect URI, Response_type을 code로 지정하여 전달하도록 유도&lt;br /&gt;
  인증이 된다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;token&lt;/code&gt;을 돌려 받음&lt;/li&gt;
  &lt;li&gt;획득한 access token이 유요한지 &lt;code class=&quot;highlighter-rouge&quot;&gt;검증&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;검증에 대한 응답을 돌려줌&lt;/li&gt;
  &lt;li&gt;획득한 &lt;code class=&quot;highlighter-rouge&quot;&gt;access token&lt;/code&gt;을 사용해 리소스 서버에 사용자의 데이터를 요청&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-resource-owner-password-credentials-grant&quot;&gt;3. Resource Owner Password Credentials Grant&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/web/web_2_3.png&quot; alt=&quot;Resource Owner Password Credentials Grant 방식&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;리소스 주인이 인증을 진행, 대부분 ID/PW로 &lt;code class=&quot;highlighter-rouge&quot;&gt;자격증명&lt;/code&gt;을 수행&lt;/li&gt;
  &lt;li&gt;클라이언트는 전달 받은 정보를 기반으로 권한 서버에 &lt;code class=&quot;highlighter-rouge&quot;&gt;access token&lt;/code&gt; 획득 요청&lt;/li&gt;
  &lt;li&gt;Access token을 돌려줌&lt;/li&gt;
  &lt;li&gt;획득한 &lt;code class=&quot;highlighter-rouge&quot;&gt;access token&lt;/code&gt;을 사용해 리소스 서버에 사용자의 데이터를 요청&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-client-credentials-grant-type-방식&quot;&gt;4. Client Credentials Grant Type 방식&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/web/web_2_4.png&quot; alt=&quot;Client Credentials Grant Type 방식&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;리소스 주인이 access token 정보를 &lt;code class=&quot;highlighter-rouge&quot;&gt;직접&lt;/code&gt; 권한 서버에 요청&lt;/li&gt;
  &lt;li&gt;Access token을 돌려줌&lt;/li&gt;
  &lt;li&gt;획득한 &lt;code class=&quot;highlighter-rouge&quot;&gt;access token&lt;/code&gt;을 사용해 리소스 서버에 사용자의 데이터를 요청
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;p&gt;Oauth2.0의 인증 방식에 대하여 간략하게 알아보았다. 다음 포스팅에서는 각 방식을 직접 구현할 예정이다.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="devlog" /><category term="web" /><summary type="html">들어가기 앞서 지난 글에서 oauth2.0의 기초 및 구성에 대하여 알아보았다. 이번 글에서는 실제로 다음과 같은 oauth2.0의 인증 방식에 대하여 알아볼 예정이다. Authorization Code Grant Type Implicit Grant Type Resource Owner Password Credentials Grant Type Client Credentials Grant Type</summary></entry><entry><title type="html">[Mac]백 쿼트(`) 입력하는 법</title><link href="https://owin2828.github.io/devlog/2020/03/11/etc-4.html" rel="alternate" type="text/html" title="[Mac]백 쿼트(`) 입력하는 법" /><published>2020-03-11T15:09:00+09:00</published><updated>2020-03-11T15:09:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/03/11/etc-4</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/03/11/etc-4.html">&lt;h2 id=&quot;-입력하기&quot;&gt;(`) 입력하기&lt;/h2&gt;
&lt;p&gt;맥을 사용하다보면, 한글을 타이핑하다가 (`)버튼을 누르면 원하는 grave는 나오지 않고 (₩)가 나오는 것을 볼 수 있다. 
Markdown 문서나 개발자들에게는 여러모로 불편한 일인데, 다음과 같은 해결법을 공유한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;기본-키-설정-파일-생성&quot;&gt;기본 키 설정 파일 생성&lt;/h4&gt;
&lt;p&gt;다음의 내용을 터미널에서 입력한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Keybindings 디렉토리 생성&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/Library
&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;KeyBindings

&lt;span class=&quot;c&quot;&gt;# DefaultkeyBinding.dict 파일 생성&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;KeyBindings
&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;DefaultkeyBinding.dict
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;설정-파일-변경&quot;&gt;설정 파일 변경&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultkeyBinding.dict&lt;/code&gt; 파일에 다음과 같은 내용을 추가한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;₩&quot; = (&quot;insertText:&quot;, &quot;`&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;맥을 &lt;code class=&quot;highlighter-rouge&quot;&gt;재부팅&lt;/code&gt;하자 변경사항이 적용될 것이다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>owin2828</name></author><category term="devlog" /><category term="etc" /><summary type="html">(`) 입력하기 맥을 사용하다보면, 한글을 타이핑하다가 (`)버튼을 누르면 원하는 grave는 나오지 않고 (₩)가 나오는 것을 볼 수 있다. Markdown 문서나 개발자들에게는 여러모로 불편한 일인데, 다음과 같은 해결법을 공유한다.</summary></entry><entry><title type="html">[Oauth] Oauth2.0의 등장배경, 역할 및 기본 정보</title><link href="https://owin2828.github.io/devlog/2020/03/11/web-3.html" rel="alternate" type="text/html" title="[Oauth] Oauth2.0의 등장배경, 역할 및 기본 정보" /><published>2020-03-11T14:54:00+09:00</published><updated>2020-03-11T14:54:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/03/11/web-3</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/03/11/web-3.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Oauth2.0&lt;/code&gt;의 기초에 대해 알아보고자 한다. 
많은 자료가 있지만, 정확한 이해를 위해 oauth2.0의 &lt;code class=&quot;highlighter-rouge&quot;&gt;개념&lt;/code&gt;부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;구현&lt;/code&gt;까지 직접하며 글을 남기고자 한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;자세한 개념 설명은 다음과 같은 더 좋은 글들을 찾아보기 바란다.&lt;br /&gt;
  &lt;a href=&quot;https://opentutorials.org/course/3405&quot;&gt;생활코딩 oauth2.0&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-인증-vs-인가&quot;&gt;1. 인증 vs 인가&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;본격적으로 oauth2.0를 살펴보기 전에 다음과 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;용어&lt;/code&gt;의 의미를 짚고 가자.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;인증&lt;/code&gt;(Authentication)&lt;br /&gt;
인증이란, &lt;code class=&quot;highlighter-rouge&quot;&gt;신원을 확인&lt;/code&gt; 하는 행위이다.&lt;br /&gt;
즉, 어떠한 주권을 행사할 자격이 있는지를 검증하는 단계이다.&lt;br /&gt;
그렇기 때문에 인증을 한다고 해서, 주체에게 새로운 권한이 부여되지는 않는다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;인가&lt;/code&gt;(Authorization)&lt;br /&gt;
인가란 &lt;code class=&quot;highlighter-rouge&quot;&gt;승인&lt;/code&gt;이라고도 불리는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;권한을 부여&lt;/code&gt;하는 행위이다.&lt;br /&gt;
즉, 인가를 받은 대상이 새로운 자격을 얻게 되어 제한된 리소스에 접근이 가능하다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-oauth20의-등장배경&quot;&gt;2. Oauth2.0의 등장배경&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;권한이 각 사용자에게 부여되는 경우에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;반드시&lt;/code&gt; 권한 소유자에 대한 인증절차를 거치게 된다. 
웹에서 이러한 가장 보편적인 방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;ID/PW&lt;/code&gt; 방식으로 로그인하는 것이다. 
사용자가 입력한 정보를 서버에 전송하여 인증이 성공할 경우, &lt;code class=&quot;highlighter-rouge&quot;&gt;쿠키&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;세션&lt;/code&gt; 값을 저장함으로써 권한이 부여된다. 
이런 방식은 한 번의 로그인으로 세션이 종료되기 전까지 제한된 기능을 수행할 수 있어, &lt;code class=&quot;highlighter-rouge&quot;&gt;간편&lt;/code&gt;하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;효율적&lt;/code&gt;인 방식으로 널리 사용된다. 
하지만 이러한 쿠키 기반 권한 부여는 다음과 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;단점&lt;/code&gt;을 지닌다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서버에 요청이 올때마다 DB를 통해 현재 상태를 매번 확인하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;낭비&lt;/code&gt;가 발생한다.&lt;/li&gt;
  &lt;li&gt;모바일 앱에 적합하지 &lt;code class=&quot;highlighter-rouge&quot;&gt;않다&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;서로 다른 서비스 간에 정보를 공유하기 &lt;code class=&quot;highlighter-rouge&quot;&gt;어렵다&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 단점을 해결하기 위해 IETF는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Oauth&lt;/code&gt;라는 프레임워크를 만들게 된다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;oauth1과 oauth2는 완전히 &lt;code class=&quot;highlighter-rouge&quot;&gt;다른&lt;/code&gt; 프로토콜이며, 호환되지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-oauth20의-4가지-역할&quot;&gt;3. Oauth2.0의 4가지 역할&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Oauth2.0의 시나리오에는 다음과 같은 4가지 역할이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/web/web_1_1.jpg&quot; alt=&quot;Oauth2 역할, 출처: http://tutorials.jenkov.com/oauth2/roles.html&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Resource Owner&lt;/code&gt;&lt;br /&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;사용자&lt;/code&gt;로서 자신의 리소스에 대한 접근 권한을 가지고 있는 주체이다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Client&lt;/code&gt;&lt;br /&gt;
  사용자가 &lt;code class=&quot;highlighter-rouge&quot;&gt;접근하는 서비스&lt;/code&gt;로서 사용자의 데이터에 대한 요청을 보내는 주체이다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Resource Server&lt;/code&gt;&lt;br /&gt;
  사용자의 &lt;code class=&quot;highlighter-rouge&quot;&gt;데이터를 보유&lt;/code&gt;한 기관으로서 유효한 권한을 부여받은 client가 요청할 경우 제공한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Authorization Server&lt;/code&gt; &lt;br /&gt;
  사용자의 데이터에 접근할 &lt;code class=&quot;highlighter-rouge&quot;&gt;권한을 제공&lt;/code&gt;하는 서버이다. client의 요청에 따라 사용자에게 &lt;code class=&quot;highlighter-rouge&quot;&gt;정보제공 동의&lt;/code&gt;를 받은 후, 권한을 부여한다.
    &lt;blockquote&gt;
      &lt;p&gt;규모가 작을 경우, Resource Server와 Authorization Server를 하나의 서버로 구현하기도 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-oauth20의-기본-정보&quot;&gt;4. Oauth2.0의 기본 정보&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Oauth2.0에는 다음과 같은 세 가지의 기본 정보가 존재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;등록정보&lt;/code&gt;&lt;br /&gt;
  서비스를 제공하는 Client는 사전에 Authorization Server에 &lt;code class=&quot;highlighter-rouge&quot;&gt;등록&lt;/code&gt;해야한다. 
  새로운 서비스가 출시될 때마다 정보를 갱신하여 제출한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Redirect URI&lt;/code&gt;&lt;br /&gt;
  Authorization Server는 사용자가 &lt;code class=&quot;highlighter-rouge&quot;&gt;정보제공 동의&lt;/code&gt;를 하게되면 사용자를 등록된 &lt;code class=&quot;highlighter-rouge&quot;&gt;Redirect URI&lt;/code&gt;로 이동시킨다. 
  만약 등록되지 않은 Redirect URI를 담은 요청이 들어오면 &lt;code class=&quot;highlighter-rouge&quot;&gt;무효&lt;/code&gt; 처리한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Client ID&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;Client Secret&lt;/code&gt;&lt;br /&gt;
  새로 등록하는 Client는 Authorization Server로 부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;Client ID&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Client Secret&lt;/code&gt;을 발급받는다. 
  Client ID는 노출되어도 상관 없지만, Client Secret는 &lt;code class=&quot;highlighter-rouge&quot;&gt;절대&lt;/code&gt; 노출되어서는 안된다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;p&gt;Oauth2.0에 대하여 간략하게 알아보았다. 다음 포스팅에서는 oauth2.0의 &lt;code class=&quot;highlighter-rouge&quot;&gt;4가지 인증 방식&lt;/code&gt;에 대하여 알아볼 예정이다.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="devlog" /><category term="web" /><summary type="html">들어가기 앞서 Oauth2.0의 기초에 대해 알아보고자 한다. 많은 자료가 있지만, 정확한 이해를 위해 oauth2.0의 개념부터 구현까지 직접하며 글을 남기고자 한다. 자세한 개념 설명은 다음과 같은 더 좋은 글들을 찾아보기 바란다. 생활코딩 oauth2.0</summary></entry><entry><title type="html">[AWS] IAM</title><link href="https://owin2828.github.io/devlog/2020/01/29/aws-7.html" rel="alternate" type="text/html" title="[AWS] IAM" /><published>2020-01-29T09:51:00+09:00</published><updated>2020-01-29T09:51:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/29/aws-7</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/29/aws-7.html">&lt;h2 id=&quot;id0&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;본 포스팅에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;IAM&lt;/code&gt;에 대해 살펴보고, 접근 제어 및 권한 설정을 하는 방법에 대해 알아볼 예정이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;id1&quot;&gt;1. IAM이란?&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IAM&lt;/code&gt;은 Identity and Access Management의 약자로, AWS 리소스에 대한 접근을 안전하게 제어할 수 있는 웹 서비스이다.&lt;br /&gt;
이 설정을 통해 리소스를 사용하도록 인증하거나, 권한을 부여할 수 있다.&lt;/p&gt;

&lt;p&gt;처음 AWS 계정을 생성하게 되면, 해당 계정에 모든 리소스에 접근할 수 있는 권한이 부여된 &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; 계정이 생성된다.&lt;br /&gt;
이러한 사용자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;root 사용자&lt;/code&gt;라고 부르며, 로그인할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;Email&lt;/code&gt;을 입력하여 로그인하게 된다.&lt;br /&gt;
이에 AWS는 일상작업뿐 아니라 관리작업에도 이 루트사용자를 사용하는 것을 &lt;code class=&quot;highlighter-rouge&quot;&gt;비권장&lt;/code&gt;한다.&lt;br /&gt;
대신 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/best-practices.html&quot;&gt;이곳&lt;/a&gt;과 같은 방법으로 IAM 사용자를 생성할 때만 사용하도록 권장한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;즉 루트 사용자는 계정 및 서비스 관기 작업에만 사용하기를 권장한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;id2&quot;&gt;2. IAM의 기능&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;IAM은 다양한 기능을 제공하지만, 주로 사용하게 될 기능은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AWS 계정에 대한 공유 접근제어&lt;/li&gt;
  &lt;li&gt;권한을 세분화하여 부여&lt;/li&gt;
  &lt;li&gt;MFA(멀티 팩터 인증)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;더 구체적인 사항은 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/introduction.html&quot;&gt;AWS 공식 홈페이지&lt;/a&gt;를 참고하기 바란다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;id3&quot;&gt;3. IAM 유저 생성&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;콘솔에 로그인하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;내 보안자격 증명&lt;/code&gt;을 눌러준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위와 같은 팝업창이 뜨게 되는데 여기서 빨간 사각형의 버튼을 클릭한다.
    &lt;blockquote&gt;
      &lt;p&gt;혹은 서비스에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;IAM&lt;/code&gt;을 검색하여 들어가도 된다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;사용자 추가&lt;/code&gt; 버튼을 눌러 새로운 IAM 사용자를 추가해준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생성할 사용자의 이름을 입력한다.&lt;/li&gt;
  &lt;li&gt;액세스 유형은 &lt;code class=&quot;highlighter-rouge&quot;&gt;콘솔&lt;/code&gt;로 설정한다. (추후, 키를 발급받을 수 있다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;권한 설정에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;그룹 생성&lt;/code&gt;을 클릭한다.&lt;br /&gt;
그룹에 권한을 설정하고 유저를 추가하면, 관리가 &lt;code class=&quot;highlighter-rouge&quot;&gt;편리&lt;/code&gt;하다.
    &lt;blockquote&gt;
      &lt;p&gt;만약 특정 유저에게서 권한을 제거하고 싶다면, 그룹에서 사용자를 제거하면 된다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;그룹 이름을 지정후, &lt;code class=&quot;highlighter-rouge&quot;&gt;AdministratorAccess&lt;/code&gt;를 체크하여 관리자 권한을 해당 그룹에 부여한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;그룹 생성&lt;/code&gt;을 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위와 같이 성공적으로 추가되었음을 확인할 수 있고, 다음 단계로 넘어간다.
    &lt;blockquote&gt;
      &lt;p&gt;다음 단계는 &lt;code class=&quot;highlighter-rouge&quot;&gt;태그&lt;/code&gt;이지만, 딱히 추가할 태그가 없으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;검토&lt;/code&gt;로 가도록 한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생성한 정보를 확인 후, &lt;code class=&quot;highlighter-rouge&quot;&gt;사용자 만들기&lt;/code&gt;를 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용자들이 접속할 &lt;code class=&quot;highlighter-rouge&quot;&gt;콘솔 주소&lt;/code&gt;가 표시되며, 해당 주소를 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;IAM 유저&lt;/code&gt;로 로그인이 가능하다.&lt;/li&gt;
  &lt;li&gt;사용자의 액세스 키(액세스 키 ID &amp;amp; 보안 액세스 키)를 확인하려면, &lt;code class=&quot;highlighter-rouge&quot;&gt;표시&lt;/code&gt; 버튼을 눌러 확인한다.&lt;/li&gt;
  &lt;li&gt;액세스 키를 저장하려면, &lt;code class=&quot;highlighter-rouge&quot;&gt;.csv 다운로드&lt;/code&gt; 버튼을 클릭한 후 안전한 위치에 저장한다.
    &lt;blockquote&gt;
      &lt;p&gt;보안 액세스 키는 이 단계에서만 확인 및 다운로드가 가능하다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;다시는&lt;/code&gt; 확인하거나 다운로드 할 수 없으므로 주의하자.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IAM 유저&lt;/code&gt;가 생성됨을 확인할 수 있다.&lt;br /&gt;
앞으로는 IAM유저로 로그인하여 네트워크를 구성하면 된다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;id4&quot;&gt;4. 루트계정 MFA 활성화&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;AWS에서 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;MFA&lt;/code&gt;는 보안을 강화하는 수단이다. AWS계정 및 개별 IAM 사용자들에 대해 AWS MFA를 활성화할 수 있다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;루트계정&lt;/code&gt;에는 MFA를 활성화하는것이 권장되며, 현재는 토큰 기반의 가상 MfA 어플리케이션만 존재한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;2019.02.01 이후로 SMS 문자 메세지 기반 방식은 더이상 지원되지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;좌측메뉴의 &lt;code class=&quot;highlighter-rouge&quot;&gt;대시보드&lt;/code&gt;를 누른 후, 사진처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;MFA 관리&lt;/code&gt; 버튼을 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MFA 활성화&lt;/code&gt; 버튼을 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_13.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;가상 MFA 디바이스&lt;/code&gt;를 체크하고 계속을 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_14.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QR 코드 표시&lt;/code&gt;를 클릭하여 나오는 QR 코드를 &lt;code class=&quot;highlighter-rouge&quot;&gt;Google OTP&lt;/code&gt;를 설치하여 스캔하면 MFA 코드가 생성된다.&lt;/li&gt;
  &lt;li&gt;생성된 2개의 &lt;code class=&quot;highlighter-rouge&quot;&gt;MFA 코드&lt;/code&gt;를 입력하여 할당을 누른다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_15.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;성공적으로 할당시, 사진과 같이 성공했다는 표시가 되며, 루트계정 로그인은 &lt;code class=&quot;highlighter-rouge&quot;&gt;MFA&lt;/code&gt; 인증을 해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;루트 계정으로 로그인할 시 &lt;code class=&quot;highlighter-rouge&quot;&gt;MFA&lt;/code&gt; 코드를 입력하는 화면이 뜨게되며,  &lt;code class=&quot;highlighter-rouge&quot;&gt;Google OTP&lt;/code&gt;에서 코드를 입력하면 로그인할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;id5&quot;&gt;5. IAM 역할 부여&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;IAM에서 제공하는 기능중 &lt;code class=&quot;highlighter-rouge&quot;&gt;역할&lt;/code&gt;을 사용하면 특정 인스턴스에 제약을 걸 수 있다.&lt;br /&gt;
이어지는 실습에서는 특정 EC2에게 S3버킷에 대한 접근 제어 역할을 부여하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;좌측 메뉴에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;역할&lt;/code&gt;을 클릭 후, &lt;code class=&quot;highlighter-rouge&quot;&gt;역할 만들기&lt;/code&gt;를 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;우리는 특정 &lt;code class=&quot;highlighter-rouge&quot;&gt;EC2&lt;/code&gt;에게 역할을 부여할 것이므로, 사진처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;EC2&lt;/code&gt;를 클릭 후 다음을 누른다.
    &lt;blockquote&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;다른 AWS 계정&lt;/code&gt;을 눌러 특정 계정에게 역할을 부여할 수도 있다.&lt;br /&gt;
이런 경우, 계정 ID는 이메일 형식의 로그인ID가 아니라, 내 정보에서 볼 수 있는 12자리 숫자 ID이다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;특정 EC2에게 &lt;code class=&quot;highlighter-rouge&quot;&gt;S3&lt;/code&gt;버킷에 접근할 역할을 부여할 것이므로, &lt;code class=&quot;highlighter-rouge&quot;&gt;amazons3fullaccess&lt;/code&gt;를 검색 후 체크하여 다음을 클릭한다.
    &lt;blockquote&gt;
      &lt;p&gt;이어지는 태그는 건너뛰고 &lt;code class=&quot;highlighter-rouge&quot;&gt;검토&lt;/code&gt;를 클릭한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;역할의 이름을 지정하고 방금 지정한 정책이 맞는지 확인 후, 만들기를 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생성한 역할이 지정한 이름과 할당한 서비스를 표시함을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_22.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EC2를 생성할 때, 우리가 지정한 역할을 부여할 수 있음을 알 수 있다.&lt;br /&gt;
이렇게 생성된 EC2 인스턴스는 S3외의 다른 서비스의 접근은 &lt;code class=&quot;highlighter-rouge&quot;&gt;불가능&lt;/code&gt;해진다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;id6&quot;&gt;6. 끝마치며&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;공부하며, 내용을 정리하다 보니 문득 &lt;code class=&quot;highlighter-rouge&quot;&gt;정책&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;역할&lt;/code&gt;의 차이가 모호해져 찾아보게 되었다.&lt;br /&gt;
내가 이해한 바로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;정책&lt;/code&gt;은 어떤 일을 할 수 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;권한&lt;/code&gt;과 관련이 있고,&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;역할&lt;/code&gt;은 그러한 &lt;code class=&quot;highlighter-rouge&quot;&gt;권한&lt;/code&gt;들의 논리적인 &lt;code class=&quot;highlighter-rouge&quot;&gt;집합&lt;/code&gt;이라는 것이다.&lt;br /&gt;
자세한 내용은 다음의 두 링크를 참조하자.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/id_roles_compare-resource-policies.html&quot;&gt;AWS 홈페이지&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://musma.github.io/2019/11/05/about-aws-iam-policy.html&quot;&gt;이현수님 포스팅&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IAM&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;EC2&lt;/code&gt; 이 3가지는 굉장히 중요하다고 한다.&lt;br /&gt;
꼭 잘 설정하여 좋은 환경을 구축하기를 바란다.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="devlog" /><category term="aws" /><summary type="html">들어가기 앞서 본 포스팅에서는 IAM에 대해 살펴보고, 접근 제어 및 권한 설정을 하는 방법에 대해 알아볼 예정이다.</summary></entry></feed>