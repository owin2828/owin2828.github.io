<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://owin2828.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://owin2828.github.io/" rel="alternate" type="text/html" /><updated>2020-01-16T09:12:16+09:00</updated><id>https://owin2828.github.io/feed.xml</id><title type="html">낮코밤코</title><subtitle>Already done, cause will do</subtitle><author><name>owin2828</name></author><entry><title type="html">[AWS] VPC 만들어보기(실습)</title><link href="https://owin2828.github.io/devlog/2020/01/15/aws-3.html" rel="alternate" type="text/html" title="[AWS] VPC 만들어보기(실습)" /><published>2020-01-15T09:31:00+09:00</published><updated>2020-01-15T09:31:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/15/aws-3</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/15/aws-3.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;이번 포스팅은 aws에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;를 구축해보는 &lt;code class=&quot;highlighter-rouge&quot;&gt;실습(?)&lt;/code&gt;에 관련된 포스팅이다.&lt;br /&gt;
깊게 들어가지는 않고 간단하게 VPC를 구성하는 방법을 써 볼 예정이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;앞으로 이어질 모든 실습 내용에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;이름&lt;/code&gt; 만큼은 &lt;code class=&quot;highlighter-rouge&quot;&gt;직관적&lt;/code&gt;이고 &lt;code class=&quot;highlighter-rouge&quot;&gt;확실&lt;/code&gt;하게 지어주자&lt;br /&gt;
이름만 보고도, 해당 객체가 어떤 일을 수행하는지 알 수 있어야 실수를 방지한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;진행되는 모든 &lt;code class=&quot;highlighter-rouge&quot;&gt;Naming Rule&lt;/code&gt;은 다음을 따른다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Object 이름&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;Region-code&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;AZ-code&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;서비스 약칭(dev, stg, prod)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;본 예제에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Single AZ&lt;/code&gt;만을 사용하므로, 중간 AZ-code가 &lt;code class=&quot;highlighter-rouge&quot;&gt;생략&lt;/code&gt;될 예정이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;마지막으로, 모든 사진은 클릭 시, &lt;code class=&quot;highlighter-rouge&quot;&gt;확대&lt;/code&gt;기능을 제공한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-aws-계정-생성&quot;&gt;1. AWS 계정 생성&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;다음의 링크로 접속하여 aws 홈페이지에 들어가보자.&lt;br /&gt;
&lt;a href=&quot;https://aws.amazon.com/ko/&quot;&gt;https://aws.amazon.com/ko/&lt;/a&gt;&lt;br /&gt;
우측 상단에 aws 계정생성 버튼을 눌러 가입을 진행하면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;가입할 때, 신용카드 정보를 입력을 하게 되는데 갑자기 &lt;code class=&quot;highlighter-rouge&quot;&gt;결제&lt;/code&gt;가 되었다고 놀라지 말자.&lt;br /&gt;
aws에서 결제가능한 카드인지 확인하기 위해 1$ 정도를 결제했다가 &lt;code class=&quot;highlighter-rouge&quot;&gt;취소&lt;/code&gt;하는 것이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-콘솔-로그인&quot;&gt;2. 콘솔 로그인&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_1.png&quot; alt=&quot;&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;우측 상단의 &lt;code class=&quot;highlighter-rouge&quot;&gt;AWS Management Console&lt;/code&gt;을 클릭하여 로그인을 진행하자.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_2.png&quot; alt=&quot;&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;지역은 &lt;code class=&quot;highlighter-rouge&quot;&gt;서울&lt;/code&gt;로 선택한다. &lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-vpc-생성&quot;&gt;3. VPC 생성&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_3.png&quot; alt=&quot;&quot; width=&quot;80%&quot; height=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서비스에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;를 검색후 클릭한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_4.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로그인에 성공하면 AWS Management Console 화면이 나타나고, &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;를 검색하여 클릭한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_5.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;기본 VPC&lt;/code&gt;가 1개 있음을 볼 수 있고, 해당 VCP에 관한 정보가 하단에 공개된다.&lt;br /&gt;
이제 좌측 상단의 VPC 생성을 클릭하여 새로운 VPC를 만든다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_6.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;VPC를 생성할 때는, 앞서 설명한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Naming Rule&lt;/code&gt;을 따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;vpc-apne2-dev-test&lt;/code&gt;로 작성한다.&lt;br /&gt;
CIDR블록은 특별한 경우가 아니면, 가이드대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;10.0.0.0/16&lt;/code&gt;으로 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2016년 6월 1일부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;App Store&lt;/code&gt;에 배포되는 모든 앱은 &lt;code class=&quot;highlighter-rouge&quot;&gt;IPv6&lt;/code&gt; 네트워크를 지원해야 한다. &lt;br /&gt;
IPv6가 지원이 안 될 경우 배포가 안된다고 하니, 필요시 체크를 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_7.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;방금 우리가 작성한 이름을 가진 이름으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;가 하나 생성되었음을 확인 할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_8.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;마지막으로 방금 생성한 VPC를 &lt;code class=&quot;highlighter-rouge&quot;&gt;우클릭&lt;/code&gt; 후, 사진처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;DNS 호스트 이름 편집&lt;/code&gt;을 눌러준다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_9.png&quot; alt=&quot;&quot; width=&quot;70%&quot; height=&quot;70%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기본 값은 비활성화지만, DNS 호스트 이름을 &lt;code class=&quot;highlighter-rouge&quot;&gt;활성화&lt;/code&gt;하여 이름을 주도록 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기까지 진행 함으로써, 기본적인 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;구성은 완료되었다.&lt;br /&gt;
다음으로 구성된 VPC에 대해 기본요소들을 살펴보자.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-기본구성-살펴보기&quot;&gt;4. 기본구성 살펴보기&lt;/h2&gt;
&lt;hr /&gt;

&lt;h4 id=&quot;4-1-서브넷&quot;&gt;4-1. 서브넷&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_10.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;좌측에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;서브넷&lt;/code&gt;을 클릭하면, 사진처럼 기본적으로 구성되어있는 총 3개의 서브넷이 확인 가능하다.&lt;br /&gt;
이때 각 서브넷은 서울 지역에 존재하는 AZ3개(a,b,c)에 하나씩 꾸려진 모습이다.
    &lt;blockquote&gt;
      &lt;p&gt;이 서브넷은 우리가 구성한 VPC가 아니라 &lt;code class=&quot;highlighter-rouge&quot;&gt;기본 VPC&lt;/code&gt;에 존재하는 것으로 수정하지 말자.&lt;br /&gt;
아직 우리는 어떠한 서브넷도 생성하지 않았다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4-2-라우팅-테이블&quot;&gt;4-2. 라우팅 테이블&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_11.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;다음으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;라우팅 테이블&lt;/code&gt;을 클릭하면,&lt;br /&gt;
사진에서 보이는 바와 같이 방금 생성한 VPC에 할당된 라우팅 테이블이 &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt;되었음을 알 수 있다.&lt;br /&gt;
(사진속 빨간 사각형 안에 우리가 정한 이름으로된 VPC에 할당되어있다.)&lt;br /&gt;
앞으로는 이 VPC의 라우팅 테이블에 규칙을 추가하며 각종 &lt;code class=&quot;highlighter-rouge&quot;&gt;네트워크 규칙&lt;/code&gt;을 설정할 것이다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4-3-인터넷-게이트웨이&quot;&gt;4-3. 인터넷 게이트웨이&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_12.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;인터넷 게이트웨이&lt;/code&gt; 또한 아직 생성된 것이 없어 기본 VPC에 부착된것만 보인다.&lt;br /&gt;
인터넷 게이트웨이는 기본적으로 VPC 내부 요소들이 &lt;code class=&quot;highlighter-rouge&quot;&gt;외부&lt;/code&gt;와 통신하는 징검다리 역할을 한다.
    &lt;blockquote&gt;
      &lt;p&gt;이 인터넷 게이트웨이를 생성하여 우리가 생성한 VPC에 붙여줘야 비로소 &lt;code class=&quot;highlighter-rouge&quot;&gt;통신&lt;/code&gt;이 가능해지는 것이다.&lt;br /&gt;
다음 글에서는 이러한 게이트웨이 생성 및 설정법을 다룰 것이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4-4-acl&quot;&gt;4-4. ACL&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_13.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACL&lt;/code&gt;을 눌러보면 사진처럼 우리가 생성한 VPC에 할당된 ACL을 확인할 수 있다.
    &lt;blockquote&gt;
      &lt;p&gt;아직은 어떠한 서브넷을 생성하지 않아, 연결된 서브넷이 &lt;code class=&quot;highlighter-rouge&quot;&gt;없음&lt;/code&gt;이 확인된다.&lt;br /&gt;
주로 ACL의 설정은 건드리지 않으며, 더 세밀한 설정이 되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;보안그룹&lt;/code&gt;의 설정을 변경한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4-5-보안그룹&quot;&gt;4-5. 보안그룹&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_3_14.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;보안그룹&lt;/code&gt;을 확인해보면, 사진의 빨간 사각형 부분에 방금 만든 VPC ID로 설정되었음이 확인된다.
    &lt;blockquote&gt;
      &lt;p&gt;이 보안그룹의 &lt;code class=&quot;highlighter-rouge&quot;&gt;인바운드&lt;/code&gt; 설정을 변경하여 앞으로 진행할 것이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;여태 진행한 과정을 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;를 하나 설정하고 기본요소들에 대하여 살펴보았다.&lt;br /&gt;
이는 서울 Region 내에 나만의 &lt;code class=&quot;highlighter-rouge&quot;&gt;IDC&lt;/code&gt;가 하나 생긴것과 마찬가지이다.&lt;/p&gt;

&lt;p&gt;다음 포스팅에서는 각 기본요소들을 &lt;code class=&quot;highlighter-rouge&quot;&gt;설정&lt;/code&gt;하는 방법 및 서브넷 &amp;amp; 인스턴스 &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt;과&lt;br /&gt;
실제로 우리가 생성한 서브넷의 인스턴스에 접속하는 방법을 설명하겠다.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="aws" /><summary type="html">들어가기 앞서 이번 포스팅은 aws에서 VPC를 구축해보는 실습(?)에 관련된 포스팅이다. 깊게 들어가지는 않고 간단하게 VPC를 구성하는 방법을 써 볼 예정이다.</summary></entry><entry><title type="html">[AWS] 서브넷, 인스턴스, 인터넷 게이트웨이(실습)</title><link href="https://owin2828.github.io/devlog/2020/01/15/aws-4.html" rel="alternate" type="text/html" title="[AWS] 서브넷, 인스턴스, 인터넷 게이트웨이(실습)" /><published>2020-01-15T09:31:00+09:00</published><updated>2020-01-15T09:31:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/15/aws-4</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/15/aws-4.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;이전 포스팅에 이어서 AWS에서 VPC를 구성 후,&lt;br /&gt;
다음의 구성 요소들을 &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt;하거나 &lt;code class=&quot;highlighter-rouge&quot;&gt;설정&lt;/code&gt;하는 방법에 대해 포스팅할 예정이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Internet Gateway&lt;/li&gt;
  &lt;li&gt;Subnet&lt;/li&gt;
  &lt;li&gt;ACL&lt;/li&gt;
  &lt;li&gt;Security Group&lt;/li&gt;
  &lt;li&gt;Routing Table&lt;/li&gt;
  &lt;li&gt;EC2&lt;/li&gt;
  &lt;li&gt;S3(VPC 내부 구성은 아님)&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-인터넷-게이트웨이-생성-및-설정&quot;&gt;1. 인터넷 게이트웨이 생성 및 설정&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_1.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;좌측의 인터넷 게이트웨이 생성 버튼을 눌러&lt;br /&gt;
기본 인터넷 게이트 웨이는 두고 &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt;을 진행한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_2.png&quot; alt=&quot;&quot; width=&quot;80%&quot; height=&quot;80%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생성하는 인터넷 게이트웨이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Naming Rule&lt;/code&gt;을 따라 사진처럼 명명한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_3.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;성공적으로 생성하게되면, 사진처럼 우리가 지정한 ID의 정보를 보여주며 상태는 &lt;code class=&quot;highlighter-rouge&quot;&gt;detached&lt;/code&gt;가 된다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_19.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이때, 마우스 우클릭을 하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;VCP에 연결&lt;/code&gt;을 누른다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_20.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;우리가 생성한 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;를 클릭한 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;연결&lt;/code&gt;을 누른다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_21.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;다시 상태를 확인해 보면, &lt;code class=&quot;highlighter-rouge&quot;&gt;attached&lt;/code&gt;로 변경되었음을 확인할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-서브넷-생성-및-설정&quot;&gt;2. 서브넷 생성 및 설정&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_4.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;마찬가지 방법으로 서브넷을 클릭 후,&lt;br /&gt;
기본 VPC에 할당된 3개의 서브넷은 그대로 두고 &lt;code class=&quot;highlighter-rouge&quot;&gt;서브넷 생성&lt;/code&gt;을 눌러준다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_5.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;이름은 규칙에 따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;subnet-apne2-dev-ssh&lt;/code&gt;라 입력한다.&lt;br /&gt;
추후, 이 서브넷은 ssh로 접속하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;bastion&lt;/code&gt;으로 사용할 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;VPC는 드롭박스를 클릭하면 사진처럼 뜨게 되는데,&lt;br /&gt;
그 중 전 포스팅에서 만든 VPC를 클릭해 주면된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CIDR 블록은 VPC CIDR 블록 &lt;code class=&quot;highlighter-rouge&quot;&gt;범위 내&lt;/code&gt;에서 생성하면 된다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;: 10.0.0.0/16&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;서브넷&lt;/code&gt;: 10.0.1.0./24&lt;br /&gt;
같은 방식으로 VPC내부에 존재하도록 지정하며,&lt;br /&gt;
3번째 숫자가 적어질수록 &lt;code class=&quot;highlighter-rouge&quot;&gt;security&lt;/code&gt;가 높아지게 cidr블록을 설정한다.&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;현재 사진에서는 편의상 1로 지정했지만, 실제로 생성할 때는 다음같은 나름의 &lt;code class=&quot;highlighter-rouge&quot;&gt;규칙&lt;/code&gt;을 적용하자.  &lt;br /&gt;
10.0.1.0/16 ~10.0.99.0/16 : &lt;code class=&quot;highlighter-rouge&quot;&gt;내부&lt;/code&gt; 통신&lt;br /&gt;
10.0.100.0/16 ~10.0.199.0/16: &lt;code class=&quot;highlighter-rouge&quot;&gt;외부&lt;/code&gt; 통신&lt;br /&gt;
같이 설정하여, IP만 보고도 &lt;code class=&quot;highlighter-rouge&quot;&gt;security&lt;/code&gt; 정도를 알 수 있도록 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_6.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;성공적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt;하였다면, 사진의 빨간 사각형처럼 우리가 명명한 이름으로 등록되며,&lt;br /&gt;
우리가 생성한 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;에 할당되었음을 확인할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-acl-확인&quot;&gt;3. ACL 확인&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_7.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;서브넷까지 생성한 후, 좌측 메뉴에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;ACL&lt;/code&gt;을 클릭하면 사진과 같이 새로 추가 되었음이 확인된다.&lt;br /&gt;
빨간 사각형 부분을 보면, 우리가 생성한 &lt;code class=&quot;highlighter-rouge&quot;&gt;서브넷&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;에 적용됨을 알 수 있다.
    &lt;blockquote&gt;
      &lt;p&gt;ACL 설정은 변경할 것도, 추가할 것도 없으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;확인&lt;/code&gt;만 하자.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-보안그룹-생성-및-설정&quot;&gt;3. 보안그룹 생성 및 설정&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_8.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;좌측 메뉴에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;보안그룹&lt;/code&gt;을 클릭하면, 사진처럼 2가지가 존재한다.&lt;br /&gt;
하나는 기본 VPC용, 다른 하나는 우리가 만든 VPC용이다.
    &lt;blockquote&gt;
      &lt;p&gt;우리는 서브넷별로 다른 보안그룹을 할당할 것이므로 새로 &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt;을 하자.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_9.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사진처럼 규칙에 따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;sg_apne2_dev_ssh&lt;/code&gt;로 이름을 작성한다.
    &lt;blockquote&gt;
      &lt;p&gt;이때 이름에 하이픈’&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;‘이 존재하면 생성이 되지 않으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;주의&lt;/code&gt;하자.&lt;br /&gt;
(이유는 모르겠다.. 연산자라 그런지도)&lt;br /&gt;
여태는 다 하이픈을 사용했으나.. 이번에만 언더바’&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;‘를 사용하도록 한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;설명에는 본인이 알아볼 수 있도록 작성하면 된다.
    &lt;blockquote&gt;
      &lt;p&gt;위와 비슷한 이유로 설명에 &lt;code class=&quot;highlighter-rouge&quot;&gt;한글&lt;/code&gt;이 들어가면 안된다고 발광을 하니 &lt;code class=&quot;highlighter-rouge&quot;&gt;주의&lt;/code&gt;하자.&lt;br /&gt;
사실 설명 없이도 한 눈에 알아볼 수 있는 이름이 &lt;code class=&quot;highlighter-rouge&quot;&gt;중요&lt;/code&gt;하다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;마지막으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;는 우리가 생성한 VPC를 선택하여 준다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_10.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;성공적으로 생성했다면, 사진처럼 우리가 정한 &lt;code class=&quot;highlighter-rouge&quot;&gt;이름&lt;/code&gt;으로 생성한 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;에&lt;br /&gt;
알맞은 &lt;code class=&quot;highlighter-rouge&quot;&gt;설명&lt;/code&gt;으로 생성됨이 확인된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이때, 방금 작성한 보안그룹을 클릭 후 사진처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;인바운드 규칙&lt;/code&gt;을 누른 후,&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;규칙 편집&lt;/code&gt;을 클릭한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_11.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;규칙 추가&lt;/code&gt;를 눌러 사진처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;SSH&lt;/code&gt;를 추가해준다.&lt;/li&gt;
  &lt;li&gt;이때 &lt;code class=&quot;highlighter-rouge&quot;&gt;소스&lt;/code&gt;는 특별한 경우가 아니면 &lt;code class=&quot;highlighter-rouge&quot;&gt;내 IP&lt;/code&gt;로 지정한다.&lt;br /&gt;
(혹은 직접 &lt;code class=&quot;highlighter-rouge&quot;&gt;지정&lt;/code&gt;하여 선택할 수도 있다.)
    &lt;blockquote&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;위치 무관&lt;/code&gt;으로 지정하는 순간 엄청난 &lt;code class=&quot;highlighter-rouge&quot;&gt;공격&lt;/code&gt;을 받게 될 것이다.&lt;br /&gt;
실제 내 지인 또한 이 설정을 하지 않아 &lt;code class=&quot;highlighter-rouge&quot;&gt;과금&lt;/code&gt;된 사례가 있었다.&lt;br /&gt;
이러한 경우 AWS에 문의하면 로그를 확인하고, 과금을 &lt;code class=&quot;highlighter-rouge&quot;&gt;취소&lt;/code&gt;해준다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_12.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;규칙을 추가한다면, 사진처럼 두 가지 프로토콜에 대한 &lt;code class=&quot;highlighter-rouge&quot;&gt;인바운드&lt;/code&gt; 규칙이 생긴다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-라우팅-테이블-생성-및-설정&quot;&gt;5. 라우팅 테이블 생성 및 설정&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_13.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;좌측 메뉴에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;라우팅 테이블&lt;/code&gt;을 클릭한 후, &lt;code class=&quot;highlighter-rouge&quot;&gt;라우팅 테이블 생성&lt;/code&gt;을 클릭한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_14.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;규칙에 따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;rt-apne2-dev-ssh&lt;/code&gt; 이름을 선택 후,&lt;br /&gt;
우리가 생성한 VPC를 선택하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt;한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_15.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생성한 라우팅 테이블을 선택하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;서브넷 연결&lt;/code&gt;을 누르고 &lt;code class=&quot;highlighter-rouge&quot;&gt;서브넷 연결 편집&lt;/code&gt;을 클릭한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_16.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;목록에서 우리가 만든 &lt;code class=&quot;highlighter-rouge&quot;&gt;서브넷&lt;/code&gt;을 선택 후, &lt;code class=&quot;highlighter-rouge&quot;&gt;저장&lt;/code&gt;을 누른다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_17.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;명시적으로 우리가 만든 &lt;code class=&quot;highlighter-rouge&quot;&gt;서브넷&lt;/code&gt;과 연결되었다는 정보를 확인할 수 있고,&lt;br /&gt;
하단에도 정보가 노출된다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_18.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;다음으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;라우팅&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;라우팅 편집&lt;/code&gt;을 눌러준다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_22.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;라우팅 추가&lt;/code&gt;를 누른 후, 왼쪽 대상에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;0.0.0.0/0&lt;/code&gt;을 입력하고, &lt;br /&gt;
오른쪽 대상에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Internet Gateway&lt;/code&gt;를 눌러준다.&lt;br /&gt;
그 후 왼쪽 검은 사각형처럼 정보가 노출되고, 우리가 만든 &lt;code class=&quot;highlighter-rouge&quot;&gt;인터넷 게이트웨이&lt;/code&gt;를 클릭하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;저장&lt;/code&gt;한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_4_23.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;등록 후, 사진처럼 연결한 &lt;code class=&quot;highlighter-rouge&quot;&gt;인터넷 게이트웨이&lt;/code&gt;가 표시된다.
    &lt;blockquote&gt;
      &lt;p&gt;이로써 &lt;code class=&quot;highlighter-rouge&quot;&gt;외부&lt;/code&gt;로 인터넷 게이트웨이를 통하여 통신할 준비가 완료 되었다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-인스턴스ec2-생성-및-설정&quot;&gt;6. 인스턴스(EC2) 생성 및 설정&lt;/h2&gt;
&lt;hr /&gt;</content><author><name>owin2828</name></author><category term="aws" /><summary type="html">들어가기 앞서 이전 포스팅에 이어서 AWS에서 VPC를 구성 후, 다음의 구성 요소들을 생성하거나 설정하는 방법에 대해 포스팅할 예정이다. Internet Gateway Subnet ACL Security Group Routing Table EC2 S3(VPC 내부 구성은 아님)</summary></entry><entry><title type="html">[AWS] Region, AZ, VPC, Subnet등 구성</title><link href="https://owin2828.github.io/devlog/2020/01/10/aws-2.html" rel="alternate" type="text/html" title="[AWS] Region, AZ, VPC, Subnet등 구성" /><published>2020-01-10T14:15:00+09:00</published><updated>2020-01-10T14:15:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/10/aws-2</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/10/aws-2.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;기초적인 내용을 들어가기 전에 여담으로 aws 사용에 대한 이야기를 잠깐 하고 가겠다.&lt;/p&gt;

&lt;p&gt;퍼블릭 클라우드가 그러하듯이, aws 또한 모든것이 &lt;code class=&quot;highlighter-rouge&quot;&gt;가상화&lt;/code&gt; 되어있다.&lt;br /&gt;
이 말은 내가 신경쓰고 관리해야할 것이 &lt;code class=&quot;highlighter-rouge&quot;&gt;전혀 없다&lt;/code&gt;는 말이고 모든 것을 aws가 알아서 해주는 것이다.&lt;br /&gt;
하지만 이러한 이유로 &lt;code class=&quot;highlighter-rouge&quot;&gt;하드웨어적 장애&lt;/code&gt;가 생겼을 때, 반대로 내가 할 수 있는 것은 전혀 없다.&lt;/p&gt;

&lt;p&gt;무슨 말이냐면, 하드웨어적 결함으로 어떤 에러가 발생하였을 때&lt;br /&gt;
그게 내 문제인지, aws의 문제인지 &lt;code class=&quot;highlighter-rouge&quot;&gt;알지 못할&lt;/code&gt; 수도 있다는 의미이다.&lt;br /&gt;
생각보다 이러한 이유가 굉장히 &lt;code class=&quot;highlighter-rouge&quot;&gt;스트레스&lt;/code&gt; 받는 일이 된다고 우리팀의 시니어분께서 말씀해 주셨다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;실제로 어떤 기업의 세미나에서 aws 기반 서비스를 개발하던 중, 이런 &lt;code class=&quot;highlighter-rouge&quot;&gt;장애&lt;/code&gt;를 만나서 고생한 이야기를 들었다.&lt;br /&gt;
장애의 원인이 본인들의 문제인지, aws의 결함인지 알지 못하여 문의로 해결을 받기까지 고생한 이야기인데,&lt;br /&gt;
알 수 없는 에러와 싸우며 몇날 몇일을 고생했다고 하셨다..&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;하지만 이런 단점에 비해 얻는 장점이 월등히 많으므로 전세계가 aws에 열광하는 것이 아닐까&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;각설하고 본격적으로 aws의 기초 구성에 대해 알아보도록 하자.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;aws-public-cloud의-구성&quot;&gt;AWS Public Cloud의 구성&lt;/h2&gt;
&lt;hr /&gt;
&lt;figure&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_2_1.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;figcaption&gt;출처: &lt;a href=&quot;https://blog.leedoing.com/46&quot;&gt;https://blog.leedoing.com/46&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;AWS의 기본적인 &lt;code class=&quot;highlighter-rouge&quot;&gt;구성요소&lt;/code&gt;의 단위는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;region&lt;/li&gt;
  &lt;li&gt;AZ(Availability Zone)&lt;/li&gt;
  &lt;li&gt;VPC(Virtual Private Cloud)&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-region&quot;&gt;1. region&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;구성요소 중 가장 큰 단위이며, 논리적인 단계이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-azavailability-zone&quot;&gt;2. AZ(Availability Zone)&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;실제 IDC 단위로써, aws 정책에 따라 하나의 region안에는 반드시 &lt;code class=&quot;highlighter-rouge&quot;&gt;2개 이상&lt;/code&gt;의 AZ가 존재한다고 한다.&lt;br /&gt;
(그림에서도 2개의 AZ가 존재한다.)&lt;br /&gt;
시스템을 구성할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;single AZ&lt;/code&gt;로 할 것인지, &lt;code class=&quot;highlighter-rouge&quot;&gt;multi AZ&lt;/code&gt;로 할 것인지는 사용자의 선택사항이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;multi AZ로 구성하여 data들을 이원화하여 안전하게 보관하는 것도 하나의 방법이고,&lt;br /&gt;
Elastic Load Balancer를 통해 각각의 AZ가 다른 일을 수행하게 하는 것도 하나의 방법이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;3-vpcvirtual-private-cloud&quot;&gt;3. VPC(Virtual Private Cloud)&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;AZ 밑의 단위로써, &lt;code class=&quot;highlighter-rouge&quot;&gt;논리적인 구조&lt;/code&gt;로 하나의 IDC 처럼 동작한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;약간 웃긴것이 분명 public 서비스인데, &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;가 붙었다.&lt;br /&gt;
그 이유는 논리적인 하나의 IDC를 만들어서 개인이 사용할 수 있기 때문이라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;모든 리소스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;에 저장되며 한 region에 5개까지 VPC를 생성할 수 있다.(필요시 제한용량 해제 신청)&lt;br /&gt;
물론 VPC 없이도 서버를 생성할 수 있지만, 권장되지 않는다고 한다.&lt;/p&gt;

&lt;p&gt;계정을 생성하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;기본 VPC&lt;/code&gt;가 생성되고 그 안에 기본적인 구성요소들이 생성된다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;이 기본 VPC는 건들지 말자. 어떤 &lt;code class=&quot;highlighter-rouge&quot;&gt;에러&lt;/code&gt;들이 발생한다고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;figure&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_2_2.png&quot; alt=&quot;&quot; width=&quot;130%&quot; height=&quot;130%&quot; /&gt;&lt;/p&gt;
  &lt;figcaption&gt;출처: &lt;a href=&quot;https://cloudaffaire.com/create-a-vpc-interface-endpoint/&quot;&gt;https://cloudaffaire.com/create-a-vpc-interface-endpoint/&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;위 그림에서도 볼 수 있듯이, VPC의 구성은 다음과 같이 이루어진다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IGW&lt;/code&gt;(Internet Gate Way): 외부로 연결되는 인터넷 게이트웨이&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Subnet&lt;/code&gt;: VPC의 가장 &lt;code class=&quot;highlighter-rouge&quot;&gt;기본&lt;/code&gt;적인 하나의 단위로써, 각 서브넷은 public, private 중 설정이 가능&lt;br /&gt;
private은 외부에서 접속할 수도, 외부로 나갈 수도 없음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACL&lt;/code&gt;: 서브넷의 설정을 위한 &lt;code class=&quot;highlighter-rouge&quot;&gt;방화벽&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Security Group&lt;/code&gt;: 서브넷 하나의 &lt;code class=&quot;highlighter-rouge&quot;&gt;보안&lt;/code&gt;을 설정, 주로 ACL은 두고, SG를 설정하여 보안관리&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ELB&lt;/code&gt;(Elastic Load Balancing): 로드밸런싱과 보안 설정을 해줌&lt;br /&gt;
private 서브넷을 만들경우, 외부와 통신이 안되는데 이때 ELB를 사용해서 외부에서 접근하도록 설정&lt;br /&gt;
(&lt;code class=&quot;highlighter-rouge&quot;&gt;로드밸런싱&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;허용된 매서드&lt;/code&gt;만 접근이 가능해진다고 함)&lt;br /&gt;
ELB의 종류는 다음과 같이 3가지 존재
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Classic&lt;/code&gt;: 예전 방식&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Application&lt;/code&gt;: 도메인 하위 레벨(/users 등)에 따라 다르게 웹 서버에 구성하고 이를 밸런싱&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Network&lt;/code&gt;: 모든 프로토콜(http(s) + 커스터마이징 프로토콜)에 대해 밸런싱&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;3-1-subnet과-ec2-인스턴스&quot;&gt;3-1. Subnet과 EC2 인스턴스&lt;/h5&gt;
&lt;hr /&gt;
&lt;p&gt;하나의 VPC에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;여러개&lt;/code&gt;의 서브넷을 생성할 수 있다.(10.1.10.100 / 10.1.10.110 등..)&lt;br /&gt;
이때 ip를 구분하여 용도에 맞게 할당해 내부적으로 영역을 &lt;code class=&quot;highlighter-rouge&quot;&gt;구분&lt;/code&gt;한다.&lt;br /&gt;
(x.x.x.100대 이상은 외부통신, 미만은 내부통신 같은 방식)&lt;/p&gt;

&lt;p&gt;이렇게 만들어진 서브넷 하나에 만드는 서버를 우리가 아는 &lt;code class=&quot;highlighter-rouge&quot;&gt;EC2&lt;/code&gt;라고 한다.&lt;br /&gt;
오브젝트를 만들고 메모리에 올려 사용하는 것을 &lt;code class=&quot;highlighter-rouge&quot;&gt;인스턴스&lt;/code&gt;라 칭하므로,&lt;br /&gt;
가상화된 환경에 올려 사용자가 사용할 수 있도록 한 것을 &lt;code class=&quot;highlighter-rouge&quot;&gt;EC2 인스턴스&lt;/code&gt;라 부른다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;3-2-bastion&quot;&gt;3-2. Bastion&lt;/h5&gt;
&lt;hr /&gt;
&lt;figure&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_2_3.jpg&quot; alt=&quot;&quot; width=&quot;80%&quot; height=&quot;80%&quot; /&gt;&lt;/p&gt;
  &lt;figcaption&gt;출처: &lt;a href=&quot;https://www.youtube.com/watch?v=edi1kyxznE0&quot;&gt;https://www.youtube.com/watch?v=edi1kyxznE0&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;VPC를 구성할 때, 내부 서브넷들을 &lt;code class=&quot;highlighter-rouge&quot;&gt;전부 private&lt;/code&gt;으로 설정하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;하나만&lt;/code&gt; 관리용 &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; 서브넷으로 설정한다.&lt;br /&gt;
이 public 서브넷으로 다른 private 서브넷들을 관리하며, 이러한 관리자를 &lt;code class=&quot;highlighter-rouge&quot;&gt;bastion&lt;/code&gt;이라 한다.&lt;br /&gt;
이런 방법을 사용하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;SG&lt;/code&gt;(Security Group)을 설정해 &lt;code class=&quot;highlighter-rouge&quot;&gt;한정된 IP&lt;/code&gt;만 bastion에 접근하도록 허용해야 한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;만약 전부 public으로 서브넷을 만든다면, 관리자 중 한 명만 퇴사해도 &lt;code class=&quot;highlighter-rouge&quot;&gt;모든&lt;/code&gt; 서브넷의 key를 갱신해야 한다.&lt;br /&gt;
매 번 이렇게 서브넷을 업데이트 할 수 없으므로, &lt;code class=&quot;highlighter-rouge&quot;&gt;전부&lt;/code&gt; private으로 설정한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;3-3-nat&quot;&gt;3-3. NAT&lt;/h5&gt;
&lt;hr /&gt;
&lt;p&gt;하지만 문제는 여전히 존재한다. 전부 private으로 만들어 버렸으니, 각 서브넷의 외부와 통신이 안된다.&lt;br /&gt;
그럼 각 서브넷의 &lt;code class=&quot;highlighter-rouge&quot;&gt;OS 업데이트&lt;/code&gt;는 어떻게 하는가?&lt;/p&gt;

&lt;figure&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_2_4.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;figcaption&gt;출처: &lt;a href=&quot;https://blog.2dal.com/2017/09/12/aws-vpc-basic/&quot;&gt;https://blog.2dal.com/2017/09/12/aws-vpc-basic/&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;정답은 하나의 서브넷을 public으로 설정 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;outbound&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;가능&lt;/code&gt;하게, &lt;code class=&quot;highlighter-rouge&quot;&gt;inbound&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;불가능&lt;/code&gt;하게 만들면 된다.&lt;br /&gt;
이런 역할을 &lt;code class=&quot;highlighter-rouge&quot;&gt;NAT&lt;/code&gt;이라 부르며 하나의 서브넷에 bastion과 NAT을 둘다 포함시킬 수도 있다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;이전에는 NAT 인스턴스를 생성해야 했으나, &lt;code class=&quot;highlighter-rouge&quot;&gt;NAT gateway&lt;/code&gt;를 생성하여 서브넷 안에 포함시키면 작동하도록 변경되었다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;3-4-dev-manage-product-vpc&quot;&gt;3-4. Dev, Manage, Product VPC&lt;/h5&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;실제&lt;/code&gt; 개발 및 배포를 진행할 때는 &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC 구성&lt;/code&gt;을 어떻게 해야할까?&lt;br /&gt;
여러가지 방법이 있겠지만, aws는 &lt;code class=&quot;highlighter-rouge&quot;&gt;각 단계별&lt;/code&gt;로 VPC를 따로 구성하는 것을 추천한다.&lt;/p&gt;
&lt;figure&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_2_5.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;figcaption&gt;출처: &lt;a href=&quot;https://aws.amazon.com/ko/quickstart/architecture/compliance-uk-official/&quot;&gt;https://aws.amazon.com/ko/quickstart/architecture/compliance-uk-official/&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;위의 그림은 aws 공식 홈페이지에서 가져온 것인데, &lt;code class=&quot;highlighter-rouge&quot;&gt;Dev&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Managemnet&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Production&lt;/code&gt; 총 3단계로 구성되있다.&lt;br /&gt;
이렇게 Stage 별로 VPC를 따로 구성해서 관리하는 것이 복잡한 서브넷간 설정을 &lt;code class=&quot;highlighter-rouge&quot;&gt;피할 수 있기&lt;/code&gt; 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;물론 하나의 VPC 안에서 서브넷을 나눠 그룹별로 관리할 수도 있으나, 규모가 커졌을 때 서브넷간의 복잡한 설정으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;어려움&lt;/code&gt;이 따르게 된다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;4-s3simple-storgae-service&quot;&gt;4. S3(Simple Storgae Service)&lt;/h4&gt;
&lt;hr /&gt;
&lt;figure&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_2_6.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;figcaption&gt;출처: &lt;a href=&quot;https://www.megazone.com/techblog_191113_aws-privatelink/&quot;&gt;https://www.megazone.com/techblog_191113_aws-privatelink/&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;S3는 단순하게는 하나의 &lt;code class=&quot;highlighter-rouge&quot;&gt;저장소&lt;/code&gt;이다.&lt;br /&gt;
하지만 활용법에 따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;효율적인&lt;/code&gt; 정보의 전달이 가능한데, 이는 S3가 &lt;code class=&quot;highlighter-rouge&quot;&gt;웹서버&lt;/code&gt; 역할을 제공하기 때문이다.&lt;br /&gt;
이는 다음의 과정을 거쳐 이루어지게 된다.&lt;/p&gt;

&lt;p&gt;S3는 기본적으로 VPC 밖에 구성된 하나의 웹서버로써 이곳에 &lt;code class=&quot;highlighter-rouge&quot;&gt;html&lt;/code&gt; 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;정적인 파일&lt;/code&gt;을 주로 배치한다.&lt;br /&gt;
End-user에게는 이곳을 보도록 설정하고, user가 원하는 요청을 수행하도록 그 파일에 &lt;code class=&quot;highlighter-rouge&quot;&gt;스크립트&lt;/code&gt;로 짜놓는다.&lt;br /&gt;
User가 해당 요청을 하게되면 스크립트가 &lt;code class=&quot;highlighter-rouge&quot;&gt;브라우저&lt;/code&gt;에서 실행되어, VPC를 거쳐 EC2까지 요청을 전송한다.&lt;br /&gt;
이러한 과정을 통해 User는 VPC를 신경쓸 필요없이 S3의 html로 &lt;code class=&quot;highlighter-rouge&quot;&gt;결과&lt;/code&gt;를 받을 수 있게 된다.&lt;/p&gt;

&lt;p&gt;이러한 방식은 사실상 업계의 &lt;code class=&quot;highlighter-rouge&quot;&gt;표준&lt;/code&gt;이라고 하며, 다른 오브젝트들이 이러한 S3호환 프로토콜을 제공한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5-rdsrelation-db-service&quot;&gt;5. RDS(Relation DB Service)&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;하나의 서브넷을 구현하고, 그 안에 DB 서버를 구축하여 운영하는 것이 기존의 방식이었다면,&lt;br /&gt;
aws에서 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Paas&lt;/code&gt;의 일종인 &lt;code class=&quot;highlighter-rouge&quot;&gt;RDS&lt;/code&gt;를 이용하여 더 효율적인 관리를 할 수 있다.&lt;/p&gt;

&lt;p&gt;이는 aws가 DB의 업데이트, 설치, 운영 그리고 관리까지 지원하기 때문이며, 지원하는 엔진은 다음과 같다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;MySQL&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Oracle&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;SQL Server&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;PostgreSQL&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;MariaDB&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Aurora(MySQL과 호환)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;또한 RDS에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Multi-AZ&lt;/code&gt; 옵션을 설정하면, 다른 AZ에 복제된 DB를 바로 사용할 수 있다.&lt;br /&gt;
주로 data를 백업하여 이원화하는 용도로 많이 쓰이게 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Aurora는 aws에서 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;자체 DB&lt;/code&gt;로써 장애발생 및 AZ를 이용한 자체복구등 추가 기능을 지원한다고 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;aws의 기초에 대해 &lt;code class=&quot;highlighter-rouge&quot;&gt;유능하신 어떤 분&lt;/code&gt;께 배운 내용을 토대로 작성된 글이다.&lt;br /&gt;
인터넷을 찾아보면 훨씬 전문적이고 깊은 이해를 돕는 글들이 있지만,&lt;br /&gt;
이 포스팅의 목적은 최대한 &lt;code class=&quot;highlighter-rouge&quot;&gt;간단&lt;/code&gt;하게, &lt;code class=&quot;highlighter-rouge&quot;&gt;이해&lt;/code&gt;가 되도록 작성하는 것이었다.&lt;/p&gt;

&lt;p&gt;너무 긴 글이라 두개로 분리할까 고민했는데, 혹시 지치신 분들이 있다면 위로가 있기를…&lt;br /&gt;
다음에는 간단하게 AWS VPC를 구성하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;실습&lt;/code&gt;을 진행해 볼 예정이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이번 포스팅에는 사진에 달려있는 출처들이 reference 역할을 하기 때문에 따로 참조를 달지 않았다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>owin2828</name></author><category term="aws" /><summary type="html">들어가기 앞서 기초적인 내용을 들어가기 전에 여담으로 aws 사용에 대한 이야기를 잠깐 하고 가겠다.</summary></entry><entry><title type="html">[AWS] 퍼블릭 클라우드 vs 프라이빗 클라우드</title><link href="https://owin2828.github.io/devlog/2020/01/10/aws-1.html" rel="alternate" type="text/html" title="[AWS] 퍼블릭 클라우드 vs 프라이빗 클라우드" /><published>2020-01-10T10:55:00+09:00</published><updated>2020-01-10T10:55:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/10/aws-1</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/10/aws-1.html">&lt;h2 id=&quot;클라우드&quot;&gt;클라우드&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;이제는 이 단어가 개발자가 아닌 주변 내 지인들에게도 전혀 낯설지 않은 단어가 되었다.&lt;br /&gt;
그만큼 &lt;code class=&quot;highlighter-rouge&quot;&gt;클라우드&lt;/code&gt;가 우리 일상에 가져오는 영향은 굉장히 크다고 할 수 있는데,&lt;br /&gt;
이번 시리즈에서 클라우드의 기본 개념과 &lt;code class=&quot;highlighter-rouge&quot;&gt;AWS&lt;/code&gt;의 기초개념 및 실습을 포스팅 하고자 한다.&lt;br /&gt;
시리즈의 시작으로 각 클라우드의 장단점 및 고려사항부터 써보고자 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;클라우드의 기본 개념과 기존에 정리가 잘 된 많은 글들이 있으니,&lt;br /&gt;
혹시 궁금한 것이 있다면 다른 글을 찾아보는 것을 추천합니다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;public-cloud&quot;&gt;Public Cloud&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;나같은 일반 개발자나, 기업을 대상으로 서비스를 제공하는 클라우드 인프라를 &lt;code class=&quot;highlighter-rouge&quot;&gt;퍼블릭&lt;/code&gt; 클라우드라 한다.&lt;br /&gt;
클라우드 서비스를 제공하는 다양한 업체들(AWS, Google, MS, Alibaba, Naver)등은 가상환경 내의 서버를 임대해 준다.&lt;br /&gt;
이러한 클라우드 서비스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Pay-as-you-go&lt;/code&gt;으로 사용한 만큼 과금하는 방식을 채택하며 별도의 하드웨어가 필요하지 않다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;private-cloud&quot;&gt;Private Cloud&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;하나의 조직에 전용 클라우드 환경을 제공하는 모델을 &lt;code class=&quot;highlighter-rouge&quot;&gt;프라이빗&lt;/code&gt; 클라우드라 한다.(VMware, OpenStack등)&lt;br /&gt;
사내 전용 클라우드로써, 각 조직이 더 효율적으로 관리할 수 있으나, 퍼블릭 클라우드에 비해 비용이 많이든다.&lt;br /&gt;
각 조직에 &lt;code class=&quot;highlighter-rouge&quot;&gt;on-premise&lt;/code&gt; 방식으로 적용될 수도 있고, 퍼블릭 클라우드 제공업체에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;off-premise&lt;/code&gt;로 호스팅 될 수도 있다.&lt;/p&gt;

&lt;p&gt;조달된 하드웨어와 가상화된 레이어 위에서 동작하기 때문에 시간이 절약되는 이점이 존재하지만,&lt;br /&gt;
HW 관리자 – 하이퍼바이저 관리자 – SW 관리자 이런식의 구성으로 인해 &lt;code class=&quot;highlighter-rouge&quot;&gt;하이퍼바이저&lt;/code&gt;의 관리가 또다른 &lt;code class=&quot;highlighter-rouge&quot;&gt;비용발생&lt;/code&gt;으로 다가올 수 있다.&lt;br /&gt;
또한 각 OS별로 라이센스를 일일히 구매해야 하므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;추가적인 비용&lt;/code&gt;이 발생할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;개인적인 의견으로는 일반 사기업이 하기에는 어렵지 않나 싶다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;hybrid-cloud&quot;&gt;Hybrid Cloud&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;VPN등의 보안연결을 통해서 하나 이상의 퍼블릭 클라우드 + 프라이빗 클라우드 환경을 결합하는 방식이다.&lt;br /&gt;
두 개의 클라우드 간의 트래픽은 유동적으로 조정이 가능하여 유연한 대처가 가능하다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;프라이빗 클라우드에 많은 트래픽이 몰릴경우, 퍼블릭 클라우드로 &lt;code class=&quot;highlighter-rouge&quot;&gt;버스팅&lt;/code&gt;하여 유동적인 대처가 가능하다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;앞으로&quot;&gt;앞으로&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;진행하게될 포스팅은 위에 언급한 것 중, 당연히 퍼블릭 클라우드인 &lt;code class=&quot;highlighter-rouge&quot;&gt;aws&lt;/code&gt;를 이용하여 진행할 예정이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;무료&lt;/code&gt;로 사용해 볼 수 있고, 가장 대중적이며 개인이 작은 규모로 해보기에 가장 좋기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>owin2828</name></author><category term="aws" /><summary type="html">클라우드 이제는 이 단어가 개발자가 아닌 주변 내 지인들에게도 전혀 낯설지 않은 단어가 되었다. 그만큼 클라우드가 우리 일상에 가져오는 영향은 굉장히 크다고 할 수 있는데, 이번 시리즈에서 클라우드의 기본 개념과 AWS의 기초개념 및 실습을 포스팅 하고자 한다. 시리즈의 시작으로 각 클라우드의 장단점 및 고려사항부터 써보고자 한다.</summary></entry><entry><title type="html">[보안] 파일 업로드 취약점</title><link href="https://owin2828.github.io/devlog/2020/01/09/etc-2.html" rel="alternate" type="text/html" title="[보안] 파일 업로드 취약점" /><published>2020-01-09T14:56:00+09:00</published><updated>2020-01-09T14:56:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/09/etc-2</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/09/etc-2.html">&lt;h2 id=&quot;1-파일-업로드-취약점이란&quot;&gt;1. 파일 업로드 취약점이란&lt;/h2&gt;
&lt;p&gt;주로 게시판 등에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;파일 업로드&lt;/code&gt; 기능을 악용하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;시스템 권한&lt;/code&gt;을 획득할 수 있는 취약점을 의미한다.&lt;br /&gt;
나처럼 보안에 대한 지식이 얕은 사람은 위의 문장이 생소하게 느껴질 것이기에, 다시 풀어 써본다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;악성 스크립트&lt;/code&gt;가 업로드 된 후, 서버상에서 스크립트를 실행하여 쉘을 획득하는 등의 행위로 서버를 &lt;code class=&quot;highlighter-rouge&quot;&gt;장악&lt;/code&gt;할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 흔히 말하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;웹쉘&lt;/code&gt;의 업로드를 통해 시스템의 권한을 장악한다는 이야기이다.&lt;br /&gt;
그렇다면 어떤 파일들이 웹에서 구동되는가? 웹 서버에서 실행 가능한 &lt;code class=&quot;highlighter-rouge&quot;&gt;확장자&lt;/code&gt;는 다음과 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;언어&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;확장자&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;asp, aspx&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;asp, aspx, htm, html, asa&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;php&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;phtml, php, php3, php4, php5, inc, htm, html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;jsp, java&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;jsp, jspx, jsw, jsv, jspf, htm, html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;perl&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pl, pm, cgi, lib, htm, html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;coldfusion&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cfm, cfml, cfc, dbm, htm, html&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이러한 악성 파일이 업로드 된다면, &lt;code class=&quot;highlighter-rouge&quot;&gt;접근권한&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;정보유출&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;악성코드 배포&lt;/code&gt; 등의 문제를 야기할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-공격방법&quot;&gt;2. 공격방법&lt;/h2&gt;
&lt;p&gt;이러한 취약점을 찾아 공격하는 방법은 크게 4가지 정도이다.&lt;/p&gt;

&lt;h5 id=&quot;1_-취약점-점검&quot;&gt;1_ 취약점 점검&lt;/h5&gt;
&lt;p&gt;가장 간단한 방법으로 다음과 같은 과정을 거친다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;파일 업로드시에 &lt;code class=&quot;highlighter-rouge&quot;&gt;확장자 제한&lt;/code&gt;이 없는지 확인하고,&lt;/li&gt;
  &lt;li&gt;업로드된 파일에 &lt;code class=&quot;highlighter-rouge&quot;&gt;접근&lt;/code&gt; 및 &lt;code class=&quot;highlighter-rouge&quot;&gt;실행&lt;/code&gt;이 가능한지 확인하여 공격하는 것이다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;2_-proxy-툴을-이용해-확장자-검사-우회-파일-업로드&quot;&gt;2_ Proxy 툴을 이용해 확장자 검사 우회 파일 업로드&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;파일타입 변조&lt;/code&gt;등의 우회공격을 통해 확장자 검사를 피하는 것을 의미한다.&lt;br /&gt;
업로드 시 파일의유형 정보를 알려주는 헤더 중, &lt;code class=&quot;highlighter-rouge&quot;&gt;Content-type&lt;/code&gt; 속성을 프록시를 이용해 우회하여 공격할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;자세한 사항은 다음 링크를 참조하시기를..&lt;br /&gt;
&lt;a href=&quot;https://bit.ly/2tIJ21w&quot;&gt;https://bit.ly/2tIJ21w&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;3_-null을-이용한-파일-업로드&quot;&gt;3_ Null을 이용한 파일 업로드&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;널(%00)&lt;/code&gt;문자가 문자의 끝을 의미하기 때문에 특정 확장자를 &lt;code class=&quot;highlighter-rouge&quot;&gt;숨기기&lt;/code&gt; 위한 목적으로 사용될 수 있다.&lt;br /&gt;
해당 부분의 취약점은 내부 API를 호출할 때 발생될 가능성이 있다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;널바이트(%00)와 .jpeg확장자를 함께 접목하여 업로드하면 %00 다음의 문자열은 무시하게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;언어&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;우회패턴&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;처리패턴&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;php&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;test.php%00.jpeg&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;test.php&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;asp&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;test.asp%00.jpeg&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;test.asp&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;jsp&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;test.jsp%00.jpeg&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;test.jsp&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;4_-sql-injection을-이용한-파일-업로드&quot;&gt;4_ SQL Injection을 이용한 파일 업로드&lt;/h5&gt;
&lt;p&gt;2가지 정도의 방법이 존재하는데, 다음과 같다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;MySQL&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;into outfile()&lt;/code&gt; 함수를 이용하여 웹서버에 파일을 생성할 수 있다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;MSSQL&lt;/code&gt;의 저장 프로시저(&lt;code class=&quot;highlighter-rouge&quot;&gt;xp_cmdshell&lt;/code&gt;)을 이용하여 echo와 » (파이프) 명령어를 통해 특정 파일에 삽입할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-방어방법&quot;&gt;3. 방어방법&lt;/h2&gt;
&lt;p&gt;모든 부분을 전부 작성할 수는 없지만, 대략적으로 다음과 같은 방법을 통하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;기초&lt;/code&gt;적인 방어를 할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;확장자 검사&lt;/li&gt;
  &lt;li&gt;대소문자 구분하지 않고 확장자 비교&lt;/li&gt;
  &lt;li&gt;특수문자가 포함된 경우 업로드 금지&lt;/li&gt;
  &lt;li&gt;업로드된 파일명, 확장자를 난수화하여 변경&lt;/li&gt;
  &lt;li&gt;업로드된 파일을 url 요청으로 직접 접근이 불가능한 위치에 저장&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://4rgos.tistory.com/4&quot;&gt;https://4rgos.tistory.com/4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>owin2828</name></author><category term="etc" /><summary type="html">1. 파일 업로드 취약점이란 주로 게시판 등에서 파일 업로드 기능을 악용하여 시스템 권한을 획득할 수 있는 취약점을 의미한다. 나처럼 보안에 대한 지식이 얕은 사람은 위의 문장이 생소하게 느껴질 것이기에, 다시 풀어 써본다. 악성 스크립트가 업로드 된 후, 서버상에서 스크립트를 실행하여 쉘을 획득하는 등의 행위로 서버를 장악할 수 있다.</summary></entry><entry><title type="html">[CI/CD] Jenkins vs GitLabCI vs Travis</title><link href="https://owin2828.github.io/devlog/2020/01/09/cicd-5.html" rel="alternate" type="text/html" title="[CI/CD] Jenkins vs GitLabCI vs Travis" /><published>2020-01-09T13:13:00+09:00</published><updated>2020-01-09T13:13:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/09/cicd-5</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/09/cicd-5.html">&lt;h2 id=&quot;이번-글에서는&quot;&gt;이번 글에서는&lt;/h2&gt;
&lt;p&gt;CI/CD 파이프라인 구축을 위한 서비스들이 무엇이 있는지 살펴보고,&lt;br /&gt;
다음과 같은 솔루션들의 장단점을 분석하고자 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Travis&lt;/li&gt;
  &lt;li&gt;GitLab CI&lt;/li&gt;
  &lt;li&gt;Jenkins&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-trvais&quot;&gt;1. Trvais&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/img/cicd/cicd_5_1.jpg&quot; alt=&quot;Travis 로고&quot; width=&quot;70%&quot; height=&quot;70%&quot; /&gt;&lt;br /&gt;
별도의 회사였으나, &lt;code class=&quot;highlighter-rouge&quot;&gt;GitHub&lt;/code&gt;에서 인수하였다.(GitHub는 MS가 인수함)&lt;br /&gt;
오픈소스용 &lt;code class=&quot;highlighter-rouge&quot;&gt;무료&lt;/code&gt; travis.org와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Private Repo&lt;/code&gt;를 위한 &lt;code class=&quot;highlighter-rouge&quot;&gt;유료&lt;/code&gt; travis.com을 별도로 운영하고 있고, 내용은 동일하다.&lt;/p&gt;

&lt;h5 id=&quot;장점&quot;&gt;장점&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GitHub&lt;/code&gt;와의 연동(그냥 깃허브 계정으로 로그인하며 된다.)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;YML&lt;/code&gt; 파일을 통한 쉬운 설정&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;다양한&lt;/code&gt; 래퍼런스&lt;/li&gt;
  &lt;li&gt;직접 서버를 운영할 필요 없이, Travis에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;알아서&lt;/code&gt; VM으로 호스팅해 줌&lt;/li&gt;
  &lt;li&gt;모든 job이 &lt;code class=&quot;highlighter-rouge&quot;&gt;독립&lt;/code&gt;적(서로 간의 영향을 받지 않음)&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;단점&quot;&gt;단점&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Jenkins에 비해 플러그인의 종류가 &lt;code class=&quot;highlighter-rouge&quot;&gt;적음&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;유료 서비스를 사용할 경우, 가격이 꽤 &lt;code class=&quot;highlighter-rouge&quot;&gt;비쌈&lt;/code&gt;(기본: 69$/month, 일반: 129$/month)&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-gitlab-ci&quot;&gt;2. GitLab CI&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/img/cicd/cicd_5_2.png&quot; alt=&quot;Gitlab CI 로고&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;br /&gt;
GitLab 서비스에 내장되어 있다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;On-Premise&lt;/code&gt; 방식으로 설치하여 사용할 수도 있고, &lt;code class=&quot;highlighter-rouge&quot;&gt;웹&lt;/code&gt; 서비스로 사용할 수도 있다.&lt;br /&gt;
GitLab CI만 &lt;code class=&quot;highlighter-rouge&quot;&gt;Runner&lt;/code&gt;를 직접 호스팅하여 사용할 수 있는데, 이를 통해 고성능 혹은 서비스에 트고하된 환경에서 실행할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Runner&lt;/code&gt;: repo로부터 소스코드를 받아 해당 스크립트를 돌리는 작업을 수행&lt;br /&gt;
GitLab의 경우&lt;code class=&quot;highlighter-rouge&quot;&gt;shared runner&lt;/code&gt;를 사용해서 계획적으로 돌릴 수 있다.&lt;br /&gt;
On-Premise 방식에서는 당연히 지원하고,&lt;br /&gt;
GitLab의 클라우드 서비스를 사용하는 경우에도, Runner만 &lt;code class=&quot;highlighter-rouge&quot;&gt;따로&lt;/code&gt; 운용할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;장점-1&quot;&gt;장점&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GitLab&lt;/code&gt;과의 손쉬운 연동&lt;/li&gt;
  &lt;li&gt;Runner가 &lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 컨테이너 기반이라, Docker 친화적임(Docker Repo 무료 제공)&lt;/li&gt;
  &lt;li&gt;UI가 쉽고 &lt;code class=&quot;highlighter-rouge&quot;&gt;간편함&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;모든 job이 &lt;code class=&quot;highlighter-rouge&quot;&gt;독립적&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;단점-1&quot;&gt;단점&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;역시나 Jenkins에 비해 플러그인의 종류가 &lt;code class=&quot;highlighter-rouge&quot;&gt;적음&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;모든&lt;/code&gt; job에 대해 artifact를 정의 및 업로드/다운로드를 해야함&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-jenkins&quot;&gt;3. Jenkins&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/img/cicd/cicd_5_3.png&quot; alt=&quot;Jenkins 로고&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt; 기반의 오픈소스로 구성되어 있으며, CI계의 &lt;code class=&quot;highlighter-rouge&quot;&gt;아버지&lt;/code&gt;라 불린다.&lt;br /&gt;
제일 오래된 만큼 다양한 플러그인을 지원하며, 사용자도 관련 문서도 많이 존재한다.&lt;/p&gt;

&lt;h5 id=&quot;장점-2&quot;&gt;장점&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;무료&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;다양한 IDE를 지원하며, 커스터마이징이 다양&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;많은&lt;/code&gt; 사용자들을 보유하고 있고, 관련 문서가 &lt;code class=&quot;highlighter-rouge&quot;&gt;다양&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;호스팅을 &lt;code class=&quot;highlighter-rouge&quot;&gt;직접&lt;/code&gt;해야하기 때문에 관련된 모든 부분을 관리할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;단점-2&quot;&gt;단점&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;다양한 플러그인 -&amp;gt; 플러그인 지옥&lt;/li&gt;
  &lt;li&gt;규모가 &lt;code class=&quot;highlighter-rouge&quot;&gt;작은&lt;/code&gt; 프로젝트의 경우, 설정하는데 리소스 &lt;code class=&quot;highlighter-rouge&quot;&gt;낭비&lt;/code&gt;가 발생할 수 있음&lt;/li&gt;
  &lt;li&gt;호스팅을 &lt;code class=&quot;highlighter-rouge&quot;&gt;직접&lt;/code&gt;해야하기 때문에 서버 운영 및 관리 &lt;code class=&quot;highlighter-rouge&quot;&gt;비용&lt;/code&gt;이 발생&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;개인적인-견해로는&quot;&gt;개인적인 견해로는&lt;/h2&gt;
&lt;p&gt;CI/CD를 적용해야 한다는 생각에 제일 유명한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Jenkins&lt;/code&gt;를 사용하려는 사람들이 많은것 같다.&lt;br /&gt;
하지만, Jenkins는 오래된 만큼 장단점이 확실한 솔루션임을 알고 사용했으면 좋겠다.&lt;/p&gt;

&lt;p&gt;특히 Build Server를 직접 구매 및 운영해야 하기 때문에 발생하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;단점&lt;/code&gt;이 생각보다 크게 다가오게 된다.&lt;br /&gt;
하나부터 열까지 전부 환경설정을 구축해야하며, 서버를 관리하는데 발생하는 비용이 &lt;code class=&quot;highlighter-rouge&quot;&gt;낭비&lt;/code&gt;가 될 수 있기 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Jenkins를 사용할 때, 각종 &lt;code class=&quot;highlighter-rouge&quot;&gt;방화벽&lt;/code&gt; 작업이나 서버의 &lt;code class=&quot;highlighter-rouge&quot;&gt;관리&lt;/code&gt; 및 &lt;code class=&quot;highlighter-rouge&quot;&gt;운용&lt;/code&gt;등은 생각보다 많은 리소스를 요구한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 규모가 크지않은 프로젝트거나, 외부 클라우드 서비스를 이용하는 상황등이라면 Jenkins말고 &lt;code class=&quot;highlighter-rouge&quot;&gt;다른&lt;/code&gt; 서비스도 고려해볼 가치가 있다고 생각한다.&lt;br /&gt;
내가 글을 작성하는 이 블로그 또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Travis&lt;/code&gt;를 사용하여 간단한 CI/CD 형태로 빌드 및 배포하게 되어있다.&lt;/p&gt;

&lt;p&gt;개발을 하면서 느끼는 거지만, 모든 일에 &lt;code class=&quot;highlighter-rouge&quot;&gt;정답&lt;/code&gt;은 없다.&lt;br /&gt;
상황에 맞게 &lt;code class=&quot;highlighter-rouge&quot;&gt;최선&lt;/code&gt;의 방법을 채택하여 가장 높은 &lt;code class=&quot;highlighter-rouge&quot;&gt;효율&lt;/code&gt;을 낼 수 있는 방안을 선택하는 것도 &lt;code class=&quot;highlighter-rouge&quot;&gt;일류&lt;/code&gt; 개발자의 자질이 아닐까.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;이 글에서는 언급하지 않았지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;AWS&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;CircleCI&lt;/code&gt;등 수많은 다른 방법도 존재한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://about.gitlab.com/devops-tools/jenkins-vs-gitlab.html&quot;&gt;https://about.gitlab.com/devops-tools/jenkins-vs-gitlab.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hackernoon.com/continuous-integration-circleci-vs-travis-ci-vs-jenkins-41a1c2bd95f5&quot;&gt;https://hackernoon.com/continuous-integration-circleci-vs-travis-ci-vs-jenkins-41a1c2bd95f5&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.thecodecampus.de/blog/jenkins-vs-gitlab-ci/&quot;&gt;https://www.thecodecampus.de/blog/jenkins-vs-gitlab-ci/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.cookapps.io/cook-dev/tech-stack/#ci-cd&quot;&gt;https://blog.cookapps.io/cook-dev/tech-stack/#ci-cd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>owin2828</name></author><category term="cicd" /><summary type="html">이번 글에서는 CI/CD 파이프라인 구축을 위한 서비스들이 무엇이 있는지 살펴보고, 다음과 같은 솔루션들의 장단점을 분석하고자 한다. Travis GitLab CI Jenkins</summary></entry><entry><title type="html">[Linux] 기본 설정으로 포트 확인하기</title><link href="https://owin2828.github.io/devlog/2020/01/08/etc-1.html" rel="alternate" type="text/html" title="[Linux] 기본 설정으로 포트 확인하기" /><published>2020-01-08T15:17:00+09:00</published><updated>2020-01-08T15:17:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/08/etc-1</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/08/etc-1.html">&lt;h2 id=&quot;외부-서버의-포트가-살아있는지-open여부를-점검하기&quot;&gt;외부 서버의 포트가 살아있는지 open여부를 점검하기&lt;/h2&gt;
&lt;p&gt;이런 저런 이유로, 명령어들을 사용할 수 없는 경우가 존재한다.&lt;br /&gt;
나도 원격 서버가 살아있는지 점검해야 하는데, host 서버에 telnet등이 지원하지 않아 고생한 경험이 있다.&lt;br /&gt;
이러한 경우를 대비해, 서버와 통신이 되는지 확인하는 명령어를 종류에 따라 정리해 보았다.&lt;br /&gt;
다음은 지극히 &lt;code class=&quot;highlighter-rouge&quot;&gt;주관적인&lt;/code&gt; (쉬운?) 순서대로 방법이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-ping&quot;&gt;1. Ping&lt;/h4&gt;
&lt;p&gt;포트고 뭐고 필요 없을 때&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ping&lt;/code&gt;은 port를 &lt;code class=&quot;highlighter-rouge&quot;&gt;사용하지 않는다&lt;/code&gt;.&lt;br /&gt;
이유는 TCP/IP 계층에서 사용되고, port가 사용되는 상위 계층인 TCP/UDP 와는 상관이 없기 때문이다.&lt;br /&gt;
즉, ping으로는 port 확인이 &lt;code class=&quot;highlighter-rouge&quot;&gt;불가능&lt;/code&gt;하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ping &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;IP]

// 예시
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ping 8.8.8.8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-telnet&quot;&gt;2. Telnet&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;특정&lt;/code&gt; port를 확인해야 할 경우&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;telnet &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;IP] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;PORT]  

// 예시
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;telnet 100.1.1.1 8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-ncnetcat&quot;&gt;3. nc(NetCat)&lt;/h4&gt;
&lt;p&gt;일반적으로 UNIX의 &lt;code class=&quot;highlighter-rouge&quot;&gt;cat&lt;/code&gt;명령과 비슷한 사용법 이지만, 대상이 파일이 아니라 network connection이다.&lt;br /&gt;
포트 확인 기능 말고도 다양한 기능으로 사용이 된다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nc &lt;span class=&quot;nt&quot;&gt;-z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;IP] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;PORT]

// 예시
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nc &lt;span class=&quot;nt&quot;&gt;-z&lt;/span&gt; 100.1.1.1 8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-curl&quot;&gt;4. curl&lt;/h4&gt;
&lt;p&gt;대부분 서버는 telnet이 설치되어 있지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;보안&lt;/code&gt;이슈나 &lt;code class=&quot;highlighter-rouge&quot;&gt;최소 설치&lt;/code&gt;를 한 경우 사용이 불가능한 경우가 있다.&lt;br /&gt;
그런 경우 다음의 명령을 사용하자. 아무리 최소 설치를 해도 curl은 설치되어 있기 때문이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt;의 parameter중 URL telnet 스키마를 사용하여 서버 통신 확인&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; telnet://[IP]:PORT  

// 예시
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; telnet://100.1.1.1:8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5-bash&quot;&gt;5. bash&lt;/h4&gt;
&lt;p&gt;약간 하드한 방법이다. 
&lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt;에 익숙하지 않은 사람들은 4번에서 끝내기를 권장한다.&lt;br /&gt;
TCP 연결을 간단하게 bash의 내장된 기능으로 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;timeout &lt;/span&gt;5 bash &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'cat &amp;lt; /dev/null &amp;gt; /dev/tcp/[IP]/[PORT]'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt;

// 예시
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;timeout &lt;/span&gt;5 bash &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'cat &amp;lt; /dev/null &amp;gt; /dev/tcp/100.1.1.1/8080'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$?&lt;/span&gt;
// 결과
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;0   // 성공 
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;1   // 실패 연결 전 에러&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;hostname &lt;/span&gt;not known등 오류&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;124 // 실패 Timeout 에러
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;echo $?&lt;/code&gt;는 UNIX에서 바로 전 실행의 결과를 보여주는 명령어이다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>owin2828</name></author><category term="etc" /><summary type="html">외부 서버의 포트가 살아있는지 open여부를 점검하기 이런 저런 이유로, 명령어들을 사용할 수 없는 경우가 존재한다. 나도 원격 서버가 살아있는지 점검해야 하는데, host 서버에 telnet등이 지원하지 않아 고생한 경험이 있다. 이러한 경우를 대비해, 서버와 통신이 되는지 확인하는 명령어를 종류에 따라 정리해 보았다. 다음은 지극히 주관적인 (쉬운?) 순서대로 방법이다.</summary></entry><entry><title type="html">[CI/CD] 그래서 CI/CD가 뭔데?</title><link href="https://owin2828.github.io/devlog/2020/01/08/cicd-4.html" rel="alternate" type="text/html" title="[CI/CD] 그래서 CI/CD가 뭔데?" /><published>2020-01-08T14:12:00+09:00</published><updated>2020-01-08T14:12:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/08/cicd-4</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/08/cicd-4.html">&lt;h2 id=&quot;드디어&quot;&gt;드디어&lt;/h2&gt;
&lt;p&gt;CI/CD까지 도착하여 포스팅을 하게 되었다.&lt;br /&gt;
긴 시간이었고, 나 또한 그동안 배우고 겪었던 것들을 글로 풀어내느라 시간을 꽤 썼다.&lt;br /&gt;
인터넷을 찾아보면 CI/CD에 관련된 수 많은 자료가 나오므로, 자세한 설명보다는 내가 배우고 느낀대로 적어보겠다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;CI/CD라는 단어를 사용하기 전에 우리는 &lt;code class=&quot;highlighter-rouge&quot;&gt;왜&lt;/code&gt; CI/CD를 적용해야 하는가를 생각해야 한다.&lt;br /&gt;
앞선 글 &lt;a href=&quot;https://owin2828.github.io/devlog/2020/01/07/cicd-1.html&quot;&gt;DevOps란 무엇인가?&lt;/a&gt;에서 설명했듯이,&lt;br /&gt;
고객에게 가치를 빠르고 안정적으로 전달하는 것이 DevOps의 목적이고, 이를 위해 CI/CD를 활용하는 것이다.&lt;/p&gt;

&lt;p&gt;더 상세한 설명을 하기 전에,&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;CI&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;지속적인 통합&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;자동화&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;CD&lt;/code&gt; = &lt;code class=&quot;highlighter-rouge&quot;&gt;지속적인 배포&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;자동화&lt;/code&gt;&lt;br /&gt;
개발 -&amp;gt; CI -&amp;gt; CD 순으로 Flow가 진행됨을 먼저 알고가면 좋을 것 같다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ci--cd&quot;&gt;CI / CD&lt;/h2&gt;
&lt;figure&gt;
&lt;p&gt;&lt;img src=&quot;/img/cicd/cicd_4_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;figcaption&gt;출처: &lt;a href=&quot;https://dzone.com/articles/the-complete-introduction-to-cicd-1&quot;&gt;https://dzone.com/articles/the-complete-introduction-to-cicd-1&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;인터넷을 찾아보면 수 많은 &lt;code class=&quot;highlighter-rouge&quot;&gt;CI/CD&lt;/code&gt; pipe-line 관련 이미지가 나온다.&lt;br /&gt;
그 중 위 이미지는 가장 간략하고 정확하게 CI/CD의 개요에 대해 설명하는 그림인것 같아 가져와봤다.&lt;/p&gt;

&lt;p&gt;이 중, 개발자가 &lt;code class=&quot;highlighter-rouge&quot;&gt;혼자서&lt;/code&gt; 진행하는 부분은 CI, CD 파이프라인 중 어디에도 속하지 않는다.&lt;br /&gt;
다시 말해서 CI/CD의 파이프라인을 태운다는 것은 &lt;code class=&quot;highlighter-rouge&quot;&gt;협업&lt;/code&gt;을 기반으로 한다는 의미이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;물론 규모가 작아 혼자서도 CI/CD 파이프 라인을 구축할 수도 있다.&lt;br /&gt;
하지만 CI/CD 파이프라인의 극적인 효율은 협업을 할 때 나오게 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;ci--continuous-integration&quot;&gt;CI = Continuous Integration&lt;/h5&gt;
&lt;p&gt;CI는 개발자들의 코드를 지속적, 자동적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;빌드&lt;/code&gt;하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;단위테스트&lt;/code&gt;를 거치며, &lt;code class=&quot;highlighter-rouge&quot;&gt;통합테스트&lt;/code&gt;를 하는 과정이다.&lt;br /&gt;
CI의 파이프라인이 구축되어 있지 않은 극적인 상황을 생각해 보자.&lt;/p&gt;

&lt;p&gt;10명의 개발자가 &lt;code class=&quot;highlighter-rouge&quot;&gt;각자&lt;/code&gt; 빌드 후, 유닛테스트를 하고 통합테스트를 진행한다.&lt;br /&gt;
문제는 &lt;code class=&quot;highlighter-rouge&quot;&gt;단위테스트&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;통합테스트&lt;/code&gt;를 하는 시점이 모두에게 동일하고 명확하게 정의되기가 어렵다는 점이다.&lt;br /&gt;
만약, 10명의 개발자가 각자 개발 후 통합테스트를 한 번에 진행한다면…?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;상상은 각자의 몫이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;CI&lt;/code&gt;를 적용해서 각 개발자들 간의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ground Rule&lt;/code&gt;을 다음과 같이 세웠다고 생각해보자.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 개발자들은 퇴근 전 각자의 코드를 Main 코드와 통합한다.&lt;/li&gt;
  &lt;li&gt;각자의 코드가 잘 동작하는지 테스트한다.&lt;/li&gt;
  &lt;li&gt;통합테스트를 진행한다.&lt;/li&gt;
  &lt;li&gt;버그가 발견된다면, To-Do 목록에 작성하고 다음 날 업무를 수행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CI를 적용하기 전 상황보다는 효율적이고 소스코드의 관리도 훨씬 잘 될 것이다.&lt;br /&gt;
하지만 글을 쓰면서도 위의 모든 과정이 너무나도 &lt;code class=&quot;highlighter-rouge&quot;&gt;귀찮다&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;당신이 개발자라면 위와 같은 과정을 &lt;code class=&quot;highlighter-rouge&quot;&gt;수작업&lt;/code&gt;으로 하겠는가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;누군가가 나 대신 빌드와 테스트들을 해주고 버그를 기록해준다면 얼마나 좋을까.&lt;br /&gt;
그래서 CI/CD 파이프라인에는 필연적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;자동화&lt;/code&gt;가 포함이 된다.&lt;br /&gt;
자동화가 적용된 위의 WorkFlow는 다음과 같이 간소화 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;퇴근 전 각자의 코드를 Main 코드와 통합한다.&lt;/li&gt;
  &lt;li&gt;다음날 출근 후, 버그 리포팅을 기반으로 코드를 수정한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;개발자들이 &lt;code class=&quot;highlighter-rouge&quot;&gt;게을러야&lt;/code&gt; 하는 이유가 단적으로 드러나지 않는가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;cd--continuous-deploydelivery&quot;&gt;CD = Continuous Deploy/Delivery&lt;/h5&gt;
&lt;p&gt;CD는 개발된 SW가 배포되는 시점에 신뢰할 수 있는 수준을 유지하도록 지속적으로 관리하는 것이다.&lt;br /&gt;
CI의 &lt;code class=&quot;highlighter-rouge&quot;&gt;연장선&lt;/code&gt;상에 있으며, 이상적으로는 CI가 지속적/자동적으로 이루어진다면,&lt;br /&gt;
CD 또한 지속적/자동적으로 이루어질 수밖에 없다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;실제로 CI/CD 파이프 라인을 구축해서 배포를 해본다면, 얼마나 효율적인지 알 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;이론은&quot;&gt;이론은&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;별거없다&lt;/code&gt;. CI/CD의 등장배경과 특징 및 장점을 살펴보았지만, 이해하기 어려운 개념은 아니다.&lt;br /&gt;
하지만 실제로 CI/CD 자동화 파이프라인을 구축하기 위해서는 많은 &lt;code class=&quot;highlighter-rouge&quot;&gt;삽질&lt;/code&gt;이 필요하다.&lt;br /&gt;
어떤 프로세스를 언제 어떻게 적용하고, 결과는 어떤 방법으로 처리할지 등이 고려되어야 한다.&lt;/p&gt;

&lt;p&gt;바닥부터 구축하라고하면 차라리 안하는게 나을수도 있지만, 역시 누군가가 만들어놓은 솔루션이 있다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Jenkins&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Travis&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;GitLabCI&lt;/code&gt; 등의 CI 서버가 있고 각 솔루션의 장단점을 분석한 후에 단계별 Stage의 tool들을 살펴보러가겠다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dzone.com/articles/the-complete-introduction-to-cicd-1&quot;&gt;https://dzone.com/articles/the-complete-introduction-to-cicd-1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.redhat.com/ko/topics/devops/what-is-ci-cd&quot;&gt;https://www.redhat.com/ko/topics/devops/what-is-ci-cd&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://itholic.github.io/qa-cicd/&quot;&gt;https://itholic.github.io/qa-cicd/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>owin2828</name></author><category term="cicd" /><summary type="html">드디어 CI/CD까지 도착하여 포스팅을 하게 되었다. 긴 시간이었고, 나 또한 그동안 배우고 겪었던 것들을 글로 풀어내느라 시간을 꽤 썼다. 인터넷을 찾아보면 CI/CD에 관련된 수 많은 자료가 나오므로, 자세한 설명보다는 내가 배우고 느낀대로 적어보겠다.</summary></entry><entry><title type="html">[CI/CD] Scrum? Agile?</title><link href="https://owin2828.github.io/devlog/2020/01/07/cicd-3.html" rel="alternate" type="text/html" title="[CI/CD] Scrum? Agile?" /><published>2020-01-07T16:03:00+09:00</published><updated>2020-01-07T16:03:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/07/cicd-3</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/07/cicd-3.html">&lt;h2 id=&quot;scrum이란&quot;&gt;Scrum이란&lt;/h2&gt;
&lt;p&gt;Scrum은 그 자체로 하나의 &lt;code class=&quot;highlighter-rouge&quot;&gt;방법론&lt;/code&gt;이자, Agile의 &lt;code class=&quot;highlighter-rouge&quot;&gt;실천 도구&lt;/code&gt; 중 하나이다.&lt;br /&gt;
이 말은, Agile로부터 Scrum이 등장한 것이 아니라는 이야기이다.&lt;br /&gt;
다른 실천 도구들(칸반, XP - extreme programming, 린SW개발)등은 Agile이라는 용어 정의 전에 이미 여러 형태로 존재하였다.&lt;br /&gt;
이후  Agile 선언문이 발표되며 이러한 방법들이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Agile&lt;/code&gt; 이라는 깃발 아래 모여들었고, 그 중 우리에게 익숙한 것이 Scrum이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;결국 스크럼은 &lt;code class=&quot;highlighter-rouge&quot;&gt;작은&lt;/code&gt; 개발팀, &lt;code class=&quot;highlighter-rouge&quot;&gt;짧은&lt;/code&gt; 개발 주기 및 팀원들의 &lt;code class=&quot;highlighter-rouge&quot;&gt;생산성&lt;/code&gt;을 유지시켜 SW개발을 하는 대표적인 Agile 방법론이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;scrum의-특징&quot;&gt;Scrum의 특징&lt;/h2&gt;
&lt;p&gt;다음 특징들로 Scrum을 정의할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로젝트 관리: &lt;code class=&quot;highlighter-rouge&quot;&gt;역할&lt;/code&gt;, 정의에 중점&lt;/li&gt;
  &lt;li&gt;시간 설정: &lt;code class=&quot;highlighter-rouge&quot;&gt;15분&lt;/code&gt;의 Daily Meeting, 1~4주 정도의 개발주기&lt;/li&gt;
  &lt;li&gt;관리체계: &lt;code class=&quot;highlighter-rouge&quot;&gt;요구사항(BackLog)&lt;/code&gt;관리, 업무 진행 가시화&lt;/li&gt;
  &lt;li&gt;팀 중심: &lt;code class=&quot;highlighter-rouge&quot;&gt;5~9명&lt;/code&gt;으로 팀 구성, 본인 task보다 급한 task를 &lt;code class=&quot;highlighter-rouge&quot;&gt;우선&lt;/code&gt;시&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;이러한 특성은 &lt;code class=&quot;highlighter-rouge&quot;&gt;유연하게&lt;/code&gt; 개발하기에 최적화 되어있는데, 특히 팀원의 수는 피자 한 판을 시켰을 때 나눠먹기 좋은 인원이라고 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;스크럼의-5가지-가치&quot;&gt;스크럼의 5가지 가치&lt;/h2&gt;
&lt;figure&gt;
&lt;p&gt;&lt;img src=&quot;/img/cicd/cicd_3_1.png&quot; alt=&quot;&quot; width=&quot;85%&quot; height=&quot;85%&quot; /&gt;&lt;/p&gt;
  &lt;figcaption&gt;출처: &lt;a href=&quot;https://www.scrum.org/resources/blog/5-scrum-values-take-center-stage&quot;&gt;https://www.scrum.org/resources/blog/5-scrum-values-take-center-stage&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;항상 이러한 가치를 볼 때 손과 발이 없어지는 경험을 하지만, 그래도 정의해 보도록 한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Courage(용기): &lt;code class=&quot;highlighter-rouge&quot;&gt;갈등&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;도전&lt;/code&gt;을 통해 일을 할 수 있는 용기&lt;/li&gt;
  &lt;li&gt;Focus(집중): 모두가 스프린트동안 &lt;code class=&quot;highlighter-rouge&quot;&gt;같은&lt;/code&gt; 목표를 향해 나아가는 것&lt;/li&gt;
  &lt;li&gt;Commitment(확약): 세운 목표를 &lt;code class=&quot;highlighter-rouge&quot;&gt;실행&lt;/code&gt;하는 것&lt;/li&gt;
  &lt;li&gt;Respect(존중): 팀원간 다른 객체임을 인정하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;존중&lt;/code&gt;하는 것&lt;/li&gt;
  &lt;li&gt;Openess(정직): 업무상태를 &lt;code class=&quot;highlighter-rouge&quot;&gt;공개&lt;/code&gt;하고, 일의 효율성을 높이는 것&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;일할 때 기본적으로 너무 당연한 자세 아닌가 싶지만, 실제로 스크럼을 해보면…&lt;br /&gt;
특히 한국인의 수직적인 정서상, 팀원 간의 &lt;code class=&quot;highlighter-rouge&quot;&gt;존중&lt;/code&gt;이 가장 어려운부분인것 같다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;scrum-process&quot;&gt;Scrum Process&lt;/h2&gt;
&lt;figure&gt;
&lt;p&gt;&lt;img src=&quot;/img/cicd/cicd_3_2.jpg&quot; alt=&quot;&quot; width=&quot;85%&quot; height=&quot;85%&quot; /&gt;&lt;/p&gt;
  &lt;figcaption&gt;출처: &lt;a href=&quot;https://brainhub.eu/blog/differences-lean-agile-scrum/&quot;&gt;https://brainhub.eu/blog/differences-lean-agile-scrum/&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Scrum 진행은 Broduct Backlog에서 한 Sprint에 수행할 작업들을 &lt;code class=&quot;highlighter-rouge&quot;&gt;도출&lt;/code&gt;한 뒤, 
매일 이루어지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Daily scrum&lt;/code&gt;을 통해 팀원들의 업무 진척 상황을 공유하고 필요시 &lt;code class=&quot;highlighter-rouge&quot;&gt;지원&lt;/code&gt;을 하는 방식으로 이루어진다.&lt;br /&gt;
해당 Sprint가 끝나면 Sprint &lt;code class=&quot;highlighter-rouge&quot;&gt;리뷰&lt;/code&gt;를 통해 다음 Sprint의 완급을 조절하며 이 과정을 &lt;code class=&quot;highlighter-rouge&quot;&gt;반복&lt;/code&gt;한다.&lt;/p&gt;

&lt;p&gt;각 단계별 &lt;code class=&quot;highlighter-rouge&quot;&gt;구성요소&lt;/code&gt;는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Product Backlog: &lt;code class=&quot;highlighter-rouge&quot;&gt;전체&lt;/code&gt; 기간동안 개발해야하는 기능, 특성 및 기술에 대한 나열. 요구사항의 &lt;code class=&quot;highlighter-rouge&quot;&gt;우선순위&lt;/code&gt; 나열 필수&lt;/li&gt;
  &lt;li&gt;Sprint Planning Meeting: 해당 스프린트의 기간, 수행해야할 목록등 해당 스프린트 &lt;code class=&quot;highlighter-rouge&quot;&gt;계획&lt;/code&gt; 수립&lt;/li&gt;
  &lt;li&gt;Sprint Backlog: 해당 Sprint 기간 동안 수행하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Task 목록&lt;/code&gt;. Product Backlog에서 우선순위순으로 선택&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scrum에서는 각 구성원이 주어진 역할을 잘 해내는것이 중요한데, 구성원들은 다음의 역할 중 하나를 따르게 된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Product Owner(PO):
    &lt;ul&gt;
      &lt;li&gt;고객, 관리자 및 팀원 간의 합의를 도출해 &lt;code class=&quot;highlighter-rouge&quot;&gt;목표&lt;/code&gt; 설정&lt;/li&gt;
      &lt;li&gt;요구사항 정의, Product Backlog 간의 &lt;code class=&quot;highlighter-rouge&quot;&gt;우선순위&lt;/code&gt; 조정&lt;/li&gt;
      &lt;li&gt;Product Backlog &lt;code class=&quot;highlighter-rouge&quot;&gt;업데이트&lt;/code&gt; 수행&lt;/li&gt;
      &lt;li&gt;제품을 사용할 고객이 &lt;code class=&quot;highlighter-rouge&quot;&gt;직접&lt;/code&gt; 하거나, 비지니스 요구사항을 &lt;code class=&quot;highlighter-rouge&quot;&gt;정의&lt;/code&gt;할 수 있는 사람&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Scrum Master(SM):
    &lt;ul&gt;
      &lt;li&gt;팀원들이 Scrum을 올바르게 할 수 있도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;가이드&lt;/code&gt;하는 역할&lt;/li&gt;
      &lt;li&gt;최대한 &lt;code class=&quot;highlighter-rouge&quot;&gt;객관적인&lt;/code&gt; 시각에서 Scrum의 원칙이 잘 적용될 수 있도록 도움&lt;/li&gt;
      &lt;li&gt;문제 발생시, &lt;code class=&quot;highlighter-rouge&quot;&gt;해결&lt;/code&gt;하는 역할&lt;/li&gt;
      &lt;li&gt;일이 끝났을 때, 잘 끝났는지 확인&lt;/li&gt;
      &lt;li&gt;직책에 &lt;code class=&quot;highlighter-rouge&quot;&gt;상관없이&lt;/code&gt; 수행 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Scrum Team:
    &lt;ul&gt;
      &lt;li&gt;Backlog에 따라 Sprint 동안 개발하는 팀원&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cross-functional&lt;/code&gt;한 롤을 가진 팀원들로 구성(개발자, 디자이너, 설계자 등)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 외 산출물로써는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Burn Down Chart&lt;/code&gt;가 존재하며, 각 Task별로 작업량을 측정한 뒤 작업량의 총 합에서 완료한 Task들의 작업량을 빼가며 
그래프의 하강 기울기를 통해 다음 Sprint의 진행을 조절한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;기존의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Top-Down&lt;/code&gt;방식과는 달리 Scrum에는 PM과 같은 직책이 존재하지 않는다.&lt;br /&gt;
그저 서로간의 &lt;code class=&quot;highlighter-rouge&quot;&gt;존중&lt;/code&gt;을 바탕으로 팀원간의 소통과 협업을 최대로 이끌어내며 일하는 것이 목표이며,&lt;br /&gt;
Scrum Master는 권력자나 리더가 아니라 그저 &lt;code class=&quot;highlighter-rouge&quot;&gt;조력자&lt;/code&gt;에 불과한 직책으로 늘 팀원들에게 귀기울이며 의견을 들어야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;또한, 실제로 Scrum을 하다보면 Daily meeting이 서로 간의 감시와 업무 보고의 연장선이라고 느낄 수 있다.&lt;br /&gt;
하지만 Scrum Master가 팀원들을 강압적으로 압박하지 않고, Daily meeting의 목적이 &lt;code class=&quot;highlighter-rouge&quot;&gt;우선순위&lt;/code&gt;에 따라 Task를 수행하며 
우선순위가 높은 Task에 &lt;code class=&quot;highlighter-rouge&quot;&gt;도움&lt;/code&gt;이 필요하다면, 자발적으로 팀원들이 본인의 Task를 제쳐두고 도움을 주는 것임을 팀원들이 숙지하도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;도와주는&lt;/code&gt; 것이 중요하다.  &lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://brunch.co.kr/@insuk/13&quot;&gt;https://brunch.co.kr/@insuk/13&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://needjarvis.tistory.com/317&quot;&gt;https://needjarvis.tistory.com/317&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>owin2828</name></author><category term="cicd" /><summary type="html">Scrum이란 Scrum은 그 자체로 하나의 방법론이자, Agile의 실천 도구 중 하나이다. 이 말은, Agile로부터 Scrum이 등장한 것이 아니라는 이야기이다. 다른 실천 도구들(칸반, XP - extreme programming, 린SW개발)등은 Agile이라는 용어 정의 전에 이미 여러 형태로 존재하였다. 이후 Agile 선언문이 발표되며 이러한 방법들이 Agile 이라는 깃발 아래 모여들었고, 그 중 우리에게 익숙한 것이 Scrum이다.</summary></entry><entry><title type="html">[CI/CD] DevOps란 무엇인가?</title><link href="https://owin2828.github.io/devlog/2020/01/07/cicd-1.html" rel="alternate" type="text/html" title="[CI/CD] DevOps란 무엇인가?" /><published>2020-01-07T10:31:00+09:00</published><updated>2020-01-07T10:31:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/07/cicd-1</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/07/cicd-1.html">&lt;p&gt;&lt;img src=&quot;/img/cicd/cicd_1_1.png&quot; alt=&quot;DevOps&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;devops-등장배경&quot;&gt;DevOps 등장배경&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;DevOps = &lt;code class=&quot;highlighter-rouge&quot;&gt;Development&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;Operations&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;하나의 소프트웨어를 개발하기 위해 여러 개발자가 동시에 &lt;code class=&quot;highlighter-rouge&quot;&gt;협업&lt;/code&gt;하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;빠르게&lt;/code&gt; 개발할 수 있는 환경이 필요하며, 
수많은 사용자를 상대로 서비스를 오픈하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;안정적인&lt;/code&gt; 인프라가 필요하다.&lt;br /&gt;
이러한 모순되는 두 가지, &lt;code class=&quot;highlighter-rouge&quot;&gt;신속함&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;안정성&lt;/code&gt;에서 개발자와 운영자간의 &lt;code class=&quot;highlighter-rouge&quot;&gt;충돌&lt;/code&gt;이 발생하게 된다.&lt;/p&gt;

&lt;p&gt;이러한 배경에서 등장하게 된 것이 &lt;code class=&quot;highlighter-rouge&quot;&gt;DevOps&lt;/code&gt;이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;자동화&lt;/code&gt;를 핵심으로 두 역할 간의 간극을 좁히게 해주며,&lt;br /&gt;
업무와 정보 또한 쉽게 공유하게 해준다. 더이상 통합 빌드를 특정 시점에 진행하는 것이 아니라,&lt;br /&gt;
주기적으로 수행하며 오류를 사전에 방지하고 시간을 단축한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;devops-핵심요소&quot;&gt;DevOps 핵심요소&lt;/h2&gt;
&lt;p&gt;DevOps의 핵심요소는 &lt;code class=&quot;highlighter-rouge&quot;&gt;CALMS&lt;/code&gt;로 다음과 같은 5가지 요소로 이루어져있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Culture(문화)&lt;/li&gt;
  &lt;li&gt;Automation(자동화)&lt;/li&gt;
  &lt;li&gt;Lean(간소화)&lt;/li&gt;
  &lt;li&gt;Measurement(측정)&lt;/li&gt;
  &lt;li&gt;Share(공유)&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;culture문화&quot;&gt;Culture(문화)&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;DevOps 문화 = &lt;code class=&quot;highlighter-rouge&quot;&gt;협업&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;DevOps의 문화는 도구의 문제가 아니라, 사람 간의 문제를 해결하기 위해 등장했다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;automation자동화&quot;&gt;Automation(자동화)&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;개발, 테스트 및 배포의 &lt;code class=&quot;highlighter-rouge&quot;&gt;핵심&lt;/code&gt;요소&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자동화를 통해 막대한 이익을 얻을 수 있으며, 이는 곧 &lt;code class=&quot;highlighter-rouge&quot;&gt;CI(지속적인 통합)&lt;/code&gt;과  &lt;code class=&quot;highlighter-rouge&quot;&gt;CD(지속적인 배포)&lt;/code&gt;로 구성된다.&lt;br /&gt;
또한 개발자와 운영자가 서로 업데이트한 내용을 자동화하여 확인함으로써, 즉각적인 소통을 가능하게 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;lean간소화&quot;&gt;Lean(간소화)&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;낭비를 &lt;code class=&quot;highlighter-rouge&quot;&gt;제거&lt;/code&gt;하고 고객에게 가치를 &lt;code class=&quot;highlighter-rouge&quot;&gt;빠르게&lt;/code&gt; 전달&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;끊임없이 문제를 찾고, 해결하고, 개선하는 사고방식을 의미한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;measurement측정&quot;&gt;Measurement(측정)&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;여러가지를 &lt;code class=&quot;highlighter-rouge&quot;&gt;측정&lt;/code&gt;하고, 측정 결과를 &lt;code class=&quot;highlighter-rouge&quot;&gt;가시화&lt;/code&gt;하여 보여줌&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;실질적인 데이터를 가시화하여 제공하므로써, 지속적인 개선을 향한 노력이 실제 개선으로 나아가는지 확인 가능하다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;share공유&quot;&gt;Share(공유)&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;성공 여부와 상관없이 서로의 &lt;code class=&quot;highlighter-rouge&quot;&gt;경험&lt;/code&gt;을 공유&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서로 경험을 공유함으로써, 마찰을 줄이고 서로 간의 경계를 허무는 발판이 된다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.atlassian.com/ko/devops&quot;&gt;https://www.atlassian.com/ko/devops&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.redhat.com/ko/topics/devops#?&quot;&gt;https://www.redhat.com/ko/topics/devops#?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://devops.com/using-calms-to-assess-organizations-devops/&quot;&gt;https://devops.com/using-calms-to-assess-organizations-devops/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>owin2828</name></author><category term="cicd" /><summary type="html"></summary></entry></feed>