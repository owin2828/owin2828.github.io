<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://owin2828.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://owin2828.github.io/" rel="alternate" type="text/html" /><updated>2020-10-19T16:08:43+09:00</updated><id>https://owin2828.github.io/feed.xml</id><title type="html">낮코밤코</title><subtitle>Already done, cause will do</subtitle><author><name>owin2828</name></author><entry><title type="html">[PSQL]PostgreSQL 설치 및 data 저장 위치 변경</title><link href="https://owin2828.github.io/devlog/2020/10/19/etc-8.html" rel="alternate" type="text/html" title="[PSQL]PostgreSQL 설치 및 data 저장 위치 변경" /><published>2020-10-19T13:29:00+09:00</published><updated>2020-10-19T13:29:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/10/19/etc-8</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/10/19/etc-8.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;본 문서에서는 PSQL CentOS 7 설치 및 Data directory 변경 방법에 대하여 기술한다.
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;psql-설치&quot;&gt;PSQL 설치&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;설치
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;yum &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;postgresql94-server postgresql94-contrib
 &lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt; /usr/pgsql-9.4/bin/postgresql94-setup initdb
 &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;postgresql-9.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;기동
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl start postgresql-9.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;psql-기본-설정&quot;&gt;PSQL 기본 설정&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;listen 변경
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 설정파일 - /var/lib/pgsql/9.4/data/postgresql.conf
 org
 #listen_address = 'localhost'
 change
 listen_address = '*'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;권한 변경
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 설정파일 - /var/lib/pgsql/9.4/data/pg_hba.conf
 org
 local   all             all                        peer
 host    all             all    127.0.0.1/32        trust
 change
 local   all             all                        trust
 host    all             all             0.0.0.0/0            trust
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;psql-data-directory-변경&quot;&gt;PSQL DATA DIRECTORY 변경&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;현재 data directory 확인
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sudo -iu postgres
 postgres=# show data_directory;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;db 중지
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sudo systemctl stop postgresql-9.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;db 설정 파일 수정
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 설정파일 - /var/lib/pgsql/9.4/data/postmaster.opts
 /user/pgsql-9.4/bin/postgres &quot;-D&quot; &quot;&amp;lt;&amp;lt;to directory&amp;gt;&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스 설정 파일 수정
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 설정파일 - /etc/lib/systemd/system/postgresql-9.4.service
 Environment=PGDATA=&amp;lt;&amp;lt;to directory&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;기존 데이터 복사
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nb&quot;&gt;mv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt; directory&amp;gt;&amp;gt; &amp;lt;&amp;lt;to directory&amp;gt;&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스 재시작
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; systemctl daemon-reload
 systemctl start postgresql-9.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;현재 data directory 확인 (1번방법)&lt;/li&gt;
&lt;/ol&gt;</content><author><name>owin2828</name></author><category term="etc" /><summary type="html">들어가기 앞서 본 문서에서는 PSQL CentOS 7 설치 및 Data directory 변경 방법에 대하여 기술한다.</summary></entry><entry><title type="html">[Thanos]프로메테우스의 스케일링 tool</title><link href="https://owin2828.github.io/devlog/2020/03/13/etc-7.html" rel="alternate" type="text/html" title="[Thanos]프로메테우스의 스케일링 tool" /><published>2020-03-13T18:19:00+09:00</published><updated>2020-03-13T18:19:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/03/13/etc-7</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/03/13/etc-7.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;프로메테우스&lt;/code&gt;는 좋은 모니터링 툴이지만, 앞선 글에서 언급했듯이 클러스터링 구조를 지원하지 않기 때문에 다음과 같은 결정적인 두 가지 &lt;code class=&quot;highlighter-rouge&quot;&gt;문제점&lt;/code&gt;을 지닌다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;확장성의 어려움&lt;/li&gt;
  &lt;li&gt;가용성의 어려움&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;확장성&lt;/code&gt;의 문제는 디스크를 사서 붙이는 것으로 어느 정도 해결이된다. 
하지만 데이터의 양이 방대해지고 많아질 경우, 이러한 방식으로 매 번 증축할 수 없고 결국 하나의 프로메테우스 인스턴스로는 감당이 되지 않는 &lt;code class=&quot;highlighter-rouge&quot;&gt;문제&lt;/code&gt;가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_7_1.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;
이러한 문제를 해결하기 위해 프로메테우스에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Federation&lt;/code&gt;이라는 방법을 권장한다. 
프로메테우스 인스턴스를 여러개 만들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;Master-Slave&lt;/code&gt; 구로조 관리를 하여 계층적으로 관리를 하는 방법이다. 
약간은 지저분하고 또 복잡해 보이지만, 위의 구조를 사용함으로써 어느정도 보완이 되었다. 
하지만 여전히 이러한 구조는 단점을 지닌다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;가용성&lt;/code&gt;의 문제가 바로 그것인데, 프로메테우스는 기본적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;하나&lt;/code&gt;의 서버로 기동된다. 
따라서 실행중인 서버가 다운되거나 장애 및 재시작 등의 업무로 인해 생기는 공백의 기간동안은 메트릭을 수집할 수 &lt;code class=&quot;highlighter-rouge&quot;&gt;없다&lt;/code&gt;. 
클러스터링 기능이 존재하지 않기 때문에 이러한 문제점을 해결하기 위해서는 다음의 그림과 같이 프로메테우스 인스턴스를 &lt;code class=&quot;highlighter-rouge&quot;&gt;두 개&lt;/code&gt; 띄우고 같은 대상으로부터 메트릭을 수집해야 한다.&lt;br /&gt;
&lt;img src=&quot;/img/etc/etc_7_2.png&quot; alt=&quot;&quot; width=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;여전히 마음에 들지 않는다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-thanos란&quot;&gt;1. Thanos란&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;위와 같은 문제를 해결하기 위해 등장한 것이 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Thanos&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_7_3.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;
타노스의 기본 구조는 위와 같다. 여러개의 프로메테우스에서 메트릭 정보를 받아 &lt;code class=&quot;highlighter-rouge&quot;&gt;전체적인&lt;/code&gt; 정보를 제공해준다. 
또한 수집된 메트릭을 &lt;code class=&quot;highlighter-rouge&quot;&gt;스케일&lt;/code&gt;이 가능한 스토리지에 저장해서 특정 프로메테우스 인스턴스가 다운이 되더라도, 그 인스턴스가 담당하는 메트릭을 &lt;code class=&quot;highlighter-rouge&quot;&gt;조회&lt;/code&gt;할 수 있도록 해준다. 
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-thanos-아키텍처&quot;&gt;2. Thanos 아키텍처&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;타노스의 전반적인 이해를 돕기 위해 타노스의 아키텍처를 살펴본다.&lt;/p&gt;

&lt;h4 id=&quot;2-1-thanos-side-car--querier&quot;&gt;2-1. Thanos Side car &amp;amp; Querier&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/etc/etc_7_4.png&quot; alt=&quot;&quot; width=&quot;30%&quot; /&gt;
타노스는 프로메테우스 서버에 &lt;code class=&quot;highlighter-rouge&quot;&gt;타노스 에이전트(Thanos Sidecar)&lt;/code&gt;를 설치하여 데이터를 조회할 수 있도록 한다. 
프로메테우스는 수집된 메트릭 데이터를 로컬 디스크에 저장하기 때문에 타노스 에이전트는 디스크에 저장된 내용을 읽어 필요시 쿼리 엔진에게 전달한다. 
이러한 구조로 이루어져 있기 때문에 사용자가 관리하고 바라보는 것은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Thanos Query&lt;/code&gt; 하나로 줄어들게 된다.&lt;/p&gt;

&lt;h4 id=&quot;2-2-ha-지원&quot;&gt;2-2. HA 지원&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/etc/etc_7_5.png&quot; alt=&quot;&quot; width=&quot;30%&quot; /&gt;
타노스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;HA&lt;/code&gt;(High Availability, 서버 이중화)는 기존과 동일하다. 프로메테우스 인스턴스를 두 개 띄워서 같은 대상을 모니터링 하는 것이다. 
기존 방식에서는 프로메테우스 인스턴스를 각각 모니터링 해야하지만, 타노스는 특정 그룹의 프로메테우스 인스턴스들을 &lt;code class=&quot;highlighter-rouge&quot;&gt;하나로&lt;/code&gt; 처리해서 메트릭을 보여준다. 
즉, 두 인스턴스에서 수집된 메트릭을 &lt;code class=&quot;highlighter-rouge&quot;&gt;합쳐서&lt;/code&gt; 보여줄 수도 있고, &lt;code class=&quot;highlighter-rouge&quot;&gt;중복값을 제거&lt;/code&gt;해주는 De-duplication 기능을 지원한다.&lt;/p&gt;

&lt;h4 id=&quot;2-3-오래된-값-저장&quot;&gt;2-3. 오래된 값 저장&lt;/h4&gt;
&lt;p&gt;프로메테우스는 로컬에 데이터를 저장하기 때문에 일정 기간이 지난 데이터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;삭제&lt;/code&gt;된다. 따라서 기간이 오래된 데이터는 조회가 &lt;code class=&quot;highlighter-rouge&quot;&gt;불가능&lt;/code&gt;하다. 
이 문제는 여러 대의 프로메테우스를 모니터링하게 되므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;타노스에서도 발생&lt;/code&gt;하는데, 메모리와 로컬디스크의 용량 문제로 여러 프로메테우스 모니터링이 &lt;code class=&quot;highlighter-rouge&quot;&gt;불가능&lt;/code&gt;하게 된다. 
이를 해결하기 위해 타노스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;외부 스토리지&lt;/code&gt;를 사용한다.&lt;/p&gt;

&lt;p&gt;프로메테우스에서 수집된 데이터는 2시간 정도 메모리에 저장된 후, 로컬 디스크로 덤프되어 저장된다. 이 데이터를 &lt;code class=&quot;highlighter-rouge&quot;&gt;타노스 에이전트&lt;/code&gt;가 수집하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;외부 스토리지에 저장&lt;/code&gt;한다. 
외부 스토리지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ceph&lt;/code&gt;와 같은 분산형 파일 시스템 혹은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Google Cloud Storage&lt;/code&gt;, AWS &lt;code class=&quot;highlighter-rouge&quot;&gt;S3&lt;/code&gt;와 같은 클라우드 스토리지를 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_7_6.png&quot; alt=&quot;&quot; width=&quot;50%&quot; /&gt;
즉 쿼리 엔진에서 최근의 데이터를 조회할 때는 타노스 에이전트를 통해서 가져오고, 오래된 데이터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Thanos Sotrage Gateway&lt;/code&gt;를 통해 조회한다. 
이 게이트웨이는 외부 스토리지에 저장된 데이터를 &lt;code class=&quot;highlighter-rouge&quot;&gt;Storage API&lt;/code&gt;를 통해 쿼리 엔진과 통신하는 역할 및 &lt;code class=&quot;highlighter-rouge&quot;&gt;캐싱 기능&lt;/code&gt;을 제공한다.&lt;/p&gt;

&lt;p&gt;데이터가 많이 축적되게 되면, 오래된 데이터를 조회하는 경우 많은 양을 조회하기 때문에 성능에 문제가 발생한다. 
이러한 문제를 피하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;Compactor&lt;/code&gt;가 존재하는데, 데이터 파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;압축&lt;/code&gt;하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;다운 샘플링&lt;/code&gt;을 한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;다운 샘플링&lt;/code&gt;: 1분단위로 저장된 데이터를 10분이나 1시간 단위로 샘플링 기준을 낮춰서(해상도 낮춤) 전체 데이터 저장용량을 낮추는 방법&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;p&gt;본 포스팅은 &lt;a href=&quot;https://bcho.tistory.com/1372?category=731548&quot;&gt;조대협님의 블로그 글&lt;/a&gt;을 참조하여 학습용으로 작성된 글임을 밝힙니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://katacoda.com/bwplotka/courses/thanos&quot;&gt;katacoda 타노스 튜토리얼&lt;/a&gt;&lt;/p&gt;</content><author><name>owin2828</name></author><category term="etc" /><summary type="html">들어가기 앞서 프로메테우스는 좋은 모니터링 툴이지만, 앞선 글에서 언급했듯이 클러스터링 구조를 지원하지 않기 때문에 다음과 같은 결정적인 두 가지 문제점을 지닌다. 확장성의 어려움 가용성의 어려움</summary></entry><entry><title type="html">[Grafana]프로메테우스 &amp;amp; 그라파나 연동</title><link href="https://owin2828.github.io/devlog/2020/03/13/etc-6.html" rel="alternate" type="text/html" title="[Grafana]프로메테우스 &amp; 그라파나 연동" /><published>2020-03-13T17:29:00+09:00</published><updated>2020-03-13T17:29:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/03/13/etc-6</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/03/13/etc-6.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;프로메테우스&lt;/code&gt;가 메트릭의 정보를 가져오는 모니터링 툴이었다면, &lt;code class=&quot;highlighter-rouge&quot;&gt;그라파나&lt;/code&gt;는 가져온 메트릭 정보를 시각화 해주는 오픈소스 도구이다. 
그라파나는 다음과 같은 장점들로 인해 널리 사용되고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Graphite, Prometheus, InfluxDB등 &lt;code class=&quot;highlighter-rouge&quot;&gt;다양한&lt;/code&gt; 데이타베이스와 메트릭수집 시스템을 지원&lt;/li&gt;
  &lt;li&gt;하나의 대시보드에 동시에 &lt;code class=&quot;highlighter-rouge&quot;&gt;여러&lt;/code&gt; 메트릭 시스템들의 지표를 표시&lt;/li&gt;
  &lt;li&gt;설치 및 사용이 &lt;code class=&quot;highlighter-rouge&quot;&gt;쉬움&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;프로메테우스를 잘 &lt;code class=&quot;highlighter-rouge&quot;&gt;지원&lt;/code&gt;함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그라파나의 설치는 &lt;a href=&quot;https://grafana.com/docs/grafana/latest/installation/debian/&quot;&gt;공식문서&lt;/a&gt;를 따라 진행하면 된다. 
본 문서에서 이용한 환경은 이전 포스팅과 동일하게 katacoda에서 그라파나 듀토리얼을 사용한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.katacoda.com/courses/prometheus/creating-dashboards-with-grafana&quot;&gt;그라파나 듀토리얼&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-그라파나-설치-및-접속&quot;&gt;1. 그라파나 설치 및 접속&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;로그인 화면의 기본 ID/PW는 &lt;code class=&quot;highlighter-rouge&quot;&gt;amdin&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;admin&lt;/code&gt; 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;연동되었다면, &lt;code class=&quot;highlighter-rouge&quot;&gt;Add data source&lt;/code&gt;를 눌러 프로메테우스를 연결한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;본 문서에서는 프로메테우스를 localhost:9090에 실행중이므로, 사진과 같이 정보를 입력 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;savt &amp;amp; test&lt;/code&gt; 를 누른다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Create your first dashboard&lt;/code&gt;를 눌러 &lt;code class=&quot;highlighter-rouge&quot;&gt;Graph&lt;/code&gt;를 누르면 위와 같이 빈 그래프가 생성된다.&lt;/li&gt;
  &lt;li&gt;이때 &lt;code class=&quot;highlighter-rouge&quot;&gt;panel title&lt;/code&gt; 버튼을 눌러 메트릭을 추가한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사진과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Metrics&lt;/code&gt; 란에 &lt;code class=&quot;highlighter-rouge&quot;&gt;node_cpu&lt;/code&gt;를 입력하여 원하는 메트릭 정보를 입력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;그래프에 해당 메트릭이 표시되는 것을 알 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-그라파나-템플릿-사용&quot;&gt;2. 그라파나 템플릿 사용&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;그라파나의 장점은 이미 만들어진 다양한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Template&lt;/code&gt;이 존재한다는 것이다. 
사용자들이 다양한 템플릿을 만들어 공유하는데, 템플릿은 &lt;a href=&quot;https://grafana.com/dashboards/22&quot;&gt;https://grafana.com/dashboards/22&lt;/a&gt;에 가서 볼 수 있다. 
본 예제에서는 프로메테우스의 node_exporter에 의해 제공되는 템플릿을 import할 예정이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;상단의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node exporter single server&lt;/code&gt;를 클릭하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;Import Dashboard&lt;/code&gt;를 누른다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Json&lt;/code&gt; 파일로 템플릿을 저장할 수도 있지만, 제공하는 공식 탬플릿 중 ID:22 대시보드의 URL을 입력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;성공적으로 인식되었다면, 위의 사진과 같이 창이 변경되고 &lt;code class=&quot;highlighter-rouge&quot;&gt;prometheus&lt;/code&gt;란을 사진처럼 설정 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;Import&lt;/code&gt; 버튼을 누른다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_6_10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 과정이 완료되면 사진처럼 준비된 대시보드가 로딩되게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;p&gt;본 포스팅은 &lt;a href=&quot;https://bcho.tistory.com/1372?category=731548&quot;&gt;조대협님의 블로그 글&lt;/a&gt;을 참조하여 학습용으로 작성된 글임을 밝힙니다.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="etc" /><summary type="html">들어가기 앞서 프로메테우스가 메트릭의 정보를 가져오는 모니터링 툴이었다면, 그라파나는 가져온 메트릭 정보를 시각화 해주는 오픈소스 도구이다. 그라파나는 다음과 같은 장점들로 인해 널리 사용되고 있다.</summary></entry><entry><title type="html">[Prometheus]프로메테우스 개념 구조 및 quick start</title><link href="https://owin2828.github.io/devlog/2020/03/13/etc-5.html" rel="alternate" type="text/html" title="[Prometheus]프로메테우스 개념 구조 및 quick start" /><published>2020-03-13T16:09:00+09:00</published><updated>2020-03-13T16:09:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/03/13/etc-5</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/03/13/etc-5.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;프로메테우스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;오픈 소스&lt;/code&gt; 기반의 &lt;code class=&quot;highlighter-rouge&quot;&gt;모니터링&lt;/code&gt; 시스템이다. ELK 와 같은 로깅이 아니라, 대상 시스템으로 부터 각종 모니터링 지표를 수집하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;저장&lt;/code&gt;하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;검색&lt;/code&gt;할 수 있는 시스템이다. 구조가 간단해서 운영이 쉽고, 강력한 쿼리 기능을 가지고 있으며, 그라파나(Grafana) 를 통한 &lt;code class=&quot;highlighter-rouge&quot;&gt;시각화&lt;/code&gt;를 지원한다. 무엇보다 넓은 오픈 소스 생태계를 기반으로 해서, 많은 시스템을 모니터링할 수 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;다양한 플러그인&lt;/code&gt;을 가지고 있는 것이 가장 큰 장점이다. 특히 이런 간편함 때문에 특히나 &lt;code class=&quot;highlighter-rouge&quot;&gt;쿠버네티스&lt;/code&gt;의 메인 모니터링 시스템으로 많이 사용되면서 요즘 특히 더 주목을 받고 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-기본-구조&quot;&gt;1. 기본 구조&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/etc/etc_5_1.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;
&lt;img src=&quot;/img/etc/etc_5_2.png&quot; alt=&quot;&quot; width=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-1-metric-수집&quot;&gt;1-1. Metric 수집&lt;/h4&gt;
&lt;p&gt;수집을 하려는 대상 시스템이 Target system이다. MySQL이나, Tomcat 또는 VM 과 같이 여러가지 자원이 모니터링 대상이 될 수 있다. 이 대상 시스템에서 메트릭을 프로메테우스로 전송하기 위해서는 Exporter 라는 것을 사용한다.&lt;/p&gt;

&lt;h4 id=&quot;1-2-pulling-방식&quot;&gt;1-2. pulling 방식&lt;/h4&gt;
&lt;p&gt;프로메테우스가 Target System에서 메트릭을 수집하는 방식은 &lt;code class=&quot;highlighter-rouge&quot;&gt;풀링&lt;/code&gt; 방식을 사용한다. 프로메테우스가 주기적으로 Exporter로 부터 메트릭 읽어와서 수집하는 방식이다. 보통 모니터링 시스템의 에이전트 들은 에이전트가 모니터링 시스템으로 메트릭을 보내는 푸쉬 방식을 사용한다. 특히 푸쉬 방식은 서비스가 오토 스켈링등으로 가변적일 경우에 유리하다. 풀링 방식의 경우 모니터링 대상이 가변적으로 변경될 경우, 모니터링 대상의 IP 주소들을 알 수 가 없기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;어려운&lt;/code&gt; 점이 있다.&lt;/p&gt;

&lt;p&gt;이러한 문제를 해결하기 위한 방안이 &lt;code class=&quot;highlighter-rouge&quot;&gt;서비스 디스커버리&lt;/code&gt;라는 방식인데, 특정 시스템이 현재 기동중인 서비스들의 목록과 IP 주소를 가지고 있으면 된다. 예를 들어 앞에서 VM들을 내부 DNS에 등록해놓고 새로운 VM이 생성될때에도 DNS에 등록을 하도록 하면, DNS에서 현재 기동중인 VM 목록을 얻어와서 그 목록의 IP들로 풀링을 하면 되는 구조이다.&lt;/p&gt;

&lt;h4 id=&quot;1-3-service-discovery&quot;&gt;1-3. Service Discovery&lt;/h4&gt;
&lt;p&gt;프로메테우스도 서비스 디스커버리 시스템과 통합을 하도록 되어 있다. 앞에서 언급한 &lt;code class=&quot;highlighter-rouge&quot;&gt;DNS&lt;/code&gt;나, 서비스 디스커버리 전용 솔루션인 Hashicorp사의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Consul&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;쿠버네티스&lt;/code&gt;를 통해서, 모니터링해야할 타겟 서비스의 목록을 가지고 올 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;1-4-exporter&quot;&gt;1-4. Exporter&lt;/h4&gt;
&lt;p&gt;Exporter는 &lt;code class=&quot;highlighter-rouge&quot;&gt;모니터링 에이전트&lt;/code&gt;로 타겟 시스템에서 메트릭을 읽어서, 프로메테우스가 풀링을 할 수 있도록 한다. 또한, 단순히 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP GET&lt;/code&gt;으로 메트릭을 &lt;code class=&quot;highlighter-rouge&quot;&gt;텍스트&lt;/code&gt; 형태로 프로메테우스에 리턴한다. 요청 당시의 데이타를 리턴하는 것일뿐, Exporter 자체는 기존값(히스토리)를 저장하는 등의 기능은 없다.&lt;/p&gt;

&lt;h4 id=&quot;1-5-retrieval&quot;&gt;1-5. Retrieval&lt;/h4&gt;
&lt;p&gt;서비스 디스커버리 시스템으로 부터 모니터링 대상 목록을 받아오고, Exporter로 부터 주기적으로 그 대상으로 부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;메트릭을 수집&lt;/code&gt;하는 모듈이 프로메테우스내의 Retrieval 이라는 컴포넌트이다.&lt;/p&gt;

&lt;h4 id=&quot;1-6-저장&quot;&gt;1-6. 저장&lt;/h4&gt;
&lt;p&gt;이렇게 수집된 정보는 프로메테우스 내의 &lt;code class=&quot;highlighter-rouge&quot;&gt;메모리&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;로컬 디스크&lt;/code&gt;에 저장된다. 뒷단에 별도의 데이타 베이스등을 사용하지 않고, 그냥 로컬 디스크에 저장하는데, 그로 인해서 설치가 매우 쉽다는 장점이 있지만 반대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;스케일링이 불가능&lt;/code&gt;하다는 단점을 가지고 있다.  대상 시스템이 늘어날 수록 메트릭 저장 공간이 많이 필요한데, &lt;code class=&quot;highlighter-rouge&quot;&gt;단순히 디스크를 늘리는 방법&lt;/code&gt; 밖에 없다.&lt;/p&gt;

&lt;p&gt;프로메테우스는 구조상 HA를 위한 이중화나 클러스터링등이 &lt;code class=&quot;highlighter-rouge&quot;&gt;불가능&lt;/code&gt;하다. (클러스터링 대신 샤딩을 사용한다. HA는 복제가 아니라 프로메테우스를 두개를 띄워서 같은 타겟을 동시에 같이 저장 하는 방법을 사용한다. 이 문제에 대한 해결 방법은 Thanos 라는 오픈 소스를 사용하면 된다고 한다.)&lt;/p&gt;

&lt;h4 id=&quot;1-7-서빙&quot;&gt;1-7. 서빙&lt;/h4&gt;
&lt;p&gt;이렇게 저장된 메트릭은 &lt;code class=&quot;highlighter-rouge&quot;&gt;PromQL 쿼리&lt;/code&gt; 언어를 이용해서 조회가 가능하고, 이를 외부 API나 프로메테우스 웹콘솔을 이용해서 서빙이 가능하다. 또한 그라파나등과 통합하여 대쉬보드등을 구성하는 것이 가능하다.&lt;/p&gt;

&lt;p&gt;이 외에도 메트릭을 수집하기 위한 gateway, 알람을 위한 Alert manager 등의 컴포넌트등이 존재한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-장단점&quot;&gt;2. 장/단점&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;위의 내용을 기반으로 확장한 프로메테우스의 장/단점은 다음과 같다.&lt;/p&gt;

&lt;h4 id=&quot;2-1-장점&quot;&gt;2-1. 장점&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pull 방식&lt;/code&gt;의 구조를 채택함으로써, 모든 메트릭의 정보를 중앙 서버로 보내지 않아도 됨&lt;br /&gt;
대부분의 모니터링 구조는 push인데, 각 타겟 서버에서 부하가 걸릴 경우 push 방식은 fail point가 될 가능성이 있음&lt;/li&gt;
  &lt;li&gt;Kubernetes 환경에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;설치가 간단&lt;/code&gt;하고, grafana와의 연동을 통한 &lt;code class=&quot;highlighter-rouge&quot;&gt;운영이 쉽다&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;다양한 metric exporter 제공&lt;br /&gt;
Linux, Window등의 OS metric 뿐 아니라 각종 &lt;code class=&quot;highlighter-rouge&quot;&gt;Third-party&lt;/code&gt;의 exporter를 제공&lt;/li&gt;
  &lt;li&gt;장기간 데이터 유지와 확인&lt;br /&gt;
데이터 저장소가 &lt;code class=&quot;highlighter-rouge&quot;&gt;시계열 데이터&lt;/code&gt; 저장소로 구성되어있어, &lt;code class=&quot;highlighter-rouge&quot;&gt;많은&lt;/code&gt; 양의 정보를 &lt;code class=&quot;highlighter-rouge&quot;&gt;빠르게&lt;/code&gt; 검색 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-2-단점&quot;&gt;2-2. 단점&lt;/h4&gt;
&lt;p&gt;프로메테우스는 장점이 확실한 만큼 다음과 같이 단점도 확실하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_5_3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위의 그림처럼, 각 Region에 프로메테우스를 배치 한 뒤, 이를 Master에 Aggregate하는 방식이 프로메테우스가 공식적으로 권장하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;다중화&lt;/code&gt; 방식&lt;br /&gt;
즉 Clustering과는 거리가 &lt;code class=&quot;highlighter-rouge&quot;&gt;멈&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;싱글 호스트 아키텍처이기 때문에 저장용량이 부족하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;디스크 용량을 늘리는 것&lt;/code&gt; 밖에 방법이 없음&lt;/li&gt;
  &lt;li&gt;프로메테우스 서버가 다운되거나, 설정 변경 등을 위해서 재시작을 할 경우 그간의 metric은 &lt;code class=&quot;highlighter-rouge&quot;&gt;유실&lt;/code&gt;됨&lt;/li&gt;
  &lt;li&gt;일정 풀링 주기를 기반으로 metric을 가져오기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;풀링하는 순간&lt;/code&gt;의 스냅샷 정보만 알 수 있음&lt;br /&gt;
스냅샷의 연속된 모음이기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;근사값&lt;/code&gt;의 형태&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-hello-prometheus&quot;&gt;3. Hello Prometheus&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;프로메테우스를 이해하기 위해 간단한 테스트를 https://www.katacoda.com/ 에서 진행하였다.&lt;/p&gt;

&lt;h4 id=&quot;3-1-설정-파일-정의&quot;&gt;3-1. 설정 파일 정의&lt;/h4&gt;
&lt;p&gt;프로메테우스의 설정은 prometheus.yml 파일에 다음과 같이 정의한다.&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;global&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;scrape_interval&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;s&quot;&gt;15s&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;evaluation_interval&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;15s&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;scrape_configs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;job_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;prometheus'&lt;/span&gt;

    &lt;span class=&quot;na&quot;&gt;static_configs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;targets&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;127.0.0.1:9090'&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;127.0.0.1:9100'&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;prometheus'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;scrape_interval&lt;/code&gt;: 타겟시스템으로부터 메트릭을 읽어오는 주기&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;evaluation_interval&lt;/code&gt;: 읽어온 메트릭을 기반으로 alert를 보낼지 말지 판단하는 주기&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;scrap_configs&lt;/code&gt;: 데이터 수집 대상과 방법을 정의&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;job&lt;/code&gt;: 대상 그룹에서 메트릭을 수집해오는 내용을 정의&lt;br /&gt;
위의 경우, 127.0.0.1:9090과 127.0.0.1:9100으로 부터 메트릭을 수집하도록 job이 정의&lt;br /&gt;
앞 부분은 프로메테우스 시스템 자체의 케트릭, 두 번째는 프로메테우스가 기동괴고 있는 VM의 메트릭을 수집하도록 정의&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3-2-프로메테우스-서버와-node-exporter-기동&quot;&gt;3-2. 프로메테우스 서버와 node exporter 기동&lt;/h4&gt;
&lt;p&gt;설정이 끝난 후, 다음의 명령을 통해 간단하게 docker로 기동한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;host &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /root/prometheus.yml:/etc/prometheus/prometheus.yml &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; prometheus-server &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
     prom/prometheus
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로메테우스가 기동되면 다음의 명령으로 docker를 통해 node exporter를 설치해서 기동한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/proc:/host/proc&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/sys:/host/sys&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/:/rootfs&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;--net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;host&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;prometheus &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   quay.io/prometheus/node-exporter:v0.13.0 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;-collector&lt;/span&gt;.procfs /host/proc &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;-collector&lt;/span&gt;.sysfs /host/sys &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;-collector&lt;/span&gt;.filesystem.ignored-mount-points &lt;span class=&quot;s2&quot;&gt;&quot;^/(sys|proc|dev|host|etc)(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$|&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/)&quot;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;node exporter가 제대로 동작하는지 확인하기 위해, 다음의 명령을 통해 메트릭 정보를 얻는다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl https://&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;프로메테우스 서버 IP&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;:9100/metrics
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3-3-프로메테우스-dashboard-접속&quot;&gt;3-3. 프로메테우스 Dashboard 접속&lt;/h4&gt;
&lt;p&gt;프로메테우스와 exporter가 기동이 되었으면, 제대로 메트릭이 수집되는지 확인하기 위해 다음의 주소에 접속하여 대쉬보드를 확인한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;http://{프로메테우스 서버 ip}:9090 &lt;br /&gt;
검색 쿼리 부분에 메트릭 쿼리를 입력하면 그래프등의 형태로 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/etc/etc_5_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;p&gt;본 포스팅은 &lt;a href=&quot;https://bcho.tistory.com/1372?category=731548&quot;&gt;조대협님의 블로그 글&lt;/a&gt;을 참조하여 학습용으로 작성된 글임을 밝힙니다.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="etc" /><summary type="html">들어가기 앞서 프로메테우스는 오픈 소스 기반의 모니터링 시스템이다. ELK 와 같은 로깅이 아니라, 대상 시스템으로 부터 각종 모니터링 지표를 수집하여 저장하고 검색할 수 있는 시스템이다. 구조가 간단해서 운영이 쉽고, 강력한 쿼리 기능을 가지고 있으며, 그라파나(Grafana) 를 통한 시각화를 지원한다. 무엇보다 넓은 오픈 소스 생태계를 기반으로 해서, 많은 시스템을 모니터링할 수 있는 다양한 플러그인을 가지고 있는 것이 가장 큰 장점이다. 특히 이런 간편함 때문에 특히나 쿠버네티스의 메인 모니터링 시스템으로 많이 사용되면서 요즘 특히 더 주목을 받고 있다.</summary></entry><entry><title type="html">[Oauth] Oauth2.0의 4가지 인증 방식</title><link href="https://owin2828.github.io/devlog/2020/03/11/web-4.html" rel="alternate" type="text/html" title="[Oauth] Oauth2.0의 4가지 인증 방식" /><published>2020-03-11T16:30:00+09:00</published><updated>2020-03-11T16:30:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/03/11/web-4</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/03/11/web-4.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;지난 글에서 oauth2.0의 기초 및 구성에 대하여 알아보았다. 
이번 글에서는 실제로 다음과 같은 oauth2.0의 &lt;code class=&quot;highlighter-rouge&quot;&gt;인증 방식&lt;/code&gt;에 대하여 알아볼 예정이다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Authorization Code Grant Type&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Implicit Grant Type&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Resource Owner Password Credentials Grant Type&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Client Credentials Grant Type&lt;/code&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-authorization-code-grant-type&quot;&gt;1. Authorization Code Grant Type&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/web/web_2_1.png&quot; alt=&quot;Authorization Code Grant Type 방식&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;클라이언트는 리소스 주인이 권한 서버에게 Client ID, Redirect URI, Response_type을 code로 지정하여 전달하도록 유도&lt;br /&gt;
  인증이 된다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;code&lt;/code&gt;값을 돌려 받음&lt;/li&gt;
  &lt;li&gt;클라이언트는 전달 받은 &lt;code class=&quot;highlighter-rouge&quot;&gt;code&lt;/code&gt;를 사용해 필요한 정보들과 함께 access token 획득 요청을 권한서버에게 보냄&lt;/li&gt;
  &lt;li&gt;획득한 &lt;code class=&quot;highlighter-rouge&quot;&gt;access token&lt;/code&gt;을 사용해 리소스 서버에 사용자의 데이터를 요청&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-implicit-grant&quot;&gt;2. Implicit Grant&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/web/web_2_2.png&quot; alt=&quot;Implicit Grant 방식&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;클라이언트는 리소스 주인이 권한 서버에게 Client ID, Redirect URI, Response_type을 code로 지정하여 전달하도록 유도&lt;br /&gt;
  인증이 된다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;token&lt;/code&gt;을 돌려 받음&lt;/li&gt;
  &lt;li&gt;획득한 access token이 유요한지 &lt;code class=&quot;highlighter-rouge&quot;&gt;검증&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;검증에 대한 응답을 돌려줌&lt;/li&gt;
  &lt;li&gt;획득한 &lt;code class=&quot;highlighter-rouge&quot;&gt;access token&lt;/code&gt;을 사용해 리소스 서버에 사용자의 데이터를 요청&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;3-resource-owner-password-credentials-grant&quot;&gt;3. Resource Owner Password Credentials Grant&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/web/web_2_3.png&quot; alt=&quot;Resource Owner Password Credentials Grant 방식&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;리소스 주인이 인증을 진행, 대부분 ID/PW로 &lt;code class=&quot;highlighter-rouge&quot;&gt;자격증명&lt;/code&gt;을 수행&lt;/li&gt;
  &lt;li&gt;클라이언트는 전달 받은 정보를 기반으로 권한 서버에 &lt;code class=&quot;highlighter-rouge&quot;&gt;access token&lt;/code&gt; 획득 요청&lt;/li&gt;
  &lt;li&gt;Access token을 돌려줌&lt;/li&gt;
  &lt;li&gt;획득한 &lt;code class=&quot;highlighter-rouge&quot;&gt;access token&lt;/code&gt;을 사용해 리소스 서버에 사용자의 데이터를 요청&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-client-credentials-grant-type-방식&quot;&gt;4. Client Credentials Grant Type 방식&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/web/web_2_4.png&quot; alt=&quot;Client Credentials Grant Type 방식&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;리소스 주인이 access token 정보를 &lt;code class=&quot;highlighter-rouge&quot;&gt;직접&lt;/code&gt; 권한 서버에 요청&lt;/li&gt;
  &lt;li&gt;Access token을 돌려줌&lt;/li&gt;
  &lt;li&gt;획득한 &lt;code class=&quot;highlighter-rouge&quot;&gt;access token&lt;/code&gt;을 사용해 리소스 서버에 사용자의 데이터를 요청
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;p&gt;Oauth2.0의 인증 방식에 대하여 간략하게 알아보았다. 다음 포스팅에서는 각 방식을 직접 구현할 예정이다.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="web" /><summary type="html">들어가기 앞서 지난 글에서 oauth2.0의 기초 및 구성에 대하여 알아보았다. 이번 글에서는 실제로 다음과 같은 oauth2.0의 인증 방식에 대하여 알아볼 예정이다. Authorization Code Grant Type Implicit Grant Type Resource Owner Password Credentials Grant Type Client Credentials Grant Type</summary></entry><entry><title type="html">[Mac]백 쿼트(`) 입력하는 법</title><link href="https://owin2828.github.io/devlog/2020/03/11/etc-4.html" rel="alternate" type="text/html" title="[Mac]백 쿼트(`) 입력하는 법" /><published>2020-03-11T15:09:00+09:00</published><updated>2020-03-11T15:09:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/03/11/etc-4</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/03/11/etc-4.html">&lt;h2 id=&quot;-입력하기&quot;&gt;(`) 입력하기&lt;/h2&gt;
&lt;p&gt;맥을 사용하다보면, 한글을 타이핑하다가 (`)버튼을 누르면 원하는 grave는 나오지 않고 (₩)가 나오는 것을 볼 수 있다. 
Markdown 문서나 개발자들에게는 여러모로 불편한 일인데, 다음과 같은 해결법을 공유한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;기본-키-설정-파일-생성&quot;&gt;기본 키 설정 파일 생성&lt;/h4&gt;
&lt;p&gt;다음의 내용을 터미널에서 입력한다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Keybindings 디렉토리 생성&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/Library
&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;KeyBindings

&lt;span class=&quot;c&quot;&gt;# DefaultkeyBinding.dict 파일 생성&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;KeyBindings
&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;DefaultkeyBinding.dict
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;설정-파일-변경&quot;&gt;설정 파일 변경&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultkeyBinding.dict&lt;/code&gt; 파일에 다음과 같은 내용을 추가한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;₩&quot; = (&quot;insertText:&quot;, &quot;`&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;맥을 &lt;code class=&quot;highlighter-rouge&quot;&gt;재부팅&lt;/code&gt;하자 변경사항이 적용될 것이다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>owin2828</name></author><category term="etc" /><summary type="html">(`) 입력하기 맥을 사용하다보면, 한글을 타이핑하다가 (`)버튼을 누르면 원하는 grave는 나오지 않고 (₩)가 나오는 것을 볼 수 있다. Markdown 문서나 개발자들에게는 여러모로 불편한 일인데, 다음과 같은 해결법을 공유한다.</summary></entry><entry><title type="html">[Oauth] Oauth2.0의 등장배경, 역할 및 기본 정보</title><link href="https://owin2828.github.io/devlog/2020/03/11/web-3.html" rel="alternate" type="text/html" title="[Oauth] Oauth2.0의 등장배경, 역할 및 기본 정보" /><published>2020-03-11T14:54:00+09:00</published><updated>2020-03-11T14:54:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/03/11/web-3</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/03/11/web-3.html">&lt;h2 id=&quot;들어가기-앞서&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Oauth2.0&lt;/code&gt;의 기초에 대해 알아보고자 한다. 
많은 자료가 있지만, 정확한 이해를 위해 oauth2.0의 &lt;code class=&quot;highlighter-rouge&quot;&gt;개념&lt;/code&gt;부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;구현&lt;/code&gt;까지 직접하며 글을 남기고자 한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;자세한 개념 설명은 다음과 같은 더 좋은 글들을 찾아보기 바란다.&lt;br /&gt;
  &lt;a href=&quot;https://opentutorials.org/course/3405&quot;&gt;생활코딩 oauth2.0&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-인증-vs-인가&quot;&gt;1. 인증 vs 인가&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;본격적으로 oauth2.0를 살펴보기 전에 다음과 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;용어&lt;/code&gt;의 의미를 짚고 가자.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;인증&lt;/code&gt;(Authentication)&lt;br /&gt;
인증이란, &lt;code class=&quot;highlighter-rouge&quot;&gt;신원을 확인&lt;/code&gt; 하는 행위이다.&lt;br /&gt;
즉, 어떠한 주권을 행사할 자격이 있는지를 검증하는 단계이다.&lt;br /&gt;
그렇기 때문에 인증을 한다고 해서, 주체에게 새로운 권한이 부여되지는 않는다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;인가&lt;/code&gt;(Authorization)&lt;br /&gt;
인가란 &lt;code class=&quot;highlighter-rouge&quot;&gt;승인&lt;/code&gt;이라고도 불리는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;권한을 부여&lt;/code&gt;하는 행위이다.&lt;br /&gt;
즉, 인가를 받은 대상이 새로운 자격을 얻게 되어 제한된 리소스에 접근이 가능하다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-oauth20의-등장배경&quot;&gt;2. Oauth2.0의 등장배경&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;권한이 각 사용자에게 부여되는 경우에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;반드시&lt;/code&gt; 권한 소유자에 대한 인증절차를 거치게 된다. 
웹에서 이러한 가장 보편적인 방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;ID/PW&lt;/code&gt; 방식으로 로그인하는 것이다. 
사용자가 입력한 정보를 서버에 전송하여 인증이 성공할 경우, &lt;code class=&quot;highlighter-rouge&quot;&gt;쿠키&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;세션&lt;/code&gt; 값을 저장함으로써 권한이 부여된다. 
이런 방식은 한 번의 로그인으로 세션이 종료되기 전까지 제한된 기능을 수행할 수 있어, &lt;code class=&quot;highlighter-rouge&quot;&gt;간편&lt;/code&gt;하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;효율적&lt;/code&gt;인 방식으로 널리 사용된다. 
하지만 이러한 쿠키 기반 권한 부여는 다음과 같은 &lt;code class=&quot;highlighter-rouge&quot;&gt;단점&lt;/code&gt;을 지닌다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서버에 요청이 올때마다 DB를 통해 현재 상태를 매번 확인하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;낭비&lt;/code&gt;가 발생한다.&lt;/li&gt;
  &lt;li&gt;모바일 앱에 적합하지 &lt;code class=&quot;highlighter-rouge&quot;&gt;않다&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;서로 다른 서비스 간에 정보를 공유하기 &lt;code class=&quot;highlighter-rouge&quot;&gt;어렵다&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 단점을 해결하기 위해 IETF는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Oauth&lt;/code&gt;라는 프레임워크를 만들게 된다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;oauth1과 oauth2는 완전히 &lt;code class=&quot;highlighter-rouge&quot;&gt;다른&lt;/code&gt; 프로토콜이며, 호환되지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-oauth20의-4가지-역할&quot;&gt;3. Oauth2.0의 4가지 역할&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Oauth2.0의 시나리오에는 다음과 같은 4가지 역할이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/web/web_1_1.jpg&quot; alt=&quot;Oauth2 역할, 출처: http://tutorials.jenkov.com/oauth2/roles.html&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Resource Owner&lt;/code&gt;&lt;br /&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;사용자&lt;/code&gt;로서 자신의 리소스에 대한 접근 권한을 가지고 있는 주체이다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Client&lt;/code&gt;&lt;br /&gt;
  사용자가 &lt;code class=&quot;highlighter-rouge&quot;&gt;접근하는 서비스&lt;/code&gt;로서 사용자의 데이터에 대한 요청을 보내는 주체이다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Resource Server&lt;/code&gt;&lt;br /&gt;
  사용자의 &lt;code class=&quot;highlighter-rouge&quot;&gt;데이터를 보유&lt;/code&gt;한 기관으로서 유효한 권한을 부여받은 client가 요청할 경우 제공한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Authorization Server&lt;/code&gt; &lt;br /&gt;
  사용자의 데이터에 접근할 &lt;code class=&quot;highlighter-rouge&quot;&gt;권한을 제공&lt;/code&gt;하는 서버이다. client의 요청에 따라 사용자에게 &lt;code class=&quot;highlighter-rouge&quot;&gt;정보제공 동의&lt;/code&gt;를 받은 후, 권한을 부여한다.
    &lt;blockquote&gt;
      &lt;p&gt;규모가 작을 경우, Resource Server와 Authorization Server를 하나의 서버로 구현하기도 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-oauth20의-기본-정보&quot;&gt;4. Oauth2.0의 기본 정보&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Oauth2.0에는 다음과 같은 세 가지의 기본 정보가 존재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;등록정보&lt;/code&gt;&lt;br /&gt;
  서비스를 제공하는 Client는 사전에 Authorization Server에 &lt;code class=&quot;highlighter-rouge&quot;&gt;등록&lt;/code&gt;해야한다. 
  새로운 서비스가 출시될 때마다 정보를 갱신하여 제출한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Redirect URI&lt;/code&gt;&lt;br /&gt;
  Authorization Server는 사용자가 &lt;code class=&quot;highlighter-rouge&quot;&gt;정보제공 동의&lt;/code&gt;를 하게되면 사용자를 등록된 &lt;code class=&quot;highlighter-rouge&quot;&gt;Redirect URI&lt;/code&gt;로 이동시킨다. 
  만약 등록되지 않은 Redirect URI를 담은 요청이 들어오면 &lt;code class=&quot;highlighter-rouge&quot;&gt;무효&lt;/code&gt; 처리한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Client ID&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;Client Secret&lt;/code&gt;&lt;br /&gt;
  새로 등록하는 Client는 Authorization Server로 부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;Client ID&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Client Secret&lt;/code&gt;을 발급받는다. 
  Client ID는 노출되어도 상관 없지만, Client Secret는 &lt;code class=&quot;highlighter-rouge&quot;&gt;절대&lt;/code&gt; 노출되어서는 안된다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;끝마치며&quot;&gt;끝마치며&lt;/h2&gt;
&lt;p&gt;Oauth2.0에 대하여 간략하게 알아보았다. 다음 포스팅에서는 oauth2.0의 &lt;code class=&quot;highlighter-rouge&quot;&gt;4가지 인증 방식&lt;/code&gt;에 대하여 알아볼 예정이다.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="web" /><summary type="html">들어가기 앞서 Oauth2.0의 기초에 대해 알아보고자 한다. 많은 자료가 있지만, 정확한 이해를 위해 oauth2.0의 개념부터 구현까지 직접하며 글을 남기고자 한다. 자세한 개념 설명은 다음과 같은 더 좋은 글들을 찾아보기 바란다. 생활코딩 oauth2.0</summary></entry><entry><title type="html">[AWS] IAM</title><link href="https://owin2828.github.io/devlog/2020/01/29/aws-7.html" rel="alternate" type="text/html" title="[AWS] IAM" /><published>2020-01-29T09:51:00+09:00</published><updated>2020-01-29T09:51:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/29/aws-7</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/29/aws-7.html">&lt;h2 id=&quot;id0&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;본 포스팅에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;IAM&lt;/code&gt;에 대해 살펴보고, 접근 제어 및 권한 설정을 하는 방법에 대해 알아볼 예정이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;id1&quot;&gt;1. IAM이란?&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IAM&lt;/code&gt;은 Identity and Access Management의 약자로, AWS 리소스에 대한 접근을 안전하게 제어할 수 있는 웹 서비스이다.&lt;br /&gt;
이 설정을 통해 리소스를 사용하도록 인증하거나, 권한을 부여할 수 있다.&lt;/p&gt;

&lt;p&gt;처음 AWS 계정을 생성하게 되면, 해당 계정에 모든 리소스에 접근할 수 있는 권한이 부여된 &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; 계정이 생성된다.&lt;br /&gt;
이러한 사용자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;root 사용자&lt;/code&gt;라고 부르며, 로그인할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;Email&lt;/code&gt;을 입력하여 로그인하게 된다.&lt;br /&gt;
이에 AWS는 일상작업뿐 아니라 관리작업에도 이 루트사용자를 사용하는 것을 &lt;code class=&quot;highlighter-rouge&quot;&gt;비권장&lt;/code&gt;한다.&lt;br /&gt;
대신 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/best-practices.html&quot;&gt;이곳&lt;/a&gt;과 같은 방법으로 IAM 사용자를 생성할 때만 사용하도록 권장한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;즉 루트 사용자는 계정 및 서비스 관기 작업에만 사용하기를 권장한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;id2&quot;&gt;2. IAM의 기능&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;IAM은 다양한 기능을 제공하지만, 주로 사용하게 될 기능은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AWS 계정에 대한 공유 접근제어&lt;/li&gt;
  &lt;li&gt;권한을 세분화하여 부여&lt;/li&gt;
  &lt;li&gt;MFA(멀티 팩터 인증)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;더 구체적인 사항은 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/introduction.html&quot;&gt;AWS 공식 홈페이지&lt;/a&gt;를 참고하기 바란다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;id3&quot;&gt;3. IAM 유저 생성&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;콘솔에 로그인하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;내 보안자격 증명&lt;/code&gt;을 눌러준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위와 같은 팝업창이 뜨게 되는데 여기서 빨간 사각형의 버튼을 클릭한다.
    &lt;blockquote&gt;
      &lt;p&gt;혹은 서비스에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;IAM&lt;/code&gt;을 검색하여 들어가도 된다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;사용자 추가&lt;/code&gt; 버튼을 눌러 새로운 IAM 사용자를 추가해준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생성할 사용자의 이름을 입력한다.&lt;/li&gt;
  &lt;li&gt;액세스 유형은 &lt;code class=&quot;highlighter-rouge&quot;&gt;콘솔&lt;/code&gt;로 설정한다. (추후, 키를 발급받을 수 있다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;권한 설정에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;그룹 생성&lt;/code&gt;을 클릭한다.&lt;br /&gt;
그룹에 권한을 설정하고 유저를 추가하면, 관리가 &lt;code class=&quot;highlighter-rouge&quot;&gt;편리&lt;/code&gt;하다.
    &lt;blockquote&gt;
      &lt;p&gt;만약 특정 유저에게서 권한을 제거하고 싶다면, 그룹에서 사용자를 제거하면 된다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;그룹 이름을 지정후, &lt;code class=&quot;highlighter-rouge&quot;&gt;AdministratorAccess&lt;/code&gt;를 체크하여 관리자 권한을 해당 그룹에 부여한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;그룹 생성&lt;/code&gt;을 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위와 같이 성공적으로 추가되었음을 확인할 수 있고, 다음 단계로 넘어간다.
    &lt;blockquote&gt;
      &lt;p&gt;다음 단계는 &lt;code class=&quot;highlighter-rouge&quot;&gt;태그&lt;/code&gt;이지만, 딱히 추가할 태그가 없으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;검토&lt;/code&gt;로 가도록 한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생성한 정보를 확인 후, &lt;code class=&quot;highlighter-rouge&quot;&gt;사용자 만들기&lt;/code&gt;를 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용자들이 접속할 &lt;code class=&quot;highlighter-rouge&quot;&gt;콘솔 주소&lt;/code&gt;가 표시되며, 해당 주소를 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;IAM 유저&lt;/code&gt;로 로그인이 가능하다.&lt;/li&gt;
  &lt;li&gt;사용자의 액세스 키(액세스 키 ID &amp;amp; 보안 액세스 키)를 확인하려면, &lt;code class=&quot;highlighter-rouge&quot;&gt;표시&lt;/code&gt; 버튼을 눌러 확인한다.&lt;/li&gt;
  &lt;li&gt;액세스 키를 저장하려면, &lt;code class=&quot;highlighter-rouge&quot;&gt;.csv 다운로드&lt;/code&gt; 버튼을 클릭한 후 안전한 위치에 저장한다.
    &lt;blockquote&gt;
      &lt;p&gt;보안 액세스 키는 이 단계에서만 확인 및 다운로드가 가능하다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;다시는&lt;/code&gt; 확인하거나 다운로드 할 수 없으므로 주의하자.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IAM 유저&lt;/code&gt;가 생성됨을 확인할 수 있다.&lt;br /&gt;
앞으로는 IAM유저로 로그인하여 네트워크를 구성하면 된다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;id4&quot;&gt;4. 루트계정 MFA 활성화&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;AWS에서 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;MFA&lt;/code&gt;는 보안을 강화하는 수단이다. AWS계정 및 개별 IAM 사용자들에 대해 AWS MFA를 활성화할 수 있다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;루트계정&lt;/code&gt;에는 MFA를 활성화하는것이 권장되며, 현재는 토큰 기반의 가상 MfA 어플리케이션만 존재한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;2019.02.01 이후로 SMS 문자 메세지 기반 방식은 더이상 지원되지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;좌측메뉴의 &lt;code class=&quot;highlighter-rouge&quot;&gt;대시보드&lt;/code&gt;를 누른 후, 사진처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;MFA 관리&lt;/code&gt; 버튼을 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MFA 활성화&lt;/code&gt; 버튼을 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_13.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;가상 MFA 디바이스&lt;/code&gt;를 체크하고 계속을 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_14.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QR 코드 표시&lt;/code&gt;를 클릭하여 나오는 QR 코드를 &lt;code class=&quot;highlighter-rouge&quot;&gt;Google OTP&lt;/code&gt;를 설치하여 스캔하면 MFA 코드가 생성된다.&lt;/li&gt;
  &lt;li&gt;생성된 2개의 &lt;code class=&quot;highlighter-rouge&quot;&gt;MFA 코드&lt;/code&gt;를 입력하여 할당을 누른다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_15.png&quot; alt=&quot;&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;성공적으로 할당시, 사진과 같이 성공했다는 표시가 되며, 루트계정 로그인은 &lt;code class=&quot;highlighter-rouge&quot;&gt;MFA&lt;/code&gt; 인증을 해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_16.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;루트 계정으로 로그인할 시 &lt;code class=&quot;highlighter-rouge&quot;&gt;MFA&lt;/code&gt; 코드를 입력하는 화면이 뜨게되며,  &lt;code class=&quot;highlighter-rouge&quot;&gt;Google OTP&lt;/code&gt;에서 코드를 입력하면 로그인할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;id5&quot;&gt;5. IAM 역할 부여&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;IAM에서 제공하는 기능중 &lt;code class=&quot;highlighter-rouge&quot;&gt;역할&lt;/code&gt;을 사용하면 특정 인스턴스에 제약을 걸 수 있다.&lt;br /&gt;
이어지는 실습에서는 특정 EC2에게 S3버킷에 대한 접근 제어 역할을 부여하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;좌측 메뉴에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;역할&lt;/code&gt;을 클릭 후, &lt;code class=&quot;highlighter-rouge&quot;&gt;역할 만들기&lt;/code&gt;를 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;우리는 특정 &lt;code class=&quot;highlighter-rouge&quot;&gt;EC2&lt;/code&gt;에게 역할을 부여할 것이므로, 사진처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;EC2&lt;/code&gt;를 클릭 후 다음을 누른다.
    &lt;blockquote&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;다른 AWS 계정&lt;/code&gt;을 눌러 특정 계정에게 역할을 부여할 수도 있다.&lt;br /&gt;
이런 경우, 계정 ID는 이메일 형식의 로그인ID가 아니라, 내 정보에서 볼 수 있는 12자리 숫자 ID이다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;특정 EC2에게 &lt;code class=&quot;highlighter-rouge&quot;&gt;S3&lt;/code&gt;버킷에 접근할 역할을 부여할 것이므로, &lt;code class=&quot;highlighter-rouge&quot;&gt;amazons3fullaccess&lt;/code&gt;를 검색 후 체크하여 다음을 클릭한다.
    &lt;blockquote&gt;
      &lt;p&gt;이어지는 태그는 건너뛰고 &lt;code class=&quot;highlighter-rouge&quot;&gt;검토&lt;/code&gt;를 클릭한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;역할의 이름을 지정하고 방금 지정한 정책이 맞는지 확인 후, 만들기를 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생성한 역할이 지정한 이름과 할당한 서비스를 표시함을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/aws/aws_7_22.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EC2를 생성할 때, 우리가 지정한 역할을 부여할 수 있음을 알 수 있다.&lt;br /&gt;
이렇게 생성된 EC2 인스턴스는 S3외의 다른 서비스의 접근은 &lt;code class=&quot;highlighter-rouge&quot;&gt;불가능&lt;/code&gt;해진다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;id6&quot;&gt;6. 끝마치며&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;공부하며, 내용을 정리하다 보니 문득 &lt;code class=&quot;highlighter-rouge&quot;&gt;정책&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;역할&lt;/code&gt;의 차이가 모호해져 찾아보게 되었다.&lt;br /&gt;
내가 이해한 바로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;정책&lt;/code&gt;은 어떤 일을 할 수 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;권한&lt;/code&gt;과 관련이 있고,&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;역할&lt;/code&gt;은 그러한 &lt;code class=&quot;highlighter-rouge&quot;&gt;권한&lt;/code&gt;들의 논리적인 &lt;code class=&quot;highlighter-rouge&quot;&gt;집합&lt;/code&gt;이라는 것이다.&lt;br /&gt;
자세한 내용은 다음의 두 링크를 참조하자.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/IAM/latest/UserGuide/id_roles_compare-resource-policies.html&quot;&gt;AWS 홈페이지&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://musma.github.io/2019/11/05/about-aws-iam-policy.html&quot;&gt;이현수님 포스팅&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IAM&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;EC2&lt;/code&gt; 이 3가지는 굉장히 중요하다고 한다.&lt;br /&gt;
꼭 잘 설정하여 좋은 환경을 구축하기를 바란다.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="aws" /><summary type="html">들어가기 앞서 본 포스팅에서는 IAM에 대해 살펴보고, 접근 제어 및 권한 설정을 하는 방법에 대해 알아볼 예정이다.</summary></entry><entry><title type="html">[CI/CD] Travis CI 파이프라인 구축하기</title><link href="https://owin2828.github.io/devlog/2020/01/28/cicd-2.html" rel="alternate" type="text/html" title="[CI/CD] Travis CI 파이프라인 구축하기" /><published>2020-01-28T14:20:00+09:00</published><updated>2020-01-28T14:20:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/28/cicd-2</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/28/cicd-2.html">&lt;h2 id=&quot;id0&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://owin2828.github.io/devlog/2020/01/10/aws-1.html&quot;&gt;AWS 기초 시리즈&lt;/a&gt;에서 AWS의 구성을 살펴보았으니, 배운 것을 활용할 겸 AWS를 적극 사용하려한다.&lt;br /&gt;
물론 AWS에서 제공하는 Code Build나 Code Pipeline까지 활용해야 적극 활용이라 할 수 있지만, CI는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Jenkins&lt;/code&gt;를 이용하고 CD는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Code Deploy&lt;/code&gt;를 이용하여 구축하겠다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/codedeploy/&quot;&gt;AWS Code Deploy&lt;/a&gt;는 AWS에서 제공하는 배포 서비스로, EC2에서 사용하는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;무료&lt;/code&gt;이다.&lt;br /&gt;
 &lt;code class=&quot;highlighter-rouge&quot;&gt;On-premise&lt;/code&gt;에서 Code Deploy를 사용하는 경우는 업데이트당 0.02USD가 &lt;code class=&quot;highlighter-rouge&quot;&gt;과금&lt;/code&gt;된다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;id1&quot;&gt;1. Why Jenkins?&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;나는 처음에 다음과 같은 이유로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Travis&lt;/code&gt;를 사용하여 환경을 구축하려 했다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;무료(오픈소스에 한해서)&lt;/li&gt;
  &lt;li&gt;GitHub와의 강력한 연동&lt;/li&gt;
  &lt;li&gt;추가적인 서버 필요 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만 다음과 같은 결정적인 단점이 존재하였고, 이는 굉장히 치명적이었다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;래퍼런스 문서가 &lt;code class=&quot;highlighter-rouge&quot;&gt;없음&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아무것도 아닌 문제처럼 보일 수 있으나, 정말 &lt;code class=&quot;highlighter-rouge&quot;&gt;심각하게&lt;/code&gt; 내가 원하는 방향에 관련된 문서가 없었다.&lt;br /&gt;
Jenkins는 다양한 플러그인과 이를 Script로 표현하여 설정하는 다양한 문서들이 존재하는 반면에, 
Travis는 Unity를 배포하는 방법에 관련된 문서가 &lt;code class=&quot;highlighter-rouge&quot;&gt;없었다&lt;/code&gt;.&lt;br /&gt;
그나마 존재하는 문서들은 Mac 환경에서 진행된 개발이 전부였고, &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ubuntu&lt;/code&gt;에서 진행하는 내게 이는 상당한 부담으로 다가왔다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;아무것도 안하고 이 일만 하면 모를까 회사일과 병행하며 삽질을 하기에는 무리였다..&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;결국 하루의 삽질과 고민 끝에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Jenkins&lt;/code&gt;로 노선을 변경했다. &lt;code class=&quot;highlighter-rouge&quot;&gt;AWS&lt;/code&gt;를 공부하고 배웠으니 이렇게 된김에 free tier가 유지되는 동안에 적극 활용해보자는 다짐과 함께.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;만약, AWS CI/CD에 관심이 있다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;AWS Code Build &amp;amp; Code Pipeline&lt;/code&gt;을 사용하는 것을 추천한다.&lt;br /&gt;
AWS도 훌륭한 빌드 툴과 전체적인 파이프라인을 관리하는 툴을 제공한다.&lt;br /&gt;
하지만 Code Build는 빌드 시간으로, Code Pipeline은 활성화된 파이프라인 개수로 &lt;code class=&quot;highlighter-rouge&quot;&gt;과금&lt;/code&gt;한다.&lt;br /&gt;
물론 &lt;code class=&quot;highlighter-rouge&quot;&gt;프리티어&lt;/code&gt;를 제공하지만, 장기적으로 생각을 잘해서 선택하기를 바란다.&lt;br /&gt;
&lt;a href=&quot;https://jojoldu.tistory.com/282?category=777282&quot;&gt;여기&lt;/a&gt; 훌륭한 자료가 있어 링크를 공유한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;id2&quot;&gt;2. 전체 구성&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/cicd/newcicd_2_1.png&quot; alt=&quot;전체 구성도(App 배포 미완성)&quot; /&gt;
내가 구성한  CI/CD의 전체 구성도는 위와 같은데, Jenkins를 이용하여 CI를 구축하고 Code Deploy를 이용해 CD를 구축하기로 했다.&lt;br /&gt;
둘 사이의 연결은 Jenkins에서 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Code Deploy Pulgin&lt;/code&gt;을 사용할 계획이다.&lt;br /&gt;
이러한 파이프 라인을 통해 S3에 빌드 결과물을 저장하고, AWS &lt;code class=&quot;highlighter-rouge&quot;&gt;Code Deploy&lt;/code&gt;에서 해당 결과물을 가지고 우리가 가동할 APP 서버에 배포하는 방식이다.&lt;br /&gt;
여기서 Jenkins Build Server와 배포를 위한 앱 서버는 모두 &lt;code class=&quot;highlighter-rouge&quot;&gt;EC2&lt;/code&gt;를 사용할 것이며, &lt;a href=&quot;https://owin2828.github.io/devlog/2020/01/15/aws-3.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VPC&lt;/code&gt;&lt;/a&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;IAM&lt;/code&gt; 설정을 통해 해나갈 것이다.&lt;/p&gt;

&lt;p&gt;App은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Unity&lt;/code&gt;를 사용하여 만들고 &lt;code class=&quot;highlighter-rouge&quot;&gt;구글 플레이스토어&lt;/code&gt;에 배포할 계획이며, 하나의 App 서버를 두고 가동할 예정이다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;배포하는 방식은 이 글을 작성하는 시점에서 아직 다른 개발자와 협의가 이루어지지 않아 &lt;code class=&quot;highlighter-rouge&quot;&gt;미완성&lt;/code&gt;으로 남겨놓았다.&lt;br /&gt;
추후, 논의되어 합의가 이루어지면 &lt;code class=&quot;highlighter-rouge&quot;&gt;업데이트&lt;/code&gt;할 예정이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>owin2828</name></author><category term="devops" /><summary type="html">들어가기 앞서 AWS 기초 시리즈에서 AWS의 구성을 살펴보았으니, 배운 것을 활용할 겸 AWS를 적극 사용하려한다. 물론 AWS에서 제공하는 Code Build나 Code Pipeline까지 활용해야 적극 활용이라 할 수 있지만, CI는 Jenkins를 이용하고 CD는 Code Deploy를 이용하여 구축하겠다. AWS Code Deploy는 AWS에서 제공하는 배포 서비스로, EC2에서 사용하는 경우 무료이다. On-premise에서 Code Deploy를 사용하는 경우는 업데이트당 0.02USD가 과금된다.</summary></entry><entry><title type="html">[AWS] Private Subnet, NAT, ELB, Elastic IP, S3 (실습)</title><link href="https://owin2828.github.io/devlog/2020/01/16/aws-6.html" rel="alternate" type="text/html" title="[AWS] Private Subnet, NAT, ELB, Elastic IP, S3 (실습)" /><published>2020-01-16T17:12:00+09:00</published><updated>2020-01-16T17:12:00+09:00</updated><id>https://owin2828.github.io/devlog/2020/01/16/aws-6</id><content type="html" xml:base="https://owin2828.github.io/devlog/2020/01/16/aws-6.html">&lt;h2 id=&quot;id0&quot;&gt;들어가기 앞서&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;본 포스팅에서는 다음과 같은 구성요소들을 살펴볼 예정이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Private Subnet&lt;/code&gt;을 구성하는 방법&lt;/li&gt;
  &lt;li&gt;Bastion Host를 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;Private Subnet&lt;/code&gt;에 접근하는 방법&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NAT&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ELB&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Elastic IP&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S3&lt;/code&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;id1&quot;&gt;1. Private Subnet 구성 및 접근&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;우선 구성하는 방법은 &lt;code class=&quot;highlighter-rouge&quot;&gt;간단&lt;/code&gt;하다. 그냥 라우팅 테이블을 하나 만들고,&lt;br /&gt;
인터넷 게이트웨이를 설정하지 않으면 그만이다.&lt;/p&gt;

&lt;p&gt;접근 또한 마찬가지로 어렵지 않은데, 우선 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bastion Host&lt;/code&gt;로 접속 후&lt;br /&gt;
다시 &lt;code class=&quot;highlighter-rouge&quot;&gt;내부&lt;/code&gt;적으로 접속을 진행하면된다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;대략적으로 그려보면 다음과 같다.&lt;br /&gt;
외부 접속 –&amp;gt; Bastion Host –&amp;gt; Private Subnet&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;약간의 &lt;code class=&quot;highlighter-rouge&quot;&gt;문제&lt;/code&gt;가 있다하면 ssh 접속을 위한 &lt;code class=&quot;highlighter-rouge&quot;&gt;키 페어 관리&lt;/code&gt;인데,&lt;br /&gt;
내부 private subnet에 접속하기 위해 Bastion Host는 각 서브넷의&lt;br /&gt;
키 페어를 &lt;code class=&quot;highlighter-rouge&quot;&gt;가지고&lt;/code&gt; 있어야 한다.&lt;/p&gt;

&lt;p&gt;이런 경우, 관리자들이 적절한 &lt;code class=&quot;highlighter-rouge&quot;&gt;보안 규칙&lt;/code&gt;을 세워 키 페어 관리를 해야한다.&lt;br /&gt;
그렇지 않으면 Bastion Host에 접속하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;모든&lt;/code&gt; private subnet에 접근이 &lt;code class=&quot;highlighter-rouge&quot;&gt;가능&lt;/code&gt;해,&lt;br /&gt;
그냥 &lt;code class=&quot;highlighter-rouge&quot;&gt;모두 public&lt;/code&gt;으로 만든 것이랑 별반 다름이 없을 수 있기 때문이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;id2&quot;&gt;2. NAT(Network Access Translation)&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NAT&lt;/code&gt;는 설명했듯이, 인터넷 게이트웨이를 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;outbound&lt;/code&gt;만 허용한다.&lt;br /&gt;
이는 AWS의 정책으로 외부에서 접근이 불가하다.&lt;/p&gt;

&lt;p&gt;설정하는 방법은 다음과 같이 두 가지 방법이 존재한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;인스턴스&lt;/code&gt;를 생성하여 설정&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;게이트웨이&lt;/code&gt;로 생성하여 설정&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;또한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Elastic IP&lt;/code&gt;를 설정하며 &lt;code class=&quot;highlighter-rouge&quot;&gt;유료&lt;/code&gt; 서비스다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Elastic IP를 사용하는 경우, 서버 재부팅 시에도 IP가 고정된다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;id3&quot;&gt;3. ELB(Elastic Load Balancer)&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_5_19.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;생성&lt;/code&gt;은 서비스에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;EC2&lt;/code&gt;를 검색 후, 좌측 메뉴에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;로드밸런서&lt;/code&gt;에서 할 수 있다.&lt;br /&gt;
생성 시, 3개 중 하나를 고르라고 하는데 기본적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Classic&lt;/code&gt;을 선택하면 된다.&lt;/p&gt;

&lt;p&gt;그 후 대략 다음의 단계에 따라서 구성한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;본인의 VPC와 서브넷을 잘 선택&lt;/li&gt;
  &lt;li&gt;보안그룹 할당: &lt;code class=&quot;highlighter-rouge&quot;&gt;기존&lt;/code&gt;그룹에서 생성한 그룹 선택&lt;/li&gt;
  &lt;li&gt;EC2 인스턴스 추가: 이 단계에서 우리의 &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; 인스턴스를 추가한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와 같은 설정의 이점은 EC2에 ELB를 거치치 않고 들어오는 경우를 막는 것이다.&lt;br /&gt;
즉, prviate EC2에 웹 프로토콜로 접속 시, &lt;code class=&quot;highlighter-rouge&quot;&gt;ELB&lt;/code&gt;를 통해서 접근해야 한다. &lt;br /&gt;
이를 통해 다음과 같은 흐름으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Inbound&lt;/code&gt;를 설정할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;ACL –&amp;gt; ELB –&amp;gt; EC2&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ELB&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bastion Host&lt;/code&gt;를 제외한 나머지 subnet은 &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; 설정을 해야한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;또한 EC2는 다음과 같은 3가지 방법으로 구분이 되는데,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;private IP&lt;/li&gt;
  &lt;li&gt;Public IP + address&lt;/li&gt;
  &lt;li&gt;Unique ID(Instance ID)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 중, 3번째 방법인 &lt;code class=&quot;highlighter-rouge&quot;&gt;유니크&lt;/code&gt;한 ID가 ELB에 제공되어야 밸런싱을 잘 해준다고 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;id4&quot;&gt;4. Elastic IP(탄력적 IP)&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;AWS에서 Elastic IP를 가지고 있지 않은 리소스의 경우,&lt;br /&gt;
재부팅 시 IP의 &lt;code class=&quot;highlighter-rouge&quot;&gt;변경&lt;/code&gt;이 일어난다.&lt;br /&gt;
이러한 현상을 막기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;Elastic IP&lt;/code&gt;를 설정하면 IP가 &lt;code class=&quot;highlighter-rouge&quot;&gt;고정&lt;/code&gt;된다.&lt;/p&gt;

&lt;p&gt;이러한 서비스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Floating&lt;/code&gt;되어 있다고 한다.&lt;br /&gt;
무슨 말이나면, 특정 객체에 묶여있는 것이 아니라&lt;br /&gt;
상황에 따라 이리 붙었다 저리 붙었다가 가능하다는 뜻이다.&lt;/p&gt;

&lt;p&gt;이러한 특징 때문에 특정 서비스가 &lt;code class=&quot;highlighter-rouge&quot;&gt;다운&lt;/code&gt;되면 Elastic IP를&lt;br /&gt;
다른쪽으로 붙여서 트래픽을 그 쪽으로 유도해 &lt;code class=&quot;highlighter-rouge&quot;&gt;장애&lt;/code&gt;에 대처할 수 있게 된다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;End-User에게 보여지는 IP는 &lt;code class=&quot;highlighter-rouge&quot;&gt;고정&lt;/code&gt;된 IP이기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;혹은 서비스를 이관할 때도 이 서비스를 이용하여&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;유동적&lt;/code&gt;으로 트래픽을 처리할 수 있게 된다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;id5&quot;&gt;5. S3(Simple Storage Service)&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/img/aws/aws_6_1.png&quot; alt=&quot;&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;br /&gt;
S3는 VPC &lt;code class=&quot;highlighter-rouge&quot;&gt;외부&lt;/code&gt;에 존재하는 서비스로써 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bucket&lt;/code&gt; 단위로 구분하며,&lt;br /&gt;
AWS에서 S3 서비스를 검색하여 시작할 수 있으며 다음과 같은 특징이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;S3는 내부적으로 2군데 더 &lt;code class=&quot;highlighter-rouge&quot;&gt;미러링&lt;/code&gt;을 한다.&lt;br /&gt;
현재 내 region에 1개 + 가장 가까운 region에 1개에 구성함으로써,&lt;br /&gt;
어떤식으로 장애가 나더라도 &lt;code class=&quot;highlighter-rouge&quot;&gt;대응&lt;/code&gt; 할 수 있는 구조이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;S3는 외부에 보여지지 않으므로, &lt;code class=&quot;highlighter-rouge&quot;&gt;버킷레벨&lt;/code&gt;로 권한을 설정하거나&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;파일레벨&lt;/code&gt;로 권한을 설정할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;S3는 &lt;code class=&quot;highlighter-rouge&quot;&gt;스토리지&lt;/code&gt; 서비스 이므로, &lt;code class=&quot;highlighter-rouge&quot;&gt;DB&lt;/code&gt;와의 연동은 &lt;code class=&quot;highlighter-rouge&quot;&gt;안된다&lt;/code&gt;.&lt;br /&gt;
즉 S3에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Static Data&lt;/code&gt;만 저장할 수 있다.&lt;br /&gt;
이러한 특징으로 인해, 서버사이드 언어를 저장하고 돌려도 &lt;code class=&quot;highlighter-rouge&quot;&gt;작동하지 않는다&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;S3는 &lt;code class=&quot;highlighter-rouge&quot;&gt;AZ&lt;/code&gt; 밖에 존재하게 되므로,&lt;br /&gt;
VPC 안에 있는 객체들과의 통신은 &lt;code class=&quot;highlighter-rouge&quot;&gt;과금&lt;/code&gt;을 유발하게 된다.&lt;br /&gt;
이 문제를 피하기 위해, S3에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;인증토큰&lt;/code&gt;을 이용하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;허용된&lt;/code&gt; REST API만 받아주면 된다고 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;id6&quot;&gt;6. 끝마치며&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;AWS에 대해서 배워볼까? 로 시작했던 시리즈의 포스팅이 끝났다.&lt;br /&gt;
단순하고 짧게 쓰려고 했지만, 쓰다보니 점점 길어지게 되었다.&lt;/p&gt;

&lt;p&gt;AWS는 늘 t2.micro 인스턴스 하나만 띡 만들어서 대충 써봤던게 전부였는데,&lt;br /&gt;
이번 기회로 새로운 눈이 뜨여지게 된 것 같다.&lt;/p&gt;

&lt;p&gt;배웠으니 앞으로 어딘가에 적용하기를 기대하고,&lt;br /&gt;
누군가에게 이 글이 도움이 되었길 바라며 포스팅을 마친다.&lt;/p&gt;</content><author><name>owin2828</name></author><category term="aws" /><summary type="html">들어가기 앞서 본 포스팅에서는 다음과 같은 구성요소들을 살펴볼 예정이다. Private Subnet을 구성하는 방법 Bastion Host를 통해 Private Subnet에 접근하는 방법 NAT ELB Elastic IP S3</summary></entry></feed>